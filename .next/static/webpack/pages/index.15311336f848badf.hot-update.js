"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/aes.ts":
/*!**************************!*\
  !*** ./src/utils/aes.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AesMode: () => (/* binding */ AesMode),\n/* harmony export */   GALOIS_MUL_2: () => (/* binding */ GALOIS_MUL_2),\n/* harmony export */   GALOIS_MUL_3: () => (/* binding */ GALOIS_MUL_3),\n/* harmony export */   KeyLength: () => (/* binding */ KeyLength),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   PaddingType: () => (/* binding */ PaddingType),\n/* harmony export */   RCON: () => (/* binding */ RCON),\n/* harmony export */   SBOX: () => (/* binding */ SBOX),\n/* harmony export */   addRoundKey: () => (/* binding */ addRoundKey),\n/* harmony export */   aesEncrypt: () => (/* binding */ aesEncrypt),\n/* harmony export */   aesRound: () => (/* binding */ aesRound),\n/* harmony export */   applyAnsiX923Padding: () => (/* binding */ applyAnsiX923Padding),\n/* harmony export */   applyPKCS7Padding: () => (/* binding */ applyPKCS7Padding),\n/* harmony export */   bytesToBinary: () => (/* binding */ bytesToBinary),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   generateIV: () => (/* binding */ generateIV),\n/* harmony export */   generateRandomKey: () => (/* binding */ generateRandomKey),\n/* harmony export */   getAesSteps: () => (/* binding */ getAesSteps),\n/* harmony export */   getAesStepsForBlock: () => (/* binding */ getAesStepsForBlock),\n/* harmony export */   getKeyExpansionSteps: () => (/* binding */ getKeyExpansionSteps),\n/* harmony export */   getKeyScheduleDetailedSteps: () => (/* binding */ getKeyScheduleDetailedSteps),\n/* harmony export */   keyExpansion: () => (/* binding */ keyExpansion),\n/* harmony export */   keyToBytes: () => (/* binding */ keyToBytes),\n/* harmony export */   mixColumns: () => (/* binding */ mixColumns),\n/* harmony export */   realAesDecrypt: () => (/* binding */ realAesDecrypt),\n/* harmony export */   realAesEncrypt: () => (/* binding */ realAesEncrypt),\n/* harmony export */   removeAnsiX923Padding: () => (/* binding */ removeAnsiX923Padding),\n/* harmony export */   shiftRows: () => (/* binding */ shiftRows),\n/* harmony export */   subBytes: () => (/* binding */ subBytes),\n/* harmony export */   testSpecificCase: () => (/* binding */ testSpecificCase),\n/* harmony export */   textToBlocks: () => (/* binding */ textToBlocks),\n/* harmony export */   textToState: () => (/* binding */ textToState)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(pages-dir-browser)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// AES mode enum\nvar AesMode = /*#__PURE__*/ function(AesMode) {\n    AesMode[\"ECB\"] = \"ECB\";\n    AesMode[\"CBC\"] = \"CBC\";\n    AesMode[\"CTR\"] = \"CTR\";\n    return AesMode;\n}({});\n// Padding enum\nvar PaddingType = /*#__PURE__*/ function(PaddingType) {\n    PaddingType[\"PKCS7\"] = \"PKCS7\";\n    PaddingType[\"ANSI_X923\"] = \"ANSI X.923\";\n    PaddingType[\"NONE\"] = \"None\";\n    return PaddingType;\n}({});\n// Output format enum\nvar OutputFormat = /*#__PURE__*/ function(OutputFormat) {\n    OutputFormat[\"BASE64\"] = \"Base64\";\n    OutputFormat[\"HEX\"] = \"Hex\";\n    OutputFormat[\"BINARY\"] = \"Binary\";\n    return OutputFormat;\n}({});\n// Key length enum\nvar KeyLength = /*#__PURE__*/ function(KeyLength) {\n    KeyLength[KeyLength[\"AES_128\"] = 128] = \"AES_128\";\n    KeyLength[KeyLength[\"AES_192\"] = 192] = \"AES_192\";\n    KeyLength[KeyLength[\"AES_256\"] = 256] = \"AES_256\";\n    return KeyLength;\n}({});\nconst getNumRounds = (keyLength)=>keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\nconst getKeyByteLength = (keyLength)=>keyLength / 8;\n// AES S-Box (Standard Rijndael S-box)\nconst SBOX = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\n// AES Rcon (Round Constants)\nconst RCON = [\n    0x00,\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a\n];\n// Used in MixColumns\nconst GALOIS_MUL_2 = [\n    0x00,\n    0x02,\n    0x04,\n    0x06,\n    0x08,\n    0x0a,\n    0x0c,\n    0x0e,\n    0x10,\n    0x12,\n    0x14,\n    0x16,\n    0x18,\n    0x1a,\n    0x1c,\n    0x1e,\n    0x20,\n    0x22,\n    0x24,\n    0x26,\n    0x28,\n    0x2a,\n    0x2c,\n    0x2e,\n    0x30,\n    0x32,\n    0x34,\n    0x36,\n    0x38,\n    0x3a,\n    0x3c,\n    0x3e,\n    0x40,\n    0x42,\n    0x44,\n    0x46,\n    0x48,\n    0x4a,\n    0x4c,\n    0x4e,\n    0x50,\n    0x52,\n    0x54,\n    0x56,\n    0x58,\n    0x5a,\n    0x5c,\n    0x5e,\n    0x60,\n    0x62,\n    0x64,\n    0x66,\n    0x68,\n    0x6a,\n    0x6c,\n    0x6e,\n    0x70,\n    0x72,\n    0x74,\n    0x76,\n    0x78,\n    0x7a,\n    0x7c,\n    0x7e,\n    0x80,\n    0x82,\n    0x84,\n    0x86,\n    0x88,\n    0x8a,\n    0x8c,\n    0x8e,\n    0x90,\n    0x92,\n    0x94,\n    0x96,\n    0x98,\n    0x9a,\n    0x9c,\n    0x9e,\n    0xa0,\n    0xa2,\n    0xa4,\n    0xa6,\n    0xa8,\n    0xaa,\n    0xac,\n    0xae,\n    0xb0,\n    0xb2,\n    0xb4,\n    0xb6,\n    0xb8,\n    0xba,\n    0xbc,\n    0xbe,\n    0xc0,\n    0xc2,\n    0xc4,\n    0xc6,\n    0xc8,\n    0xca,\n    0xcc,\n    0xce,\n    0xd0,\n    0xd2,\n    0xd4,\n    0xd6,\n    0xd8,\n    0xda,\n    0xdc,\n    0xde,\n    0xe0,\n    0xe2,\n    0xe4,\n    0xe6,\n    0xe8,\n    0xea,\n    0xec,\n    0xee,\n    0xf0,\n    0xf2,\n    0xf4,\n    0xf6,\n    0xf8,\n    0xfa,\n    0xfc,\n    0xfe,\n    0x1b,\n    0x19,\n    0x1f,\n    0x1d,\n    0x13,\n    0x11,\n    0x17,\n    0x15,\n    0x0b,\n    0x09,\n    0x0f,\n    0x0d,\n    0x03,\n    0x01,\n    0x07,\n    0x05,\n    0x3b,\n    0x39,\n    0x3f,\n    0x3d,\n    0x33,\n    0x31,\n    0x37,\n    0x35,\n    0x2b,\n    0x29,\n    0x2f,\n    0x2d,\n    0x23,\n    0x21,\n    0x27,\n    0x25,\n    0x5b,\n    0x59,\n    0x5f,\n    0x5d,\n    0x53,\n    0x51,\n    0x57,\n    0x55,\n    0x4b,\n    0x49,\n    0x4f,\n    0x4d,\n    0x43,\n    0x41,\n    0x47,\n    0x45,\n    0x7b,\n    0x79,\n    0x7f,\n    0x7d,\n    0x73,\n    0x71,\n    0x77,\n    0x75,\n    0x6b,\n    0x69,\n    0x6f,\n    0x6d,\n    0x63,\n    0x61,\n    0x67,\n    0x65,\n    0x9b,\n    0x99,\n    0x9f,\n    0x9d,\n    0x93,\n    0x91,\n    0x97,\n    0x95,\n    0x8b,\n    0x89,\n    0x8f,\n    0x8d,\n    0x83,\n    0x81,\n    0x87,\n    0x85,\n    0xbb,\n    0xb9,\n    0xbf,\n    0xbd,\n    0xb3,\n    0xb1,\n    0xb7,\n    0xb5,\n    0xab,\n    0xa9,\n    0xaf,\n    0xad,\n    0xa3,\n    0xa1,\n    0xa7,\n    0xa5,\n    0xdb,\n    0xd9,\n    0xdf,\n    0xdd,\n    0xd3,\n    0xd1,\n    0xd7,\n    0xd5,\n    0xcb,\n    0xc9,\n    0xcf,\n    0xcd,\n    0xc3,\n    0xc1,\n    0xc7,\n    0xc5,\n    0xfb,\n    0xf9,\n    0xff,\n    0xfd,\n    0xf3,\n    0xf1,\n    0xf7,\n    0xf5,\n    0xeb,\n    0xe9,\n    0xef,\n    0xed,\n    0xe3,\n    0xe1,\n    0xe7,\n    0xe5\n];\nconst GALOIS_MUL_3 = [\n    0x00,\n    0x03,\n    0x06,\n    0x05,\n    0x0c,\n    0x0f,\n    0x0a,\n    0x09,\n    0x18,\n    0x1b,\n    0x1e,\n    0x1d,\n    0x14,\n    0x17,\n    0x12,\n    0x11,\n    0x30,\n    0x33,\n    0x36,\n    0x35,\n    0x3c,\n    0x3f,\n    0x3a,\n    0x39,\n    0x28,\n    0x2b,\n    0x2e,\n    0x2d,\n    0x24,\n    0x27,\n    0x22,\n    0x21,\n    0x60,\n    0x63,\n    0x66,\n    0x65,\n    0x6c,\n    0x6f,\n    0x6a,\n    0x69,\n    0x78,\n    0x7b,\n    0x7e,\n    0x7d,\n    0x74,\n    0x77,\n    0x72,\n    0x71,\n    0x50,\n    0x53,\n    0x56,\n    0x55,\n    0x5c,\n    0x5f,\n    0x5a,\n    0x59,\n    0x48,\n    0x4b,\n    0x4e,\n    0x4d,\n    0x44,\n    0x47,\n    0x42,\n    0x41,\n    0xc0,\n    0xc3,\n    0xc6,\n    0xc5,\n    0xcc,\n    0xcf,\n    0xca,\n    0xc9,\n    0xd8,\n    0xdb,\n    0xde,\n    0xdd,\n    0xd4,\n    0xd7,\n    0xd2,\n    0xd1,\n    0xf0,\n    0xf3,\n    0xf6,\n    0xf5,\n    0xfc,\n    0xff,\n    0xfa,\n    0xf9,\n    0xe8,\n    0xeb,\n    0xee,\n    0xed,\n    0xe4,\n    0xe7,\n    0xe2,\n    0xe1,\n    0xa0,\n    0xa3,\n    0xa6,\n    0xa5,\n    0xac,\n    0xaf,\n    0xaa,\n    0xa9,\n    0xb8,\n    0xbb,\n    0xbe,\n    0xbd,\n    0xb4,\n    0xb7,\n    0xb2,\n    0xb1,\n    0x90,\n    0x93,\n    0x96,\n    0x95,\n    0x9c,\n    0x9f,\n    0x9a,\n    0x99,\n    0x88,\n    0x8b,\n    0x8e,\n    0x8d,\n    0x84,\n    0x87,\n    0x82,\n    0x81,\n    0x9b,\n    0x98,\n    0x9d,\n    0x9e,\n    0x97,\n    0x94,\n    0x91,\n    0x92,\n    0x83,\n    0x80,\n    0x85,\n    0x86,\n    0x8f,\n    0x8c,\n    0x89,\n    0x8a,\n    0xab,\n    0xa8,\n    0xad,\n    0xae,\n    0xa7,\n    0xa4,\n    0xa1,\n    0xa2,\n    0xb3,\n    0xb0,\n    0xb5,\n    0xb6,\n    0xbf,\n    0xbc,\n    0xb9,\n    0xba,\n    0xfb,\n    0xf8,\n    0xfd,\n    0xfe,\n    0xf7,\n    0xf4,\n    0xf1,\n    0xf2,\n    0xe3,\n    0xe0,\n    0xe5,\n    0xe6,\n    0xef,\n    0xec,\n    0xe9,\n    0xea,\n    0xcb,\n    0xc8,\n    0xcd,\n    0xce,\n    0xc7,\n    0xc4,\n    0xc1,\n    0xc2,\n    0xd3,\n    0xd0,\n    0xd5,\n    0xd6,\n    0xdf,\n    0xdc,\n    0xd9,\n    0xda,\n    0x5b,\n    0x58,\n    0x5d,\n    0x5e,\n    0x57,\n    0x54,\n    0x51,\n    0x52,\n    0x43,\n    0x40,\n    0x45,\n    0x46,\n    0x4f,\n    0x4c,\n    0x49,\n    0x4a,\n    0x6b,\n    0x68,\n    0x6d,\n    0x6e,\n    0x67,\n    0x64,\n    0x61,\n    0x62,\n    0x73,\n    0x70,\n    0x75,\n    0x76,\n    0x7f,\n    0x7c,\n    0x79,\n    0x7a,\n    0x3b,\n    0x38,\n    0x3d,\n    0x3e,\n    0x37,\n    0x34,\n    0x31,\n    0x32,\n    0x23,\n    0x20,\n    0x25,\n    0x26,\n    0x2f,\n    0x2c,\n    0x29,\n    0x2a,\n    0x0b,\n    0x08,\n    0x0d,\n    0x0e,\n    0x07,\n    0x04,\n    0x01,\n    0x02,\n    0x13,\n    0x10,\n    0x15,\n    0x16,\n    0x1f,\n    0x1c,\n    0x19,\n    0x1a\n];\n// Convert text to a state matrix - returns array of bytes\nconst textToState = (text)=>{\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Pad to 16 bytes if needed\n    while(bytes.length < 16){\n        bytes.push(0);\n    }\n    const block = bytes.slice(0, 16);\n    // AES state is column-major: state[r + 4*c] = input[4*c + r]\n    return block;\n};\n// Convert a hex key to array of bytes\nconst keyToBytes = (key)=>{\n    // Remove spaces and convert to lowercase\n    const cleanKey = key.replace(/\\s/g, '').toLowerCase();\n    // If it's a hex string, convert it\n    if (/^[0-9a-f]+$/.test(cleanKey)) {\n        const bytes = [];\n        for(let i = 0; i < Math.min(cleanKey.length, 32); i += 2){\n            bytes.push(parseInt(cleanKey.substr(i, 2), 16));\n        }\n        // Pad to 16 bytes if needed\n        while(bytes.length < 16){\n            bytes.push(0);\n        }\n        return bytes.slice(0, 16);\n    }\n    // Otherwise, treat as UTF-8 text\n    return textToState(key);\n};\n// Generate a random key as byte array based on key length\nconst generateRandomKey = function() {\n    let keyLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;\n    const keyBytes = keyLength / 8;\n    const bytes = [];\n    for(let i = 0; i < keyBytes; i++){\n        bytes.push(Math.floor(Math.random() * 256));\n    }\n    return bytes;\n};\n// Format bytes as hex\nconst bytesToHex = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(16).padStart(2, '0')).join(joinChar);\n};\n// Format bytes as binary\nconst bytesToBinary = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(2).padStart(8, '0')).join(joinChar);\n};\n// SubBytes operation - substitute each byte with its S-box value\nconst subBytes = (state)=>{\n    return state.map((byte)=>SBOX[byte]);\n};\n// ShiftRows operation - rotate rows of the state matrix\nconst shiftRows = (state)=>{\n    const result = [\n        ...state\n    ];\n    // Column-major state index helper: idx(row, col) = row + 4*col\n    const idx = (row, col)=>row + 4 * col;\n    for(let row = 1; row < 4; row++){\n        const rowValues = [\n            state[idx(row, 0)],\n            state[idx(row, 1)],\n            state[idx(row, 2)],\n            state[idx(row, 3)]\n        ];\n        const shifted = rowValues.slice(row).concat(rowValues.slice(0, row));\n        for(let col = 0; col < 4; col++){\n            result[idx(row, col)] = shifted[col];\n        }\n    }\n    return result;\n};\n// MixColumns operation - mix data within columns\nconst mixColumns = (state)=>{\n    const result = [\n        ...state\n    ];\n    const idx = (row, col)=>row + 4 * col;\n    for(let i = 0; i < 4; i++){\n        const s0 = state[idx(0, i)];\n        const s1 = state[idx(1, i)];\n        const s2 = state[idx(2, i)];\n        const s3 = state[idx(3, i)];\n        result[idx(0, i)] = GALOIS_MUL_2[s0] ^ GALOIS_MUL_3[s1] ^ s2 ^ s3;\n        result[idx(1, i)] = s0 ^ GALOIS_MUL_2[s1] ^ GALOIS_MUL_3[s2] ^ s3;\n        result[idx(2, i)] = s0 ^ s1 ^ GALOIS_MUL_2[s2] ^ GALOIS_MUL_3[s3];\n        result[idx(3, i)] = GALOIS_MUL_3[s0] ^ s1 ^ s2 ^ GALOIS_MUL_2[s3];\n    }\n    return result;\n};\n// AddRoundKey operation - XOR state with round key\nconst addRoundKey = (state, roundKey)=>{\n    return state.map((byte, i)=>byte ^ roundKey[i]);\n};\n// Kalitni kengaytirish — raund kalitlarini generatsiya qilish\nconst keyExpansion = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    const roundKeys = [\n        key.slice()\n    ]; // 1-raund kaliti boshlang‘ich kalitning o‘zi hisoblanadi\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const newKey = prevKey.slice();\n        // Oxirgi word ni aylantirib, S-box ni qo‘llang\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const subWord = rotWord.map((byte)=>SBOX[byte]);\n        // Birinchi baytni Rcon bilan XOR qilinadi\n        subWord[0] ^= RCON[round];\n        // Yangi kalitning birinchi word i generatsiya qilinadi\n        newKey[0] = prevKey[0] ^ subWord[0];\n        newKey[1] = prevKey[1] ^ subWord[1];\n        newKey[2] = prevKey[2] ^ subWord[2];\n        newKey[3] = prevKey[3] ^ subWord[3];\n        // Qolgan word lar hosil qilinadi\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            // AES-256 holatida har to‘rtinchi word ga qo‘shimcha S-box (SubWord) qo‘llanadi\n            if (keyLength === 256 && i === 4) {\n                const tempWord = [\n                    newKey[offset - 4],\n                    newKey[offset - 3],\n                    newKey[offset - 2],\n                    newKey[offset - 1]\n                ];\n                const subTempWord = tempWord.map((byte)=>SBOX[byte]);\n                newKey[offset] = prevKey[offset] ^ subTempWord[0];\n                newKey[offset + 1] = prevKey[offset + 1] ^ subTempWord[1];\n                newKey[offset + 2] = prevKey[offset + 2] ^ subTempWord[2];\n                newKey[offset + 3] = prevKey[offset + 3] ^ subTempWord[3];\n            } else {\n                newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n                newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n                newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n                newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            }\n        }\n        roundKeys.push(newKey);\n    }\n    return roundKeys;\n};\n// Perform one round of AES\nconst aesRound = (state, roundKey, isLastRound)=>{\n    let newState = subBytes(state);\n    newState = shiftRows(newState);\n    if (!isLastRound) {\n        newState = mixColumns(newState);\n    }\n    newState = addRoundKey(newState, roundKey);\n    return newState;\n};\n// Complete AES encryption\nconst aesEncrypt = (plaintext, key)=>{\n    // Initial state\n    const state = textToState(plaintext);\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial round - just AddRoundKey\n    let currentState = addRoundKey(state, roundKeys[0]);\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        currentState = aesRound(currentState, roundKeys[round], round === 10);\n    }\n    return currentState;\n};\n// Convert full text to array of 16-byte blocks\nconst textToBlocks = function(text) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"PKCS7\";\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    // Convert CryptoJS WordArray to byte array, respecting sigBytes\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Apply padding\n    let paddedBytes;\n    if (padding === \"PKCS7\") {\n        paddedBytes = applyPKCS7Padding(bytes);\n    } else if (padding === \"ANSI X.923\") {\n        paddedBytes = applyAnsiX923Padding(bytes);\n    } else {\n        paddedBytes = [\n            ...bytes\n        ];\n        // For NONE padding, must be multiple of 16\n        while(paddedBytes.length % 16 !== 0){\n            paddedBytes.push(0);\n        }\n    }\n    // Split into 16-byte blocks\n    const blocks = [];\n    for(let i = 0; i < paddedBytes.length; i += 16){\n        blocks.push(paddedBytes.slice(i, i + 16));\n    }\n    return blocks;\n};\n// Apply PKCS7 padding\nconst applyPKCS7Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    for(let i = 0; i < paddingLength; i++){\n        padded.push(paddingLength);\n    }\n    return padded;\n};\n// Apply ANSI X.923 padding\nconst applyAnsiX923Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    // Add padding bytes (0x00) except the last byte\n    for(let i = 0; i < paddingLength - 1; i++){\n        padded.push(0x00);\n    }\n    // Add the padding length as the last byte\n    padded.push(paddingLength);\n    return padded;\n};\n// Remove ANSI X.923 padding\nconst removeAnsiX923Padding = (data)=>{\n    const paddingLength = data[data.length - 1];\n    return data.slice(0, data.length - paddingLength);\n};\n// Get IV for CBC mode\nconst generateIV = ()=>{\n    const iv = [];\n    for(let i = 0; i < 16; i++){\n        iv.push(Math.floor(Math.random() * 256));\n    }\n    return iv;\n};\n// Get AES steps for a single block (16 bytes)\nconst getAesStepsForBlock = function(block, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", blockIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, previousCiphertextBlock = arguments.length > 4 ? arguments[4] : void 0, iv = arguments.length > 5 ? arguments[5] : void 0;\n    const steps = [];\n    // Ensure block is exactly 16 bytes\n    const plaintextBytes = [\n        ...block\n    ];\n    while(plaintextBytes.length < 16){\n        plaintextBytes.push(0);\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Asl ochiq matn\"),\n        state: plaintextBytes,\n        explanation: \"Blok \".concat(blockIndex + 1, \" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.\")\n    });\n    const initialState = plaintextBytes;\n    const roundKeys = keyExpansion(key);\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (blockIndex === 0 && iv) {\n                currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — IV bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: iv,\n                    explanation: \"CBC: birinchi blok IV bilan XOR qilinadi.\"\n                });\n            } else if (previousCiphertextBlock) {\n                currentState = initialState.map((byte, i)=>byte ^ previousCiphertextBlock[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — Oldingi ciphertext bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: previousCiphertextBlock,\n                    explanation: \"CBC: keyingi bloklar oldingi ciphertext bloki bilan XOR qilinadi.\"\n                });\n            } else {\n                currentState = initialState;\n            }\n            break;\n        case \"CTR\":\n            if (!iv) {\n                return {\n                    steps: [],\n                    finalState: plaintextBytes\n                };\n            }\n            const counterBlock = [\n                ...iv\n            ];\n            let counterValue = blockIndex;\n            for(let i = 15; i >= 0 && counterValue > 0; i--){\n                const sum = counterBlock[i] + (counterValue & 0xff);\n                counterBlock[i] = sum & 0xff;\n                counterValue = (counterValue >> 8) + (sum >> 8);\n            }\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter\"),\n                state: counterBlock,\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter.\")\n            });\n            currentState = counterBlock;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Boshlang'ich\"),\n                state: currentState,\n                explanation: \"ECB: blok \".concat(blockIndex + 1, \" mustaqil shifrlanadi.\")\n            });\n            break;\n    }\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — 0-bosqich — AddRoundKey\"),\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    for(let round = 1; round <= 10; round++){\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState\n        });\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows\n            });\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter XOR\"),\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter XOR.\"),\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Yakuniy\"),\n        state: finalState,\n        explanation: \"Blok \".concat(blockIndex + 1, \" uchun yakuniy shifrlangan natija.\")\n    });\n    return {\n        steps,\n        finalState\n    };\n};\nconst getAesSteps = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", providedIv = arguments.length > 4 ? arguments[4] : void 0;\n    const steps = [];\n    let iv = providedIv ? [\n        ...providedIv\n    ] : undefined;\n    // Convert full text to blocks\n    const blocks = textToBlocks(plaintext, padding);\n    const allBlocks = [];\n    // Convert plaintext to bytes (for first block visualization)\n    let plaintextBytes = blocks[0] || textToState(plaintext);\n    steps.push({\n        description: 'Asl ochiq matn',\n        state: plaintextBytes,\n        explanation: 'Ochiq matn \"'.concat(plaintext, '\" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.')\n    });\n    // Apply padding if needed\n    if (padding === \"ANSI X.923\") {\n        plaintextBytes = applyAnsiX923Padding(plaintextBytes);\n        steps.push({\n            description: 'ANSI X.923 to‘ldirishdan keyin',\n            state: plaintextBytes,\n            explanation: 'ANSI X.923 to‘ldirish nollar bilan to‘ldiradi va oxirgi byte ga to‘ldirish uzunligini qo‘yadi.'\n        });\n    }\n    // Generate IV for CBC/CTR mode only if not provided\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n        if (blocks.length === 1) {\n            // Only show IV step if single block (for backward compatibility)\n            const ivDescription = mode === \"CBC\" ? 'Boshlang\\'ich vektor (Initialization Vector, IV)' : 'Counter (Nonce)';\n            const ivExplanation = \"\".concat(mode === \"CBC\" ? 'CBC' : 'CTR', \" rejimi uchun 16-bayt tasodifiy \").concat(mode === \"CBC\" ? 'IV' : 'Nonce', \" yaratiladi.\");\n            steps.push({\n                description: ivDescription,\n                state: iv,\n                explanation: ivExplanation\n            });\n        }\n    }\n    // Start encryption process (for first block visualization)\n    const initialState = plaintextBytes;\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial setup based on mode\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (!iv) iv = generateIV(); // Failsafe\n            // XOR plaintext with IV\n            currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n            steps.push({\n                description: 'Boshlang\\'ich holatni IV bilan XOR qilish',\n                state: currentState,\n                activeIndices: Array.from(Array(16).keys()),\n                previousState: initialState,\n                roundKey: iv,\n                explanation: \"CBC rejimida shifrlash boshlanishidan oldin ochiq matn IV bilan XOR qilinadi. Bu jarayon CBC rejimining asosiy xususiyatidir - har bir ochiq matn bloki avvalgi shifrlangan matn bloki (yoki birinchi blok uchun IV) bilan XOR qilinadi, keyin shifrlanadi. Bu bir xil ochiq matn bloklarini turli shifrlangan matn bloklarga aylantiradi va shifrlangan matndagi naqshlarni yashirishga yordam beradi.\"\n            });\n            break;\n        case \"CTR\":\n            // In CTR mode, we encrypt a counter value instead of the plaintext\n            const counter = iv || generateIV();\n            if (!iv) iv = counter;\n            steps.push({\n                description: 'Counter qiymati',\n                state: counter,\n                explanation: 'CTR rejimida ochiq matn o‘rniga counter qiymati shifrlanadi.'\n            });\n            currentState = counter;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: 'Boshlang‘ich holat (ochiq matn)',\n                state: currentState,\n                explanation: 'ECB rejimida ochiq matn bloklari mustaqil ravishda shifrlanadi.'\n            });\n            break;\n    }\n    // Initial round - just AddRoundKey (Round 0)\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: '0-bosqich — Boshlang\\'ich AddRoundKey',\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        // SubBytes\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState // Add previous state for S-box lookup\n        });\n        // ShiftRows\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes // Add previous state for comparison\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            // MixColumns (not in final round)\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"\".concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows // Add previous state for MixColumns comparison\n            });\n            // AddRoundKey\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            // Final round has no MixColumns\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    // Final output based on mode\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            // Output is the current state (already completed encryption)\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            // XOR the encrypted counter with plaintext\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: 'Ochiq matn shifrlangan hisoblagich bilan XOR amaliyotida birlashtiriladi.',\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: 'CTR rejimida, yakuniy bosqichda shifrlangan hisoblagich ochiq matn bilan XOR amaliyoti orqali birlashtiriladi va natijada shifrlangan matn hosil bo‘ladi.',\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: 'Yakuniy shifrlangan matn',\n        state: finalState,\n        explanation: \"\".concat(mode, \" rejimida AES-128 yordamida olingan yakuniy shifrlangan natija.\")\n    });\n    // Process all blocks for multi-block support\n    let previousCiphertextBlock;\n    const combinedFinalStates = [];\n    // Generate IV if needed\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n    }\n    for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){\n        const blockResult = getAesStepsForBlock(blocks[blockIndex], key, mode, blockIndex, previousCiphertextBlock, iv);\n        allBlocks.push({\n            blockIndex,\n            steps: blockResult.steps,\n            finalState: blockResult.finalState\n        });\n        combinedFinalStates.push(...blockResult.finalState);\n        // For CBC mode, use current ciphertext as previous for next block\n        if (mode === \"CBC\") {\n            previousCiphertextBlock = blockResult.finalState;\n        }\n    }\n    // Use combined final states if we have multiple blocks, otherwise use single block result\n    const finalStateToUse = blocks.length > 1 ? combinedFinalStates : finalState;\n    // Convert the final state to the requested output format\n    const finalWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create(new Uint8Array(finalStateToUse));\n    const finalCiphertextBase64 = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.stringify(finalWordArray);\n    const finalCiphertextHex = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(finalWordArray);\n    const finalCiphertextBinary = bytesToBinary(finalStateToUse, '');\n    return {\n        steps,\n        finalCiphertext: {\n            base64: finalCiphertextBase64,\n            hex: finalCiphertextHex,\n            binary: finalCiphertextBinary\n        },\n        iv,\n        allBlocks: allBlocks.length > 1 ? allBlocks : undefined\n    };\n};\n// Get key expansion steps with detailed explanations\nconst getKeyExpansionSteps = (key)=>{\n    const roundKeys = keyExpansion(key);\n    const steps = [];\n    steps.push({\n        description: 'Boshlang‘ich kalit',\n        key: roundKeys[0],\n        explanation: 'Bu foydalanuvchi tomonidan berilgan asl 128-bitli kalitdir.'\n    });\n    for(let round = 1; round <= 10; round++){\n        const prevKey = roundKeys[round - 1];\n        const currentKey = roundKeys[round];\n        // Calculate the transformations for a more detailed explanation\n        const lastWord = [\n            prevKey[12],\n            prevKey[13],\n            prevKey[14],\n            prevKey[15]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        const rconValue = RCON[round];\n        const transformedWord = [\n            ...sboxWord\n        ];\n        transformedWord[0] ^= rconValue;\n        // Calculate the first word of the previous key and its XOR with the transformed word\n        const firstWordPrev = [\n            prevKey[0],\n            prevKey[1],\n            prevKey[2],\n            prevKey[3]\n        ];\n        const xorResult = firstWordPrev.map((byte, index)=>byte ^ transformedWord[index]);\n        // Show the key with highlighted cells for the new word\n        steps.push({\n            description: \"Raund kaliti \".concat(round),\n            key: currentKey,\n            explanation: \"\\n        \".concat(round, \"-raund uchun kalitni kengaytirish jarayoni:\\n        1. Oldingi kalitning oxirgi word qismini oling: [\").concat(lastWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        2. Wordni aylantiring: [\").concat(rotWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        3. Aylantirilgan word ga S-box ni qo‘llang: [\").concat(sboxWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        4. Birinchi baytga RCON (Round Constant \").concat(rconValue.toString(16), \") ni qo‘llang:\\n          Natija: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        5. Oldingi kalitning birinchi word i: [\").concat(firstWordPrev.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] ni o‘zgartirilgan word bilan XOR qiling: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"], natijada: [\").concat(xorResult.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] hosil bo‘ladi. So‘ngra qolgan word lar shu tarzda hosil qilinadi.\\n      \"),\n            highlightedCells: [\n                0,\n                1,\n                2,\n                3\n            ] // Highlight the first word that's directly transformed\n        });\n    }\n    return steps;\n};\n// Return intermediate steps for each word expansion for visualization\nfunction getKeyScheduleDetailedSteps(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    // Flatten byte array -> words\n    let prevKey = key.slice();\n    let roundKeys = [\n        prevKey.slice()\n    ];\n    // For result visualization: each step for each round\n    let stepsPerRound = [];\n    for(let round = 1; round <= numRounds; round++){\n        let stepDetails = [];\n        let newKey = prevKey.slice();\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        // Step 1: RotWord\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        stepDetails.push({\n            step: 'RotWord',\n            input: lastWord.slice(),\n            output: rotWord.slice()\n        });\n        // Step 2: SubBytes (S-box)\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        stepDetails.push({\n            step: 'SubBytes',\n            input: rotWord.slice(),\n            output: sboxWord.slice()\n        });\n        // Step 3: Rcon to first byte\n        const rconValue = RCON[round];\n        const rconWord = sboxWord.slice();\n        rconWord[0] ^= rconValue;\n        stepDetails.push({\n            step: 'Apply Rcon',\n            input: sboxWord.slice(),\n            rcon: rconValue,\n            output: rconWord.slice()\n        });\n        // Step 4: XOR with previous (first word)\n        const xorResult = [\n            prevKey[0] ^ rconWord[0],\n            prevKey[1] ^ rconWord[1],\n            prevKey[2] ^ rconWord[2],\n            prevKey[3] ^ rconWord[3]\n        ];\n        stepDetails.push({\n            step: 'XOR with previous',\n            inputs: [\n                prevKey.slice(0, 4),\n                rconWord.slice()\n            ],\n            output: xorResult.slice()\n        });\n        // Save and update newKey\n        newKey[0] = xorResult[0];\n        newKey[1] = xorResult[1];\n        newKey[2] = xorResult[2];\n        newKey[3] = xorResult[3];\n        // Other words (only simple xor)\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n            newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n            newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n            newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            stepDetails.push({\n                step: 'XOR chain',\n                inputs: [\n                    newKey.slice(offset - 4, offset),\n                    prevKey.slice(offset, offset + 4)\n                ],\n                output: newKey.slice(offset, offset + 4),\n                wordIndex: i\n            });\n        }\n        stepsPerRound.push({\n            round,\n            stepDetails,\n            roundKey: newKey.slice()\n        });\n        prevKey = newKey.slice();\n        roundKeys.push(prevKey);\n    }\n    return stepsPerRound;\n}\n// Real AES encryption using CryptoJS for verification\nconst realAesEncrypt = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", outputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    // Handle case where key is shorter than required by keyLength\n    const cleanKey = key.replace(/\\s/g, '');\n    let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n    // Ensure key is of correct length for the selected key length\n    const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n    if (keyHex.length < requiredHexChars) {\n        // Pad key if too short\n        keyHex = keyHex.padEnd(requiredHexChars, '0');\n    } else if (keyHex.length > requiredHexChars) {\n        // Truncate key if too long\n        keyHex = keyHex.substring(0, requiredHexChars);\n    }\n    const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n    let paddingOption;\n    switch(padding){\n        case \"ANSI X.923\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n            };\n            break;\n        case \"None\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n            };\n            break;\n        default:\n            paddingOption = {}; // default is PKCS7\n    }\n    let modeOption;\n    let iv;\n    switch(mode){\n        case \"CBC\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                iv: iv,\n                ...paddingOption\n            };\n            break;\n        case \"CTR\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                iv: iv,\n                counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                    0,\n                    0,\n                    0,\n                    0\n                ], 16),\n                ...paddingOption\n            };\n            break;\n        default:\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                ...paddingOption\n            };\n            break;\n    }\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(plaintext, keyWordArray, modeOption);\n    // Get all output formats\n    const base64Output = encrypted.toString();\n    const cipherParams = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.CipherParams.create({\n        ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(base64Output)\n    });\n    const hexOutput = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().format.Hex.stringify(cipherParams);\n    // For binary, we need to convert the hex to binary\n    const hexBytes = hexOutput.match(/.{2}/g).map((hex)=>parseInt(hex, 16));\n    const binaryOutput = bytesToBinary(hexBytes, '');\n    // Select the requested format for primary output\n    let primaryOutput;\n    switch(outputFormat){\n        case \"Hex\":\n            primaryOutput = hexOutput;\n            break;\n        case \"Binary\":\n            primaryOutput = binaryOutput;\n            break;\n        default:\n            primaryOutput = base64Output;\n            break;\n    }\n    return {\n        ciphertext: primaryOutput,\n        iv: iv ? crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(iv) : undefined,\n        formats: {\n            base64: base64Output,\n            hex: hexOutput,\n            binary: binaryOutput\n        }\n    };\n};\n// Real AES decryption using CryptoJS\nconst realAesDecrypt = function(ciphertext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", inputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    try {\n        // Handle case where key is shorter than required by keyLength\n        const cleanKey = key.replace(/\\s/g, '');\n        let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n        // Ensure key is of correct length for the selected key length\n        const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n        if (keyHex.length < requiredHexChars) {\n            // Pad key if too short\n            keyHex = keyHex.padEnd(requiredHexChars, '0');\n        } else if (keyHex.length > requiredHexChars) {\n            // Truncate key if too long\n            keyHex = keyHex.substring(0, requiredHexChars);\n        }\n        const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n        // Parse ciphertext based on input format\n        let ciphertextWordArray;\n        switch(inputFormat){\n            case \"Hex\":\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ciphertext.replace(/\\s/g, ''));\n                break;\n            case \"Binary\":\n                var _ciphertext_replace_match;\n                // Convert binary string to hex first\n                const hexFromBinary = ((_ciphertext_replace_match = ciphertext.replace(/\\s/g, '').match(/.{8}/g)) === null || _ciphertext_replace_match === void 0 ? void 0 : _ciphertext_replace_match.map((bin)=>parseInt(bin, 2).toString(16).padStart(2, '0')).join('')) || '';\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(hexFromBinary);\n                break;\n            default:\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(ciphertext);\n                break;\n        }\n        let paddingOption;\n        switch(padding){\n            case \"ANSI X.923\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n                };\n                break;\n            case \"None\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n                };\n                break;\n            default:\n                paddingOption = {}; // default is PKCS7\n        }\n        let modeOption;\n        let iv;\n        switch(mode){\n            case \"CBC\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CBC rejimi uchun IV kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                    iv: iv,\n                    ...paddingOption\n                };\n                break;\n            case \"CTR\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CTR rejimi uchun IV (Nonce) kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                    iv: iv,\n                    counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                        0,\n                        0,\n                        0,\n                        0\n                    ], 16),\n                    ...paddingOption\n                };\n                break;\n            default:\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                    ...paddingOption\n                };\n                break;\n        }\n        const decrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt({\n            ciphertext: ciphertextWordArray\n        }, keyWordArray, modeOption);\n        const plaintext = decrypted.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n        if (!plaintext) {\n            return {\n                plaintext: '',\n                error: 'Deshifrlash muvaffaqiyatsiz. Kalit yoki shifrlangan matn noto\\'g\\'ri.'\n            };\n        }\n        return {\n            plaintext\n        };\n    } catch (error) {\n        return {\n            plaintext: '',\n            error: error.message || 'Deshifrlashda xatolik yuz berdi'\n        };\n    }\n};\n// Test specific case for \"Salom, AES!\" with key \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\"\nconst testSpecificCase = ()=>{\n    const plaintext = \"Salom, AES!\";\n    const key = \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\";\n    // Create key and input as byte arrays\n    const keyBytes = [];\n    for(let i = 0; i < key.length; i += 2){\n        keyBytes.push(parseInt(key.substr(i, 2), 16));\n    }\n    // Use our implementation\n    const { finalCiphertext } = getAesSteps(plaintext, keyBytes, \"ECB\", \"PKCS7\");\n    // Use CryptoJS implementation\n    const cryptoResult = realAesEncrypt(plaintext, key, \"ECB\", \"PKCS7\", \"Hex\");\n    return \"\\n    Bizning implementatsiyamiz (HEX): \".concat(finalCiphertext.hex, \"\\n    CryptoJS implementatsiyasi (HEX): \").concat(cryptoResult.formats.hex, \"\\n    Kutilayotgan natija: 30484B8F8C6BB09CA3F94C6F84F0305E\\n  \");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9hZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUVqQyxnQkFBZ0I7QUFDVCxxQ0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELGVBQWU7QUFDUix5Q0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELHFCQUFxQjtBQUNkLDBDQUFLQzs7OztXQUFBQTtNQUlYO0FBRUQsa0JBQWtCO0FBQ1gsdUNBQUtDOzs7O1dBQUFBO01BSVg7QUFFRCxNQUFNQyxlQUFlLENBQUNDLFlBQ3BCQSxvQkFBa0MsS0FDbENBLG9CQUFrQyxLQUFLO0FBR3pDLE1BQU1DLG1CQUFtQixDQUFDRCxZQUFpQ0EsWUFBWTtBQUV2RSxzQ0FBc0M7QUFDL0IsTUFBTUUsT0FBTztJQUNsQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRixDQUFDO0FBRUYsNkJBQTZCO0FBQ3RCLE1BQU1DLE9BQU87SUFDbEI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLHFCQUFxQjtBQUNkLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVLLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxjQUFjLENBQUNDO0lBQzFCLE1BQU1DLFlBQVlkLG9EQUFZLENBQUNnQixJQUFJLENBQUNDLEtBQUssQ0FBQ0o7SUFDMUMsTUFBTUssUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxXQUFXTCxVQUFVSyxRQUFRO0lBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixVQUFVTyxLQUFLLENBQUNDLE1BQU0sRUFBRUYsSUFBSztRQUMvQyxNQUFNRyxPQUFPVCxVQUFVTyxLQUFLLENBQUNELEVBQUU7UUFDL0IsTUFBTUksa0JBQWtCQyxLQUFLQyxHQUFHLENBQUMsR0FBR1AsV0FBV0MsSUFBSTtRQUNuRCxJQUFJSSxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsSUFBSztRQUNwRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDSixPQUFPO0lBQzlDO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU9MLE1BQU1JLE1BQU0sR0FBRyxHQUFJO1FBQ3hCSixNQUFNUyxJQUFJLENBQUM7SUFDYjtJQUVBLE1BQU1DLFFBQVFWLE1BQU1XLEtBQUssQ0FBQyxHQUFHO0lBQzdCLDZEQUE2RDtJQUM3RCxPQUFPRDtBQUNULEVBQUU7QUFFRixzQ0FBc0M7QUFDL0IsTUFBTUUsYUFBYSxDQUFDQztJQUN6Qix5Q0FBeUM7SUFDekMsTUFBTUMsV0FBV0QsSUFBSUUsT0FBTyxDQUFDLE9BQU8sSUFBSUMsV0FBVztJQUVuRCxtQ0FBbUM7SUFDbkMsSUFBSSxjQUFjQyxJQUFJLENBQUNILFdBQVc7UUFDaEMsTUFBTWQsUUFBUSxFQUFFO1FBQ2hCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJSyxLQUFLQyxHQUFHLENBQUNNLFNBQVNWLE1BQU0sRUFBRSxLQUFLRixLQUFLLEVBQUc7WUFDekRGLE1BQU1TLElBQUksQ0FBQ1MsU0FBU0osU0FBU0ssTUFBTSxDQUFDakIsR0FBRyxJQUFJO1FBQzdDO1FBQ0EsNEJBQTRCO1FBQzVCLE1BQU9GLE1BQU1JLE1BQU0sR0FBRyxHQUFJO1lBQ3hCSixNQUFNUyxJQUFJLENBQUM7UUFDYjtRQUNBLE9BQU9ULE1BQU1XLEtBQUssQ0FBQyxHQUFHO0lBQ3hCO0lBRUEsaUNBQWlDO0lBQ2pDLE9BQU9qQixZQUFZbUI7QUFDckIsRUFBRTtBQUVGLDBEQUEwRDtBQUNuRCxNQUFNTyxvQkFBb0I7UUFBQ2hDO0lBQ2hDLE1BQU1pQyxXQUFXakMsWUFBWTtJQUM3QixNQUFNWSxRQUFRLEVBQUU7SUFDaEIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUltQixVQUFVbkIsSUFBSztRQUNqQ0YsTUFBTVMsSUFBSSxDQUFDRixLQUFLZSxLQUFLLENBQUNmLEtBQUtnQixNQUFNLEtBQUs7SUFDeEM7SUFDQSxPQUFPdkI7QUFDVCxFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTXdCLGFBQWEsU0FBQ3hCO1FBQWlCeUIsNEVBQW1CO0lBQzdELE9BQU96QixNQUFNMEIsR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDTDtBQUNwRSxFQUFFO0FBRUYseUJBQXlCO0FBQ2xCLE1BQU1NLGdCQUFnQixTQUFDL0I7UUFBaUJ5Qiw0RUFBbUI7SUFDaEUsT0FBT3pCLE1BQU0wQixHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUNMO0FBQ25FLEVBQUU7QUFFRixpRUFBaUU7QUFDMUQsTUFBTU8sV0FBVyxDQUFDQztJQUN2QixPQUFPQSxNQUFNUCxHQUFHLENBQUNDLENBQUFBLE9BQVFyQyxJQUFJLENBQUNxQyxLQUFLO0FBQ3JDLEVBQUU7QUFFRix3REFBd0Q7QUFDakQsTUFBTU8sWUFBWSxDQUFDRDtJQUN4QixNQUFNRSxTQUFTO1dBQUlGO0tBQU07SUFFekIsK0RBQStEO0lBQy9ELE1BQU1HLE1BQU0sQ0FBQ0MsS0FBYUMsTUFBZ0JELE1BQU0sSUFBSUM7SUFFcEQsSUFBSyxJQUFJRCxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztRQUNoQyxNQUFNRSxZQUFZO1lBQUNOLEtBQUssQ0FBQ0csSUFBSUMsS0FBSyxHQUFHO1lBQUVKLEtBQUssQ0FBQ0csSUFBSUMsS0FBSyxHQUFHO1lBQUVKLEtBQUssQ0FBQ0csSUFBSUMsS0FBSyxHQUFHO1lBQUVKLEtBQUssQ0FBQ0csSUFBSUMsS0FBSyxHQUFHO1NBQUM7UUFDbEcsTUFBTUcsVUFBVUQsVUFBVTVCLEtBQUssQ0FBQzBCLEtBQUtJLE1BQU0sQ0FBQ0YsVUFBVTVCLEtBQUssQ0FBQyxHQUFHMEI7UUFDL0QsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztZQUNoQ0gsTUFBTSxDQUFDQyxJQUFJQyxLQUFLQyxLQUFLLEdBQUdFLE9BQU8sQ0FBQ0YsSUFBSTtRQUN0QztJQUNGO0lBRUEsT0FBT0g7QUFDVCxFQUFFO0FBRUYsaURBQWlEO0FBQzFDLE1BQU1PLGFBQWEsQ0FBQ1Q7SUFDekIsTUFBTUUsU0FBUztXQUFJRjtLQUFNO0lBQ3pCLE1BQU1HLE1BQU0sQ0FBQ0MsS0FBYUMsTUFBZ0JELE1BQU0sSUFBSUM7SUFDcEQsSUFBSyxJQUFJcEMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDMUIsTUFBTXlDLEtBQUtWLEtBQUssQ0FBQ0csSUFBSSxHQUFHbEMsR0FBRztRQUMzQixNQUFNMEMsS0FBS1gsS0FBSyxDQUFDRyxJQUFJLEdBQUdsQyxHQUFHO1FBQzNCLE1BQU0yQyxLQUFLWixLQUFLLENBQUNHLElBQUksR0FBR2xDLEdBQUc7UUFDM0IsTUFBTTRDLEtBQUtiLEtBQUssQ0FBQ0csSUFBSSxHQUFHbEMsR0FBRztRQUUzQmlDLE1BQU0sQ0FBQ0MsSUFBSSxHQUFHbEMsR0FBRyxHQUFHVixZQUFZLENBQUNtRCxHQUFHLEdBQUdsRCxZQUFZLENBQUNtRCxHQUFHLEdBQUdDLEtBQUtDO1FBQy9EWCxNQUFNLENBQUNDLElBQUksR0FBR2xDLEdBQUcsR0FBR3lDLEtBQUtuRCxZQUFZLENBQUNvRCxHQUFHLEdBQUduRCxZQUFZLENBQUNvRCxHQUFHLEdBQUdDO1FBQy9EWCxNQUFNLENBQUNDLElBQUksR0FBR2xDLEdBQUcsR0FBR3lDLEtBQUtDLEtBQUtwRCxZQUFZLENBQUNxRCxHQUFHLEdBQUdwRCxZQUFZLENBQUNxRCxHQUFHO1FBQ2pFWCxNQUFNLENBQUNDLElBQUksR0FBR2xDLEdBQUcsR0FBR1QsWUFBWSxDQUFDa0QsR0FBRyxHQUFHQyxLQUFLQyxLQUFLckQsWUFBWSxDQUFDc0QsR0FBRztJQUNuRTtJQUNBLE9BQU9YO0FBQ1QsRUFBRTtBQUVGLG1EQUFtRDtBQUM1QyxNQUFNWSxjQUFjLENBQUNkLE9BQWlCZTtJQUMzQyxPQUFPZixNQUFNUCxHQUFHLENBQUMsQ0FBQ0MsTUFBTXpCLElBQU15QixPQUFPcUIsUUFBUSxDQUFDOUMsRUFBRTtBQUNsRCxFQUFFO0FBRUYsOERBQThEO0FBQ3ZELE1BQU0rQyxlQUFlLFNBQUNwQztRQUFlekI7SUFDMUMsTUFBTThELFdBQVdyQyxJQUFJVCxNQUFNLEdBQUc7SUFDOUIsTUFBTStDLFlBQVkvRCxvQkFBa0MsS0FDbENBLG9CQUFrQyxLQUFLO0lBRXpELE1BQU1nRSxZQUF3QjtRQUFDdkMsSUFBSUYsS0FBSztLQUFHLEVBQUUseURBQXlEO0lBRXRHLElBQUssSUFBSTBDLFFBQVEsR0FBR0EsU0FBU0YsV0FBV0UsUUFBUztRQUMvQyxNQUFNQyxVQUFVRixTQUFTLENBQUNDLFFBQVEsRUFBRTtRQUNwQyxNQUFNRSxTQUFTRCxRQUFRM0MsS0FBSztRQUU1QiwrQ0FBK0M7UUFDL0MsTUFBTTZDLFlBQVlGLFFBQVFsRCxNQUFNLEdBQUc7UUFDbkMsTUFBTXFELFdBQVc7WUFBQ0gsT0FBTyxDQUFDRSxVQUFVO1lBQUVGLE9BQU8sQ0FBQ0UsWUFBWSxFQUFFO1lBQUVGLE9BQU8sQ0FBQ0UsWUFBWSxFQUFFO1lBQUVGLE9BQU8sQ0FBQ0UsWUFBWSxFQUFFO1NBQUM7UUFDN0csTUFBTUUsVUFBVTtZQUFDRCxRQUFRLENBQUMsRUFBRTtZQUFFQSxRQUFRLENBQUMsRUFBRTtZQUFFQSxRQUFRLENBQUMsRUFBRTtZQUFFQSxRQUFRLENBQUMsRUFBRTtTQUFDO1FBQ3BFLE1BQU1FLFVBQVVELFFBQVFoQyxHQUFHLENBQUNDLENBQUFBLE9BQVFyQyxJQUFJLENBQUNxQyxLQUFLO1FBRTlDLDBDQUEwQztRQUMxQ2dDLE9BQU8sQ0FBQyxFQUFFLElBQUlwRSxJQUFJLENBQUM4RCxNQUFNO1FBRXpCLHVEQUF1RDtRQUN2REUsTUFBTSxDQUFDLEVBQUUsR0FBR0QsT0FBTyxDQUFDLEVBQUUsR0FBR0ssT0FBTyxDQUFDLEVBQUU7UUFDbkNKLE1BQU0sQ0FBQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxFQUFFLEdBQUdLLE9BQU8sQ0FBQyxFQUFFO1FBQ25DSixNQUFNLENBQUMsRUFBRSxHQUFHRCxPQUFPLENBQUMsRUFBRSxHQUFHSyxPQUFPLENBQUMsRUFBRTtRQUNuQ0osTUFBTSxDQUFDLEVBQUUsR0FBR0QsT0FBTyxDQUFDLEVBQUUsR0FBR0ssT0FBTyxDQUFDLEVBQUU7UUFFbkMsaUNBQWlDO1FBQ2pDLElBQUssSUFBSXpELElBQUksR0FBR0EsSUFBSWdELFVBQVVoRCxJQUFLO1lBQ2pDLE1BQU0wRCxTQUFTMUQsSUFBSTtZQUNuQixnRkFBZ0Y7WUFDaEYsSUFBSWQscUJBQW1DYyxNQUFNLEdBQUc7Z0JBQzlDLE1BQU0yRCxXQUFXO29CQUFDTixNQUFNLENBQUNLLFNBQVMsRUFBRTtvQkFBRUwsTUFBTSxDQUFDSyxTQUFTLEVBQUU7b0JBQUVMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFO29CQUFFTCxNQUFNLENBQUNLLFNBQVMsRUFBRTtpQkFBQztnQkFDakcsTUFBTUUsY0FBY0QsU0FBU25DLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUXJDLElBQUksQ0FBQ3FDLEtBQUs7Z0JBRW5ENEIsTUFBTSxDQUFDSyxPQUFPLEdBQUdOLE9BQU8sQ0FBQ00sT0FBTyxHQUFHRSxXQUFXLENBQUMsRUFBRTtnQkFDakRQLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFLEdBQUdFLFdBQVcsQ0FBQyxFQUFFO2dCQUN6RFAsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUUsR0FBR0UsV0FBVyxDQUFDLEVBQUU7Z0JBQ3pEUCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRSxHQUFHRSxXQUFXLENBQUMsRUFBRTtZQUMzRCxPQUFPO2dCQUNMUCxNQUFNLENBQUNLLE9BQU8sR0FBR0wsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxPQUFPO2dCQUNyREwsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR0wsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUU7Z0JBQzdETCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRTtnQkFDN0RMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFO1lBQy9EO1FBQ0Y7UUFFQVIsVUFBVTNDLElBQUksQ0FBQzhDO0lBQ2pCO0lBRUEsT0FBT0g7QUFDVCxFQUFFO0FBRUYsMkJBQTJCO0FBQ3BCLE1BQU1XLFdBQVcsQ0FBQzlCLE9BQWlCZSxVQUFvQmdCO0lBQzVELElBQUlDLFdBQVdqQyxTQUFTQztJQUN4QmdDLFdBQVcvQixVQUFVK0I7SUFDckIsSUFBSSxDQUFDRCxhQUFhO1FBQ2hCQyxXQUFXdkIsV0FBV3VCO0lBQ3hCO0lBQ0FBLFdBQVdsQixZQUFZa0IsVUFBVWpCO0lBQ2pDLE9BQU9pQjtBQUNULEVBQUU7QUFFRiwwQkFBMEI7QUFDbkIsTUFBTUMsYUFBYSxDQUFDQyxXQUFtQnREO0lBQzVDLGdCQUFnQjtJQUNoQixNQUFNb0IsUUFBUXZDLFlBQVl5RTtJQUUxQixnQkFBZ0I7SUFDaEIsTUFBTWYsWUFBWUgsYUFBYXBDO0lBRS9CLG1DQUFtQztJQUNuQyxJQUFJdUQsZUFBZXJCLFlBQVlkLE9BQU9tQixTQUFTLENBQUMsRUFBRTtJQUVsRCxjQUFjO0lBQ2QsSUFBSyxJQUFJQyxRQUFRLEdBQUdBLFNBQVMsSUFBSUEsUUFBUztRQUN4Q2UsZUFBZUwsU0FBU0ssY0FBY2hCLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFQSxVQUFVO0lBQ3BFO0lBRUEsT0FBT2U7QUFDVCxFQUFFO0FBRUYsK0NBQStDO0FBQ3hDLE1BQU1DLGVBQWUsU0FBQzFFO1FBQWMyRTtJQUN6QyxNQUFNMUUsWUFBWWQsb0RBQVksQ0FBQ2dCLElBQUksQ0FBQ0MsS0FBSyxDQUFDSjtJQUMxQyxNQUFNSyxRQUFrQixFQUFFO0lBRTFCLGdFQUFnRTtJQUNoRSxNQUFNQyxXQUFXTCxVQUFVSyxRQUFRO0lBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixVQUFVTyxLQUFLLENBQUNDLE1BQU0sRUFBRUYsSUFBSztRQUMvQyxNQUFNRyxPQUFPVCxVQUFVTyxLQUFLLENBQUNELEVBQUU7UUFDL0IsTUFBTUksa0JBQWtCQyxLQUFLQyxHQUFHLENBQUMsR0FBR1AsV0FBV0MsSUFBSTtRQUVuRCxJQUFJSSxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsSUFBSztRQUNwRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDSixPQUFPO0lBQzlDO0lBRUEsZ0JBQWdCO0lBQ2hCLElBQUlrRTtJQUNKLElBQUlELHFCQUErQjtRQUNqQ0MsY0FBY0Msa0JBQWtCeEU7SUFDbEMsT0FBTyxJQUFJc0UsMEJBQW1DO1FBQzVDQyxjQUFjRSxxQkFBcUJ6RTtJQUNyQyxPQUFPO1FBQ0x1RSxjQUFjO2VBQUl2RTtTQUFNO1FBQ3hCLDJDQUEyQztRQUMzQyxNQUFPdUUsWUFBWW5FLE1BQU0sR0FBRyxPQUFPLEVBQUc7WUFDcENtRSxZQUFZOUQsSUFBSSxDQUFDO1FBQ25CO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsTUFBTWlFLFNBQXFCLEVBQUU7SUFDN0IsSUFBSyxJQUFJeEUsSUFBSSxHQUFHQSxJQUFJcUUsWUFBWW5FLE1BQU0sRUFBRUYsS0FBSyxHQUFJO1FBQy9Dd0UsT0FBT2pFLElBQUksQ0FBQzhELFlBQVk1RCxLQUFLLENBQUNULEdBQUdBLElBQUk7SUFDdkM7SUFFQSxPQUFPd0U7QUFDVCxFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTUYsb0JBQW9CLENBQUNHO0lBQ2hDLE1BQU1DLFNBQVM7V0FBSUQ7S0FBSztJQUN4QixNQUFNRSxnQkFBZ0IsS0FBTUYsS0FBS3ZFLE1BQU0sR0FBRztJQUUxQyxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSTJFLGVBQWUzRSxJQUFLO1FBQ3RDMEUsT0FBT25FLElBQUksQ0FBQ29FO0lBQ2Q7SUFFQSxPQUFPRDtBQUNULEVBQUU7QUFFRiwyQkFBMkI7QUFDcEIsTUFBTUgsdUJBQXVCLENBQUNFO0lBQ25DLE1BQU1DLFNBQVM7V0FBSUQ7S0FBSztJQUN4QixNQUFNRSxnQkFBZ0IsS0FBTUYsS0FBS3ZFLE1BQU0sR0FBRztJQUUxQyxnREFBZ0Q7SUFDaEQsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUkyRSxnQkFBZ0IsR0FBRzNFLElBQUs7UUFDMUMwRSxPQUFPbkUsSUFBSSxDQUFDO0lBQ2Q7SUFFQSwwQ0FBMEM7SUFDMUNtRSxPQUFPbkUsSUFBSSxDQUFDb0U7SUFFWixPQUFPRDtBQUNULEVBQUU7QUFFRiw0QkFBNEI7QUFDckIsTUFBTUUsd0JBQXdCLENBQUNIO0lBQ3BDLE1BQU1FLGdCQUFnQkYsSUFBSSxDQUFDQSxLQUFLdkUsTUFBTSxHQUFHLEVBQUU7SUFDM0MsT0FBT3VFLEtBQUtoRSxLQUFLLENBQUMsR0FBR2dFLEtBQUt2RSxNQUFNLEdBQUd5RTtBQUNyQyxFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTUUsYUFBYTtJQUN4QixNQUFNQyxLQUFLLEVBQUU7SUFDYixJQUFLLElBQUk5RSxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztRQUMzQjhFLEdBQUd2RSxJQUFJLENBQUNGLEtBQUtlLEtBQUssQ0FBQ2YsS0FBS2dCLE1BQU0sS0FBSztJQUNyQztJQUNBLE9BQU95RDtBQUNULEVBQUU7QUFZRiw4Q0FBOEM7QUFDdkMsTUFBTUMsc0JBQXNCLFNBQ2pDdkUsT0FDQUc7UUFDQXFFLCtFQUNBQyw4RUFBcUIsR0FDckJDLHdFQUNBSjtJQUtBLE1BQU1LLFFBQW1CLEVBQUU7SUFFM0IsbUNBQW1DO0lBQ25DLE1BQU1DLGlCQUFpQjtXQUFJNUU7S0FBTTtJQUNqQyxNQUFPNEUsZUFBZWxGLE1BQU0sR0FBRyxHQUFJO1FBQ2pDa0YsZUFBZTdFLElBQUksQ0FBQztJQUN0QjtJQUVBNEUsTUFBTTVFLElBQUksQ0FBQztRQUNUOEUsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7UUFDcENsRCxPQUFPcUQ7UUFDUEUsYUFBYSxRQUF1QixPQUFmTCxhQUFhLEdBQUU7SUFDdEM7SUFFQSxNQUFNTSxlQUFlSDtJQUNyQixNQUFNbEMsWUFBWUgsYUFBYXBDO0lBRS9CLElBQUl1RDtJQUVKLE9BQVFjO1FBQ047WUFDRSxJQUFJQyxlQUFlLEtBQUtILElBQUk7Z0JBQzFCWixlQUFlcUIsYUFBYS9ELEdBQUcsQ0FBQyxDQUFDQyxNQUFNekIsSUFBTXlCLE9BQU9xRCxFQUFFLENBQUM5RSxFQUFFO2dCQUN6RG1GLE1BQU01RSxJQUFJLENBQUM7b0JBQ1Q4RSxhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtvQkFDcENsRCxPQUFPbUM7b0JBQ1BzQixlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtvQkFDeENDLGVBQWVMO29CQUNmekMsVUFBVWdDO29CQUNWUSxhQUFjO2dCQUNoQjtZQUNGLE9BQU8sSUFBSUoseUJBQXlCO2dCQUNsQ2hCLGVBQWVxQixhQUFhL0QsR0FBRyxDQUFDLENBQUNDLE1BQU16QixJQUFNeUIsT0FBT3lELHVCQUF1QixDQUFDbEYsRUFBRTtnQkFDOUVtRixNQUFNNUUsSUFBSSxDQUFDO29CQUNUOEUsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7b0JBQ3BDbEQsT0FBT21DO29CQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7b0JBQ3hDQyxlQUFlTDtvQkFDZnpDLFVBQVVvQztvQkFDVkksYUFBYztnQkFDaEI7WUFDRixPQUFPO2dCQUNMcEIsZUFBZXFCO1lBQ2pCO1lBQ0E7UUFDRjtZQUNFLElBQUksQ0FBQ1QsSUFBSTtnQkFDUCxPQUFPO29CQUFFSyxPQUFPLEVBQUU7b0JBQUVVLFlBQVlUO2dCQUFlO1lBQ2pEO1lBQ0EsTUFBTVUsZUFBZTttQkFBSWhCO2FBQUc7WUFDNUIsSUFBSWlCLGVBQWVkO1lBQ25CLElBQUssSUFBSWpGLElBQUksSUFBSUEsS0FBSyxLQUFLK0YsZUFBZSxHQUFHL0YsSUFBSztnQkFDaEQsTUFBTWdHLE1BQU1GLFlBQVksQ0FBQzlGLEVBQUUsR0FBSStGLENBQUFBLGVBQWUsSUFBRztnQkFDakRELFlBQVksQ0FBQzlGLEVBQUUsR0FBR2dHLE1BQU07Z0JBQ3hCRCxlQUFlLENBQUNBLGdCQUFnQixLQUFNQyxDQUFBQSxPQUFPO1lBQy9DO1lBQ0FiLE1BQU01RSxJQUFJLENBQUM7Z0JBQ1Q4RSxhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtnQkFDcENsRCxPQUFPK0Q7Z0JBQ1BSLGFBQWEsYUFBNEIsT0FBZkwsYUFBYSxHQUFFO1lBQzNDO1lBQ0FmLGVBQWU0QjtZQUNmO1FBQ0Y7WUFDRTVCLGVBQWVxQjtZQUNmSixNQUFNNUUsSUFBSSxDQUFDO2dCQUNUOEUsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7Z0JBQ3BDbEQsT0FBT21DO2dCQUNQb0IsYUFBYSxhQUE0QixPQUFmTCxhQUFhLEdBQUU7WUFDM0M7WUFDQTtJQUNKO0lBRUEsTUFBTWdCLG9CQUFvQnBELFlBQVlxQixjQUFjaEIsU0FBUyxDQUFDLEVBQUU7SUFDaEVpQyxNQUFNNUUsSUFBSSxDQUFDO1FBQ1Q4RSxhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtRQUNwQ2xELE9BQU9rRTtRQUNQVCxlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtRQUN4Q0wsYUFBYTtRQUNieEMsVUFBVUksU0FBUyxDQUFDLEVBQUU7UUFDdEIwQyxlQUFlMUI7SUFDakI7SUFFQUEsZUFBZStCO0lBRWYsSUFBSyxJQUFJOUMsUUFBUSxHQUFHQSxTQUFTLElBQUlBLFFBQVM7UUFDeEMsTUFBTStDLGdCQUFnQnBFLFNBQVNvQztRQUMvQmlCLE1BQU01RSxJQUFJLENBQUM7WUFDVDhFLGFBQWEsUUFBNEJsQyxPQUFwQjhCLGFBQWEsR0FBRSxPQUFXLE9BQU45QixPQUFNO1lBQy9DcEIsT0FBT21FO1lBQ1BWLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO1lBQ3hDTCxhQUFhO1lBQ2JNLGVBQWUxQjtRQUNqQjtRQUVBLE1BQU1pQyxpQkFBaUJuRSxVQUFVa0U7UUFDakNmLE1BQU01RSxJQUFJLENBQUM7WUFDVDhFLGFBQWEsUUFBNEJsQyxPQUFwQjhCLGFBQWEsR0FBRSxPQUFXLE9BQU45QixPQUFNO1lBQy9DcEIsT0FBT29FO1lBQ1BYLGVBQWU7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUk7Z0JBQUk7Z0JBQUk7Z0JBQUk7YUFBRztZQUN4REYsYUFBYTtZQUNiTSxlQUFlTTtRQUNqQjtRQUVBLElBQUlFO1FBRUosSUFBSWpELFFBQVEsSUFBSTtZQUNkLE1BQU1rRCxrQkFBa0I3RCxXQUFXMkQ7WUFDbkNoQixNQUFNNUUsSUFBSSxDQUFDO2dCQUNUOEUsYUFBYSxRQUE0QmxDLE9BQXBCOEIsYUFBYSxHQUFFLE9BQVcsT0FBTjlCLE9BQU07Z0JBQy9DcEIsT0FBT3NFO2dCQUNQYixlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtnQkFDeENMLGFBQWE7Z0JBQ2JNLGVBQWVPO1lBQ2pCO1lBRUFqQyxlQUFlckIsWUFBWXdELGlCQUFpQm5ELFNBQVMsQ0FBQ0MsTUFBTTtZQUM1RGlELDhCQUE4QkM7UUFDaEMsT0FBTztZQUNMbkMsZUFBZXJCLFlBQVlzRCxnQkFBZ0JqRCxTQUFTLENBQUNDLE1BQU07WUFDM0RpRCw4QkFBOEJEO1FBQ2hDO1FBRUFoQixNQUFNNUUsSUFBSSxDQUFDO1lBQ1Q4RSxhQUFhLFFBQTRCbEMsT0FBcEI4QixhQUFhLEdBQUUsT0FBVyxPQUFOOUIsT0FBTTtZQUMvQ3BCLE9BQU9tQztZQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7WUFDeENMLGFBQWE7WUFDYnhDLFVBQVVJLFNBQVMsQ0FBQ0MsTUFBTTtZQUMxQnlDLGVBQWVRO1FBQ2pCO0lBQ0Y7SUFFQSxJQUFJUDtJQUVKLE9BQVFiO1FBQ047WUFDRWEsYUFBYTNCO1lBQ2I7UUFDRjtZQUNFMkIsYUFBYTNCLGFBQWExQyxHQUFHLENBQUMsQ0FBQ0MsTUFBTXpCLElBQU15QixPQUFPOEQsWUFBWSxDQUFDdkYsRUFBRTtZQUNqRW1GLE1BQU01RSxJQUFJLENBQUM7Z0JBQ1Q4RSxhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtnQkFDcENsRCxPQUFPOEQ7Z0JBQ1BMLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO2dCQUN4Q0wsYUFBYSxhQUE0QixPQUFmTCxhQUFhLEdBQUU7Z0JBQ3pDVyxlQUFlTDtnQkFDZnpDLFVBQVVvQjtZQUNaO1lBQ0E7UUFDRjtZQUNFMkIsYUFBYTNCO1lBQ2I7SUFDSjtJQUVBaUIsTUFBTTVFLElBQUksQ0FBQztRQUNUOEUsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7UUFDcENsRCxPQUFPOEQ7UUFDUFAsYUFBYSxRQUF1QixPQUFmTCxhQUFhLEdBQUU7SUFDdEM7SUFFQSxPQUFPO1FBQUVFO1FBQU9VO0lBQVc7QUFDN0IsRUFBRTtBQUVLLE1BQU1TLGNBQWMsU0FDekJyQyxXQUNBdEQ7UUFDQXFFLCtFQUNBWixvRkFDQW1DO0lBV0EsTUFBTXBCLFFBQW1CLEVBQUU7SUFDM0IsSUFBSUwsS0FBMkJ5QixhQUFhO1dBQUlBO0tBQVcsR0FBR0M7SUFFOUQsOEJBQThCO0lBQzlCLE1BQU1oQyxTQUFTTCxhQUFhRixXQUFXRztJQUN2QyxNQUFNcUMsWUFBOEUsRUFBRTtJQUV0Riw2REFBNkQ7SUFDN0QsSUFBSXJCLGlCQUFpQlosTUFBTSxDQUFDLEVBQUUsSUFBSWhGLFlBQVl5RTtJQUM5Q2tCLE1BQU01RSxJQUFJLENBQUM7UUFDVDhFLGFBQWE7UUFDYnRELE9BQU9xRDtRQUNQRSxhQUFhLGVBQXlCLE9BQVZyQixXQUFVO0lBQ3hDO0lBRUEsMEJBQTBCO0lBQzFCLElBQUlHLDBCQUFtQztRQUNyQ2dCLGlCQUFpQmIscUJBQXFCYTtRQUN0Q0QsTUFBTTVFLElBQUksQ0FBQztZQUNUOEUsYUFBYTtZQUNidEQsT0FBT3FEO1lBQ1BFLGFBQWE7UUFDZjtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ04sa0JBQXdCQSxjQUFtQixLQUFNLENBQUNGLElBQUk7UUFDekRBLEtBQUtEO1FBQ0wsSUFBSUwsT0FBT3RFLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCLGlFQUFpRTtZQUNqRSxNQUFNd0csZ0JBQWdCMUIsaUJBQ2xCLHFEQUNBO1lBQ0osTUFBTTJCLGdCQUFnQixHQUEwRTNCLE9BQXZFQSxpQkFBdUIsUUFBUSxPQUFNLG9DQUF3RSxPQUF0Q0EsaUJBQXVCLE9BQU8sU0FBUTtZQUN0SUcsTUFBTTVFLElBQUksQ0FBQztnQkFDVDhFLGFBQWFxQjtnQkFDYjNFLE9BQU8rQztnQkFDUFEsYUFBYXFCO1lBQ2Y7UUFDRjtJQUNGO0lBRUEsMkRBQTJEO0lBQzNELE1BQU1wQixlQUFlSDtJQUVyQixnQkFBZ0I7SUFDaEIsTUFBTWxDLFlBQVlILGFBQWFwQztJQUUvQiw4QkFBOEI7SUFDOUIsSUFBSXVEO0lBRUosT0FBUWM7UUFDTjtZQUNFLElBQUksQ0FBQ0YsSUFBSUEsS0FBS0QsY0FBYyxXQUFXO1lBQ3ZDLHdCQUF3QjtZQUN4QlgsZUFBZXFCLGFBQWEvRCxHQUFHLENBQUMsQ0FBQ0MsTUFBTXpCLElBQU15QixPQUFPcUQsRUFBRyxDQUFDOUUsRUFBRTtZQUUxRG1GLE1BQU01RSxJQUFJLENBQUM7Z0JBQ1Q4RSxhQUFhO2dCQUNidEQsT0FBT21DO2dCQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDQyxlQUFlTDtnQkFDZnpDLFVBQVVnQztnQkFDVlEsYUFBYztZQUNoQjtZQUNBO1FBQ0Y7WUFDRSxtRUFBbUU7WUFDbkUsTUFBTXNCLFVBQVU5QixNQUFNRDtZQUN0QixJQUFJLENBQUNDLElBQUlBLEtBQUs4QjtZQUVkekIsTUFBTTVFLElBQUksQ0FBQztnQkFDVDhFLGFBQWE7Z0JBQ2J0RCxPQUFPNkU7Z0JBQ1B0QixhQUFhO1lBQ2Y7WUFFQXBCLGVBQWUwQztZQUNmO1FBQ0Y7WUFDRTFDLGVBQWVxQjtZQUNmSixNQUFNNUUsSUFBSSxDQUFDO2dCQUNUOEUsYUFBYTtnQkFDYnRELE9BQU9tQztnQkFDUG9CLGFBQWE7WUFDZjtZQUNBO0lBQ0o7SUFFQSw2Q0FBNkM7SUFDN0MsTUFBTVcsb0JBQW9CcEQsWUFBWXFCLGNBQWNoQixTQUFTLENBQUMsRUFBRTtJQUNoRWlDLE1BQU01RSxJQUFJLENBQUM7UUFDVDhFLGFBQWE7UUFDYnRELE9BQU9rRTtRQUNQVCxlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtRQUN4Q0wsYUFBYTtRQUNieEMsVUFBVUksU0FBUyxDQUFDLEVBQUU7UUFDdEIwQyxlQUFlMUI7SUFDakI7SUFFQUEsZUFBZStCO0lBRWYsY0FBYztJQUNkLElBQUssSUFBSTlDLFFBQVEsR0FBR0EsU0FBUyxJQUFJQSxRQUFTO1FBQ3hDLFdBQVc7UUFDWCxNQUFNK0MsZ0JBQWdCcEUsU0FBU29DO1FBQy9CaUIsTUFBTTVFLElBQUksQ0FBQztZQUNUOEUsYUFBYSxHQUFTLE9BQU5sQyxPQUFNO1lBQ3RCcEIsT0FBT21FO1lBQ1BWLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO1lBQ3hDTCxhQUFhO1lBQ2JNLGVBQWUxQixhQUFhLHNDQUFzQztRQUNwRTtRQUVBLFlBQVk7UUFDWixNQUFNaUMsaUJBQWlCbkUsVUFBVWtFO1FBQ2pDZixNQUFNNUUsSUFBSSxDQUFDO1lBQ1Q4RSxhQUFhLEdBQVMsT0FBTmxDLE9BQU07WUFDdEJwQixPQUFPb0U7WUFDUFgsZUFBZTtnQkFBQztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBSTtnQkFBSTtnQkFBSTtnQkFBSTthQUFHO1lBQ3hERixhQUFhO1lBQ2JNLGVBQWVNLGNBQWMsb0NBQW9DO1FBQ25FO1FBRUEsSUFBSUU7UUFFSixJQUFJakQsUUFBUSxJQUFJO1lBQ2Qsa0NBQWtDO1lBQ2xDLE1BQU1rRCxrQkFBa0I3RCxXQUFXMkQ7WUFDbkNoQixNQUFNNUUsSUFBSSxDQUFDO2dCQUNUOEUsYUFBYSxHQUFTLE9BQU5sQyxPQUFNO2dCQUN0QnBCLE9BQU9zRTtnQkFDUGIsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDTCxhQUFhO2dCQUNiTSxlQUFlTyxlQUFlLCtDQUErQztZQUMvRTtZQUVBLGNBQWM7WUFDZGpDLGVBQWVyQixZQUFZd0QsaUJBQWlCbkQsU0FBUyxDQUFDQyxNQUFNO1lBQzVEaUQsOEJBQThCQztRQUNoQyxPQUFPO1lBQ0wsZ0NBQWdDO1lBQ2hDbkMsZUFBZXJCLFlBQVlzRCxnQkFBZ0JqRCxTQUFTLENBQUNDLE1BQU07WUFDM0RpRCw4QkFBOEJEO1FBQ2hDO1FBRUFoQixNQUFNNUUsSUFBSSxDQUFDO1lBQ1Q4RSxhQUFhLEdBQVMsT0FBTmxDLE9BQU07WUFDdEJwQixPQUFPbUM7WUFDUHNCLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO1lBQ3hDTCxhQUFhO1lBQ2J4QyxVQUFVSSxTQUFTLENBQUNDLE1BQU07WUFDMUJ5QyxlQUFlUTtRQUNqQjtJQUNGO0lBRUEsNkJBQTZCO0lBQzdCLElBQUlQO0lBRUosT0FBUWI7UUFDTjtZQUNFLDZEQUE2RDtZQUM3RGEsYUFBYTNCO1lBQ2I7UUFDRjtZQUNFLDJDQUEyQztZQUMzQzJCLGFBQWEzQixhQUFhMUMsR0FBRyxDQUFDLENBQUNDLE1BQU16QixJQUFNeUIsT0FBTzhELFlBQVksQ0FBQ3ZGLEVBQUU7WUFDakVtRixNQUFNNUUsSUFBSSxDQUFDO2dCQUNUOEUsYUFBYTtnQkFDYnRELE9BQU84RDtnQkFDUEwsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDTCxhQUFhO2dCQUNiTSxlQUFlTDtnQkFDZnpDLFVBQVVvQjtZQUNaO1lBQ0E7UUFDRjtZQUNFMkIsYUFBYTNCO1lBQ2I7SUFDSjtJQUVBaUIsTUFBTTVFLElBQUksQ0FBQztRQUNUOEUsYUFBYTtRQUNidEQsT0FBTzhEO1FBQ1BQLGFBQWEsR0FBUSxPQUFMTixNQUFLO0lBQ3ZCO0lBRUEsNkNBQTZDO0lBQzdDLElBQUlFO0lBQ0osTUFBTTJCLHNCQUFnQyxFQUFFO0lBRXhDLHdCQUF3QjtJQUN4QixJQUFJLENBQUM3QixrQkFBd0JBLGNBQW1CLEtBQU0sQ0FBQ0YsSUFBSTtRQUN6REEsS0FBS0Q7SUFDUDtJQUVBLElBQUssSUFBSUksYUFBYSxHQUFHQSxhQUFhVCxPQUFPdEUsTUFBTSxFQUFFK0UsYUFBYztRQUNqRSxNQUFNNkIsY0FBYy9CLG9CQUNsQlAsTUFBTSxDQUFDUyxXQUFXLEVBQ2xCdEUsS0FDQXFFLE1BQ0FDLFlBQ0FDLHlCQUNBSjtRQUdGMkIsVUFBVWxHLElBQUksQ0FBQztZQUNiMEU7WUFDQUUsT0FBTzJCLFlBQVkzQixLQUFLO1lBQ3hCVSxZQUFZaUIsWUFBWWpCLFVBQVU7UUFDcEM7UUFFQWdCLG9CQUFvQnRHLElBQUksSUFBSXVHLFlBQVlqQixVQUFVO1FBRWxELGtFQUFrRTtRQUNsRSxJQUFJYixnQkFBc0I7WUFDeEJFLDBCQUEwQjRCLFlBQVlqQixVQUFVO1FBQ2xEO0lBQ0Y7SUFFQSwwRkFBMEY7SUFDMUYsTUFBTWtCLGtCQUFrQnZDLE9BQU90RSxNQUFNLEdBQUcsSUFBSTJHLHNCQUFzQmhCO0lBRWxFLHlEQUF5RDtJQUN6RCxNQUFNbUIsaUJBQWlCcEksb0RBQVksQ0FBQ3NJLFNBQVMsQ0FBQ0MsTUFBTSxDQUNsRCxJQUFJQyxXQUFXTDtJQUdqQixNQUFNTSx3QkFBd0J6SSxvREFBWSxDQUFDMEksTUFBTSxDQUFDQyxTQUFTLENBQUNQO0lBQzVELE1BQU1RLHFCQUFxQjVJLG9EQUFZLENBQUM2SSxHQUFHLENBQUNGLFNBQVMsQ0FBQ1A7SUFDdEQsTUFBTVUsd0JBQXdCN0YsY0FBY2tGLGlCQUFpQjtJQUU3RCxPQUFPO1FBQ0w1QjtRQUNBd0MsaUJBQWlCO1lBQ2ZDLFFBQVFQO1lBQ1JRLEtBQUtMO1lBQ0xNLFFBQVFKO1FBQ1Y7UUFDQTVDO1FBQ0EyQixXQUFXQSxVQUFVdkcsTUFBTSxHQUFHLElBQUl1RyxZQUFZRDtJQUNoRDtBQUNGLEVBQUU7QUFFRixxREFBcUQ7QUFDOUMsTUFBTXVCLHVCQUF1QixDQUFDcEg7SUFNbkMsTUFBTXVDLFlBQVlILGFBQWFwQztJQUMvQixNQUFNd0UsUUFBUSxFQUFFO0lBRWhCQSxNQUFNNUUsSUFBSSxDQUFDO1FBQ1Q4RSxhQUFhO1FBQ2IxRSxLQUFLdUMsU0FBUyxDQUFDLEVBQUU7UUFDakJvQyxhQUFhO0lBQ2Y7SUFFQSxJQUFLLElBQUluQyxRQUFRLEdBQUdBLFNBQVMsSUFBSUEsUUFBUztRQUN4QyxNQUFNQyxVQUFVRixTQUFTLENBQUNDLFFBQVEsRUFBRTtRQUNwQyxNQUFNNkUsYUFBYTlFLFNBQVMsQ0FBQ0MsTUFBTTtRQUVuQyxnRUFBZ0U7UUFDaEUsTUFBTUksV0FBVztZQUFDSCxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztTQUFDO1FBQ3JFLE1BQU1JLFVBQVU7WUFBQ0QsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7U0FBQztRQUNwRSxNQUFNMEUsV0FBV3pFLFFBQVFoQyxHQUFHLENBQUNDLENBQUFBLE9BQVFyQyxJQUFJLENBQUNxQyxLQUFLO1FBQy9DLE1BQU15RyxZQUFZN0ksSUFBSSxDQUFDOEQsTUFBTTtRQUM3QixNQUFNZ0Ysa0JBQWtCO2VBQUlGO1NBQVM7UUFDckNFLGVBQWUsQ0FBQyxFQUFFLElBQUlEO1FBQ3RCLHFGQUFxRjtRQUNyRixNQUFNRSxnQkFBZ0I7WUFBQ2hGLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1NBQUM7UUFDdEUsTUFBTWlGLFlBQVlELGNBQWM1RyxHQUFHLENBQUMsQ0FBQ0MsTUFBTTZHLFFBQVU3RyxPQUFPMEcsZUFBZSxDQUFDRyxNQUFNO1FBR2xGLHVEQUF1RDtRQUN2RG5ELE1BQU01RSxJQUFJLENBQUM7WUFDVDhFLGFBQWEsZ0JBQXNCLE9BQU5sQztZQUM3QnhDLEtBQUtxSDtZQUNMMUMsYUFBYSxhQUV3Qy9CLE9BRGpESixPQUFNLDBHQUVrQkssT0FEeUJELFNBQVMvQixHQUFHLENBQUMrRyxDQUFBQSxJQUFLQSxFQUFFN0csUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQyxPQUFNLHVDQUVsRXFHLE9BRHJCekUsUUFBUWhDLEdBQUcsQ0FBQytHLENBQUFBLElBQUtBLEVBQUU3RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sNERBRTdDc0csT0FES0QsU0FBU3pHLEdBQUcsQ0FBQytHLENBQUFBLElBQUtBLEVBQUU3RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sdURBRWhHdUcsT0FENkJELFVBQVV4RyxRQUFRLENBQUMsS0FBSSx1Q0FFeEIwRyxPQUQ1QkQsZ0JBQWdCM0csR0FBRyxDQUFDK0csQ0FBQUEsSUFBS0EsRUFBRTdHLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUMsT0FBTSxzREFDd0V1RyxPQUFqSEMsY0FBYzVHLEdBQUcsQ0FBQytHLENBQUFBLElBQUtBLEVBQUU3RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sZ0RBQW1JeUcsT0FBckZGLGdCQUFnQjNHLEdBQUcsQ0FBQytHLENBQUFBLElBQUtBLEVBQUU3RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sa0JBQStFLE9BQS9EeUcsVUFBVTdHLEdBQUcsQ0FBQytHLENBQUFBLElBQUtBLEVBQUU3RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU07WUFFaFQ0RyxrQkFBa0I7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRSxDQUFDLHVEQUF1RDtRQUN4RjtJQUNGO0lBRUEsT0FBT3JEO0FBQ1QsRUFBRTtBQUVGLHNFQUFzRTtBQUMvRCxTQUFTc0QsNEJBQTRCOUgsR0FBYTtRQUFFekIsWUFBQUE7SUFDekQsTUFBTThELFdBQVdyQyxJQUFJVCxNQUFNLEdBQUc7SUFDOUIsTUFBTStDLFlBQVkvRCxvQkFBa0MsS0FBS0Esb0JBQWtDLEtBQUs7SUFFaEcsOEJBQThCO0lBQzlCLElBQUlrRSxVQUFVekMsSUFBSUYsS0FBSztJQUN2QixJQUFJeUMsWUFBWTtRQUFDRSxRQUFRM0MsS0FBSztLQUFHO0lBRWpDLHFEQUFxRDtJQUNyRCxJQUFJaUksZ0JBQWdCLEVBQUU7SUFFdEIsSUFBSyxJQUFJdkYsUUFBUSxHQUFHQSxTQUFTRixXQUFXRSxRQUFTO1FBQy9DLElBQUl3RixjQUFjLEVBQUU7UUFDcEIsSUFBSXRGLFNBQVNELFFBQVEzQyxLQUFLO1FBQzFCLE1BQU02QyxZQUFZRixRQUFRbEQsTUFBTSxHQUFHO1FBQ25DLE1BQU1xRCxXQUFXO1lBQUNILE9BQU8sQ0FBQ0UsVUFBVTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtTQUFDO1FBRTdHLGtCQUFrQjtRQUNsQixNQUFNRSxVQUFVO1lBQUNELFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1NBQUM7UUFDcEVvRixZQUFZcEksSUFBSSxDQUFDO1lBQ2ZxSSxNQUFNO1lBQVdDLE9BQU90RixTQUFTOUMsS0FBSztZQUFJcUksUUFBUXRGLFFBQVEvQyxLQUFLO1FBQ2pFO1FBQ0EsMkJBQTJCO1FBQzNCLE1BQU13SCxXQUFXekUsUUFBUWhDLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUXJDLElBQUksQ0FBQ3FDLEtBQUs7UUFDL0NrSCxZQUFZcEksSUFBSSxDQUFDO1lBQ2ZxSSxNQUFNO1lBQVlDLE9BQU9yRixRQUFRL0MsS0FBSztZQUFJcUksUUFBUWIsU0FBU3hILEtBQUs7UUFDbEU7UUFDQSw2QkFBNkI7UUFDN0IsTUFBTXlILFlBQVk3SSxJQUFJLENBQUM4RCxNQUFNO1FBQzdCLE1BQU00RixXQUFXZCxTQUFTeEgsS0FBSztRQUMvQnNJLFFBQVEsQ0FBQyxFQUFFLElBQUliO1FBQ2ZTLFlBQVlwSSxJQUFJLENBQUM7WUFDZnFJLE1BQU07WUFBY0MsT0FBT1osU0FBU3hILEtBQUs7WUFBSXVJLE1BQU1kO1lBQVdZLFFBQVFDLFNBQVN0SSxLQUFLO1FBQ3RGO1FBQ0EseUNBQXlDO1FBQ3pDLE1BQU00SCxZQUFZO1lBQ2hCakYsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1NBQ3pCO1FBQ0RKLFlBQVlwSSxJQUFJLENBQUM7WUFDZnFJLE1BQU07WUFBcUJLLFFBQVE7Z0JBQUM3RixRQUFRM0MsS0FBSyxDQUFDLEdBQUU7Z0JBQUlzSSxTQUFTdEksS0FBSzthQUFHO1lBQUVxSSxRQUFRVCxVQUFVNUgsS0FBSztRQUNwRztRQUNBLHlCQUF5QjtRQUN6QjRDLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QixnQ0FBZ0M7UUFDaEMsSUFBSyxJQUFJckksSUFBSSxHQUFHQSxJQUFJZ0QsVUFBVWhELElBQUs7WUFDakMsTUFBTTBELFNBQVMxRCxJQUFJO1lBQ25CcUQsTUFBTSxDQUFDSyxPQUFPLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sT0FBTztZQUNyREwsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR0wsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUU7WUFDN0RMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFO1lBQzdETCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRTtZQUM3RGlGLFlBQVlwSSxJQUFJLENBQUM7Z0JBQ2ZxSSxNQUFNO2dCQUFhSyxRQUFRO29CQUN6QjVGLE9BQU81QyxLQUFLLENBQUNpRCxTQUFTLEdBQUdBO29CQUN6Qk4sUUFBUTNDLEtBQUssQ0FBQ2lELFFBQVFBLFNBQVM7aUJBQ2hDO2dCQUFFb0YsUUFBUXpGLE9BQU81QyxLQUFLLENBQUNpRCxRQUFRQSxTQUFTO2dCQUFJd0YsV0FBV2xKO1lBQzFEO1FBQ0Y7UUFDQTBJLGNBQWNuSSxJQUFJLENBQUM7WUFBRTRDO1lBQU93RjtZQUFhN0YsVUFBVU8sT0FBTzVDLEtBQUs7UUFBRztRQUNsRTJDLFVBQVVDLE9BQU81QyxLQUFLO1FBQ3RCeUMsVUFBVTNDLElBQUksQ0FBQzZDO0lBQ2pCO0lBQ0EsT0FBT3NGO0FBQ1Q7QUFFQSxzREFBc0Q7QUFDL0MsTUFBTVMsaUJBQWlCLFNBQzVCbEYsV0FDQXREO1FBQ0FxRSwrRUFDQVosb0ZBQ0FnRiwwRkFDQWxLLGtGQUNBbUs7SUFFQSw4REFBOEQ7SUFDOUQsTUFBTXpJLFdBQVdELElBQUlFLE9BQU8sQ0FBQyxPQUFPO0lBQ3BDLElBQUl5SSxTQUFTMUksU0FBU1YsTUFBTSxHQUFHLE1BQU0sSUFBSVUsV0FBVyxNQUFNQTtJQUUxRCw4REFBOEQ7SUFDOUQsTUFBTTJJLG1CQUFtQnJLLFlBQVksR0FBRywwQkFBMEI7SUFDbEUsSUFBSW9LLE9BQU9wSixNQUFNLEdBQUdxSixrQkFBa0I7UUFDcEMsdUJBQXVCO1FBQ3ZCRCxTQUFTQSxPQUFPRSxNQUFNLENBQUNELGtCQUFrQjtJQUMzQyxPQUFPLElBQUlELE9BQU9wSixNQUFNLEdBQUdxSixrQkFBa0I7UUFDM0MsMkJBQTJCO1FBQzNCRCxTQUFTQSxPQUFPRyxTQUFTLENBQUMsR0FBR0Y7SUFDL0I7SUFFQSxNQUFNRyxlQUFlOUssb0RBQVksQ0FBQzZJLEdBQUcsQ0FBQzVILEtBQUssQ0FBQ3lKO0lBRTVDLElBQUlLO0lBQ0osT0FBUXZGO1FBQ047WUFDRXVGLGdCQUFnQjtnQkFBRXZGLFNBQVN4RixzREFBWSxDQUFDaUwsUUFBUTtZQUFDO1lBQ2pEO1FBQ0Y7WUFDRUYsZ0JBQWdCO2dCQUFFdkYsU0FBU3hGLHNEQUFZLENBQUNrTCxTQUFTO1lBQUM7WUFDbEQ7UUFDRjtZQUNFSCxnQkFBZ0IsQ0FBQyxHQUFHLG1CQUFtQjtJQUMzQztJQUVBLElBQUlJO0lBQ0osSUFBSWpGO0lBRUosT0FBUUU7UUFDTjtZQUNFLElBQUlxRSxVQUFVO2dCQUNadkUsS0FBS2xHLG9EQUFZLENBQUM2SSxHQUFHLENBQUM1SCxLQUFLLENBQUN3SixTQUFTeEksT0FBTyxDQUFDLE9BQU87WUFDdEQsT0FBTztnQkFDTGlFLEtBQUtsRyxvREFBWSxDQUFDc0ksU0FBUyxDQUFDN0YsTUFBTSxDQUFDO1lBQ3JDO1lBQ0EwSSxhQUFhO2dCQUNYL0UsTUFBTXBHLHVEQUFhLENBQUNvTCxHQUFHO2dCQUN2QmxGLElBQUlBO2dCQUNKLEdBQUc2RSxhQUFhO1lBQ2xCO1lBQ0E7UUFDRjtZQUNFLElBQUlOLFVBQVU7Z0JBQ1p2RSxLQUFLbEcsb0RBQVksQ0FBQzZJLEdBQUcsQ0FBQzVILEtBQUssQ0FBQ3dKLFNBQVN4SSxPQUFPLENBQUMsT0FBTztZQUN0RCxPQUFPO2dCQUNMaUUsS0FBS2xHLG9EQUFZLENBQUNzSSxTQUFTLENBQUM3RixNQUFNLENBQUM7WUFDckM7WUFDQTBJLGFBQWE7Z0JBQ1gvRSxNQUFNcEcsdURBQWEsQ0FBQ3FMLEdBQUc7Z0JBQ3ZCbkYsSUFBSUE7Z0JBQ0o4QixTQUFTaEksb0RBQVksQ0FBQ3NJLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDO29CQUFDO29CQUFHO29CQUFHO29CQUFHO2lCQUFFLEVBQUU7Z0JBQ3JELEdBQUd3QyxhQUFhO1lBQ2xCO1lBQ0E7UUFDRjtZQUNFSSxhQUFhO2dCQUNYL0UsTUFBTXBHLHVEQUFhLENBQUNzTCxHQUFHO2dCQUN2QixHQUFHUCxhQUFhO1lBQ2xCO1lBQ0E7SUFDSjtJQUVBLE1BQU1RLFlBQVl2TCxvREFBWSxDQUFDeUwsT0FBTyxDQUFDcEcsV0FBV3lGLGNBQWNLO0lBRWhFLHlCQUF5QjtJQUN6QixNQUFNTyxlQUFlSCxVQUFVekksUUFBUTtJQUN2QyxNQUFNNkksZUFBZTNMLG9EQUFZLENBQUM0TCxZQUFZLENBQUNyRCxNQUFNLENBQUM7UUFDcERzRCxZQUFZN0wsb0RBQVksQ0FBQzBJLE1BQU0sQ0FBQ3pILEtBQUssQ0FBQ3lLO0lBQ3hDO0lBQ0EsTUFBTUksWUFBWTlMLHVEQUFlLENBQUM2SSxHQUFHLENBQUNGLFNBQVMsQ0FBQ2dEO0lBRWhELG1EQUFtRDtJQUNuRCxNQUFNSyxXQUFXRixVQUFVRyxLQUFLLENBQUMsU0FBVXJKLEdBQUcsQ0FBQ3FHLENBQUFBLE1BQU83RyxTQUFTNkcsS0FBSztJQUNwRSxNQUFNaUQsZUFBZWpKLGNBQWMrSSxVQUFVO0lBRTdDLGlEQUFpRDtJQUNqRCxJQUFJRztJQUNKLE9BQVEzQjtRQUNOO1lBQ0UyQixnQkFBZ0JMO1lBQ2hCO1FBQ0Y7WUFDRUssZ0JBQWdCRDtZQUNoQjtRQUNGO1lBQ0VDLGdCQUFnQlQ7WUFDaEI7SUFDSjtJQUVBLE9BQU87UUFDTEcsWUFBWU07UUFDWmpHLElBQUlBLEtBQUtsRyxvREFBWSxDQUFDNkksR0FBRyxDQUFDRixTQUFTLENBQUN6QyxNQUFNMEI7UUFDMUN3RSxTQUFTO1lBQ1BwRCxRQUFRMEM7WUFDUnpDLEtBQUs2QztZQUNMNUMsUUFBUWdEO1FBQ1Y7SUFDRjtBQUNGLEVBQUU7QUFFRixxQ0FBcUM7QUFDOUIsTUFBTUcsaUJBQWlCLFNBQzVCUixZQUNBOUo7UUFDQXFFLCtFQUNBWixvRkFDQThHLHlGQUNBaE0sa0ZBQ0FtSztJQUVBLElBQUk7UUFDRiw4REFBOEQ7UUFDOUQsTUFBTXpJLFdBQVdELElBQUlFLE9BQU8sQ0FBQyxPQUFPO1FBQ3BDLElBQUl5SSxTQUFTMUksU0FBU1YsTUFBTSxHQUFHLE1BQU0sSUFBSVUsV0FBVyxNQUFNQTtRQUUxRCw4REFBOEQ7UUFDOUQsTUFBTTJJLG1CQUFtQnJLLFlBQVksR0FBRywwQkFBMEI7UUFDbEUsSUFBSW9LLE9BQU9wSixNQUFNLEdBQUdxSixrQkFBa0I7WUFDcEMsdUJBQXVCO1lBQ3ZCRCxTQUFTQSxPQUFPRSxNQUFNLENBQUNELGtCQUFrQjtRQUMzQyxPQUFPLElBQUlELE9BQU9wSixNQUFNLEdBQUdxSixrQkFBa0I7WUFDM0MsMkJBQTJCO1lBQzNCRCxTQUFTQSxPQUFPRyxTQUFTLENBQUMsR0FBR0Y7UUFDL0I7UUFFQSxNQUFNRyxlQUFlOUssb0RBQVksQ0FBQzZJLEdBQUcsQ0FBQzVILEtBQUssQ0FBQ3lKO1FBRTVDLHlDQUF5QztRQUN6QyxJQUFJNkI7UUFDSixPQUFRRDtZQUNOO2dCQUNFQyxzQkFBc0J2TSxvREFBWSxDQUFDNkksR0FBRyxDQUFDNUgsS0FBSyxDQUFDNEssV0FBVzVKLE9BQU8sQ0FBQyxPQUFPO2dCQUN2RTtZQUNGO29CQUV3QjRKO2dCQUR0QixxQ0FBcUM7Z0JBQ3JDLE1BQU1XLGdCQUFnQlgsRUFBQUEsNEJBQUFBLFdBQVc1SixPQUFPLENBQUMsT0FBTyxJQUFJZ0ssS0FBSyxDQUFDLHNCQUFwQ0osZ0RBQUFBLDBCQUE4Q2pKLEdBQUcsQ0FBQzZKLENBQUFBLE1BQU9ySyxTQUFTcUssS0FBSyxHQUFHM0osUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQyxRQUFPO2dCQUMzSXVKLHNCQUFzQnZNLG9EQUFZLENBQUM2SSxHQUFHLENBQUM1SCxLQUFLLENBQUN1TDtnQkFDN0M7WUFDRjtnQkFDRUQsc0JBQXNCdk0sb0RBQVksQ0FBQzBJLE1BQU0sQ0FBQ3pILEtBQUssQ0FBQzRLO2dCQUNoRDtRQUNKO1FBRUEsSUFBSWQ7UUFDSixPQUFRdkY7WUFDTjtnQkFDRXVGLGdCQUFnQjtvQkFBRXZGLFNBQVN4RixzREFBWSxDQUFDaUwsUUFBUTtnQkFBQztnQkFDakQ7WUFDRjtnQkFDRUYsZ0JBQWdCO29CQUFFdkYsU0FBU3hGLHNEQUFZLENBQUNrTCxTQUFTO2dCQUFDO2dCQUNsRDtZQUNGO2dCQUNFSCxnQkFBZ0IsQ0FBQyxHQUFHLG1CQUFtQjtRQUMzQztRQUVBLElBQUlJO1FBQ0osSUFBSWpGO1FBRUosT0FBUUU7WUFDTjtnQkFDRSxJQUFJLENBQUNxRSxVQUFVO29CQUNiLE9BQU87d0JBQUVwRixXQUFXO3dCQUFJcUgsT0FBTztvQkFBNEI7Z0JBQzdEO2dCQUNBeEcsS0FBS2xHLG9EQUFZLENBQUM2SSxHQUFHLENBQUM1SCxLQUFLLENBQUN3SixTQUFTeEksT0FBTyxDQUFDLE9BQU87Z0JBQ3BEa0osYUFBYTtvQkFDWC9FLE1BQU1wRyx1REFBYSxDQUFDb0wsR0FBRztvQkFDdkJsRixJQUFJQTtvQkFDSixHQUFHNkUsYUFBYTtnQkFDbEI7Z0JBQ0E7WUFDRjtnQkFDRSxJQUFJLENBQUNOLFVBQVU7b0JBQ2IsT0FBTzt3QkFBRXBGLFdBQVc7d0JBQUlxSCxPQUFPO29CQUFvQztnQkFDckU7Z0JBQ0F4RyxLQUFLbEcsb0RBQVksQ0FBQzZJLEdBQUcsQ0FBQzVILEtBQUssQ0FBQ3dKLFNBQVN4SSxPQUFPLENBQUMsT0FBTztnQkFDcERrSixhQUFhO29CQUNYL0UsTUFBTXBHLHVEQUFhLENBQUNxTCxHQUFHO29CQUN2Qm5GLElBQUlBO29CQUNKOEIsU0FBU2hJLG9EQUFZLENBQUNzSSxTQUFTLENBQUNDLE1BQU0sQ0FBQzt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRSxFQUFFO29CQUNyRCxHQUFHd0MsYUFBYTtnQkFDbEI7Z0JBQ0E7WUFDRjtnQkFDRUksYUFBYTtvQkFDWC9FLE1BQU1wRyx1REFBYSxDQUFDc0wsR0FBRztvQkFDdkIsR0FBR1AsYUFBYTtnQkFDbEI7Z0JBQ0E7UUFDSjtRQUVBLE1BQU00QixZQUFZM00sb0RBQVksQ0FBQzRNLE9BQU8sQ0FDcEM7WUFBRWYsWUFBWVU7UUFBb0IsR0FDbEN6QixjQUNBSztRQUdGLE1BQU05RixZQUFZc0gsVUFBVTdKLFFBQVEsQ0FBQzlDLHNEQUFZLENBQUNnQixJQUFJO1FBRXRELElBQUksQ0FBQ3FFLFdBQVc7WUFDZCxPQUFPO2dCQUFFQSxXQUFXO2dCQUFJcUgsT0FBTztZQUF3RTtRQUN6RztRQUVBLE9BQU87WUFBRXJIO1FBQVU7SUFDckIsRUFBRSxPQUFPcUgsT0FBWTtRQUNuQixPQUFPO1lBQUVySCxXQUFXO1lBQUlxSCxPQUFPQSxNQUFNRyxPQUFPLElBQUk7UUFBa0M7SUFDcEY7QUFDRixFQUFFO0FBRUYsa0dBQWtHO0FBQzNGLE1BQU1DLG1CQUFtQjtJQUM5QixNQUFNekgsWUFBWTtJQUNsQixNQUFNdEQsTUFBTTtJQUVaLHNDQUFzQztJQUN0QyxNQUFNUSxXQUFXLEVBQUU7SUFDbkIsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJVyxJQUFJVCxNQUFNLEVBQUVGLEtBQUssRUFBRztRQUN0Q21CLFNBQVNaLElBQUksQ0FBQ1MsU0FBU0wsSUFBSU0sTUFBTSxDQUFDakIsR0FBRyxJQUFJO0lBQzNDO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU0sRUFBRTJILGVBQWUsRUFBRSxHQUFHckIsWUFBWXJDLFdBQVc5QztJQUVuRCw4QkFBOEI7SUFDOUIsTUFBTXdLLGVBQWV4QyxlQUFlbEYsV0FBV3REO0lBRS9DLE9BQU8sMkNBRStCZ0wsT0FEQWhFLGdCQUFnQkUsR0FBRyxFQUFDLDRDQUNLLE9BQXpCOEQsYUFBYVgsT0FBTyxDQUFDbkQsR0FBRyxFQUFDO0FBR2pFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdmljdHVzXFxEZXNrdG9wXFxhZXNcXEZpbmFsIEFFU1xcYWVzXFxzcmNcXHV0aWxzXFxhZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5cbi8vIEFFUyBtb2RlIGVudW1cbmV4cG9ydCBlbnVtIEFlc01vZGUge1xuICBFQ0IgPSAnRUNCJyxcbiAgQ0JDID0gJ0NCQycsXG4gIENUUiA9ICdDVFInXG59XG5cbi8vIFBhZGRpbmcgZW51bVxuZXhwb3J0IGVudW0gUGFkZGluZ1R5cGUge1xuICBQS0NTNyA9ICdQS0NTNycsXG4gIEFOU0lfWDkyMyA9ICdBTlNJIFguOTIzJyxcbiAgTk9ORSA9ICdOb25lJ1xufVxuXG4vLyBPdXRwdXQgZm9ybWF0IGVudW1cbmV4cG9ydCBlbnVtIE91dHB1dEZvcm1hdCB7XG4gIEJBU0U2NCA9ICdCYXNlNjQnLFxuICBIRVggPSAnSGV4JyxcbiAgQklOQVJZID0gJ0JpbmFyeSdcbn1cblxuLy8gS2V5IGxlbmd0aCBlbnVtXG5leHBvcnQgZW51bSBLZXlMZW5ndGgge1xuICBBRVNfMTI4ID0gMTI4LFxuICBBRVNfMTkyID0gMTkyLFxuICBBRVNfMjU2ID0gMjU2XG59XG5cbmNvbnN0IGdldE51bVJvdW5kcyA9IChrZXlMZW5ndGg6IEtleUxlbmd0aCk6IG51bWJlciA9PiAoXG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xMjggPyAxMCA6XG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xOTIgPyAxMiA6IDE0XG4pO1xuXG5jb25zdCBnZXRLZXlCeXRlTGVuZ3RoID0gKGtleUxlbmd0aDogS2V5TGVuZ3RoKTogbnVtYmVyID0+IGtleUxlbmd0aCAvIDg7XG5cbi8vIEFFUyBTLUJveCAoU3RhbmRhcmQgUmlqbmRhZWwgUy1ib3gpXG5leHBvcnQgY29uc3QgU0JPWCA9IFtcbiAgMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NixcbiAgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCxcbiAgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSxcbiAgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSxcbiAgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCxcbiAgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZixcbiAgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCxcbiAgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMixcbiAgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MyxcbiAgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYixcbiAgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSxcbiAgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCxcbiAgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSxcbiAgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSxcbiAgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZixcbiAgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNixcbl07XG5cbi8vIEFFUyBSY29uIChSb3VuZCBDb25zdGFudHMpXG5leHBvcnQgY29uc3QgUkNPTiA9IFtcbiAgMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSxcbl07XG5cbi8vIFVzZWQgaW4gTWl4Q29sdW1uc1xuZXhwb3J0IGNvbnN0IEdBTE9JU19NVUxfMiA9IFtcbiAgMHgwMCwgMHgwMiwgMHgwNCwgMHgwNiwgMHgwOCwgMHgwYSwgMHgwYywgMHgwZSwgMHgxMCwgMHgxMiwgMHgxNCwgMHgxNiwgMHgxOCwgMHgxYSwgMHgxYywgMHgxZSxcbiAgMHgyMCwgMHgyMiwgMHgyNCwgMHgyNiwgMHgyOCwgMHgyYSwgMHgyYywgMHgyZSwgMHgzMCwgMHgzMiwgMHgzNCwgMHgzNiwgMHgzOCwgMHgzYSwgMHgzYywgMHgzZSxcbiAgMHg0MCwgMHg0MiwgMHg0NCwgMHg0NiwgMHg0OCwgMHg0YSwgMHg0YywgMHg0ZSwgMHg1MCwgMHg1MiwgMHg1NCwgMHg1NiwgMHg1OCwgMHg1YSwgMHg1YywgMHg1ZSxcbiAgMHg2MCwgMHg2MiwgMHg2NCwgMHg2NiwgMHg2OCwgMHg2YSwgMHg2YywgMHg2ZSwgMHg3MCwgMHg3MiwgMHg3NCwgMHg3NiwgMHg3OCwgMHg3YSwgMHg3YywgMHg3ZSxcbiAgMHg4MCwgMHg4MiwgMHg4NCwgMHg4NiwgMHg4OCwgMHg4YSwgMHg4YywgMHg4ZSwgMHg5MCwgMHg5MiwgMHg5NCwgMHg5NiwgMHg5OCwgMHg5YSwgMHg5YywgMHg5ZSxcbiAgMHhhMCwgMHhhMiwgMHhhNCwgMHhhNiwgMHhhOCwgMHhhYSwgMHhhYywgMHhhZSwgMHhiMCwgMHhiMiwgMHhiNCwgMHhiNiwgMHhiOCwgMHhiYSwgMHhiYywgMHhiZSxcbiAgMHhjMCwgMHhjMiwgMHhjNCwgMHhjNiwgMHhjOCwgMHhjYSwgMHhjYywgMHhjZSwgMHhkMCwgMHhkMiwgMHhkNCwgMHhkNiwgMHhkOCwgMHhkYSwgMHhkYywgMHhkZSxcbiAgMHhlMCwgMHhlMiwgMHhlNCwgMHhlNiwgMHhlOCwgMHhlYSwgMHhlYywgMHhlZSwgMHhmMCwgMHhmMiwgMHhmNCwgMHhmNiwgMHhmOCwgMHhmYSwgMHhmYywgMHhmZSxcbiAgMHgxYiwgMHgxOSwgMHgxZiwgMHgxZCwgMHgxMywgMHgxMSwgMHgxNywgMHgxNSwgMHgwYiwgMHgwOSwgMHgwZiwgMHgwZCwgMHgwMywgMHgwMSwgMHgwNywgMHgwNSxcbiAgMHgzYiwgMHgzOSwgMHgzZiwgMHgzZCwgMHgzMywgMHgzMSwgMHgzNywgMHgzNSwgMHgyYiwgMHgyOSwgMHgyZiwgMHgyZCwgMHgyMywgMHgyMSwgMHgyNywgMHgyNSxcbiAgMHg1YiwgMHg1OSwgMHg1ZiwgMHg1ZCwgMHg1MywgMHg1MSwgMHg1NywgMHg1NSwgMHg0YiwgMHg0OSwgMHg0ZiwgMHg0ZCwgMHg0MywgMHg0MSwgMHg0NywgMHg0NSxcbiAgMHg3YiwgMHg3OSwgMHg3ZiwgMHg3ZCwgMHg3MywgMHg3MSwgMHg3NywgMHg3NSwgMHg2YiwgMHg2OSwgMHg2ZiwgMHg2ZCwgMHg2MywgMHg2MSwgMHg2NywgMHg2NSxcbiAgMHg5YiwgMHg5OSwgMHg5ZiwgMHg5ZCwgMHg5MywgMHg5MSwgMHg5NywgMHg5NSwgMHg4YiwgMHg4OSwgMHg4ZiwgMHg4ZCwgMHg4MywgMHg4MSwgMHg4NywgMHg4NSxcbiAgMHhiYiwgMHhiOSwgMHhiZiwgMHhiZCwgMHhiMywgMHhiMSwgMHhiNywgMHhiNSwgMHhhYiwgMHhhOSwgMHhhZiwgMHhhZCwgMHhhMywgMHhhMSwgMHhhNywgMHhhNSxcbiAgMHhkYiwgMHhkOSwgMHhkZiwgMHhkZCwgMHhkMywgMHhkMSwgMHhkNywgMHhkNSwgMHhjYiwgMHhjOSwgMHhjZiwgMHhjZCwgMHhjMywgMHhjMSwgMHhjNywgMHhjNSxcbiAgMHhmYiwgMHhmOSwgMHhmZiwgMHhmZCwgMHhmMywgMHhmMSwgMHhmNywgMHhmNSwgMHhlYiwgMHhlOSwgMHhlZiwgMHhlZCwgMHhlMywgMHhlMSwgMHhlNywgMHhlNSxcbl07XG5cbmV4cG9ydCBjb25zdCBHQUxPSVNfTVVMXzMgPSBbXG4gIDB4MDAsIDB4MDMsIDB4MDYsIDB4MDUsIDB4MGMsIDB4MGYsIDB4MGEsIDB4MDksIDB4MTgsIDB4MWIsIDB4MWUsIDB4MWQsIDB4MTQsIDB4MTcsIDB4MTIsIDB4MTEsXG4gIDB4MzAsIDB4MzMsIDB4MzYsIDB4MzUsIDB4M2MsIDB4M2YsIDB4M2EsIDB4MzksIDB4MjgsIDB4MmIsIDB4MmUsIDB4MmQsIDB4MjQsIDB4MjcsIDB4MjIsIDB4MjEsXG4gIDB4NjAsIDB4NjMsIDB4NjYsIDB4NjUsIDB4NmMsIDB4NmYsIDB4NmEsIDB4NjksIDB4NzgsIDB4N2IsIDB4N2UsIDB4N2QsIDB4NzQsIDB4NzcsIDB4NzIsIDB4NzEsXG4gIDB4NTAsIDB4NTMsIDB4NTYsIDB4NTUsIDB4NWMsIDB4NWYsIDB4NWEsIDB4NTksIDB4NDgsIDB4NGIsIDB4NGUsIDB4NGQsIDB4NDQsIDB4NDcsIDB4NDIsIDB4NDEsXG4gIDB4YzAsIDB4YzMsIDB4YzYsIDB4YzUsIDB4Y2MsIDB4Y2YsIDB4Y2EsIDB4YzksIDB4ZDgsIDB4ZGIsIDB4ZGUsIDB4ZGQsIDB4ZDQsIDB4ZDcsIDB4ZDIsIDB4ZDEsXG4gIDB4ZjAsIDB4ZjMsIDB4ZjYsIDB4ZjUsIDB4ZmMsIDB4ZmYsIDB4ZmEsIDB4ZjksIDB4ZTgsIDB4ZWIsIDB4ZWUsIDB4ZWQsIDB4ZTQsIDB4ZTcsIDB4ZTIsIDB4ZTEsXG4gIDB4YTAsIDB4YTMsIDB4YTYsIDB4YTUsIDB4YWMsIDB4YWYsIDB4YWEsIDB4YTksIDB4YjgsIDB4YmIsIDB4YmUsIDB4YmQsIDB4YjQsIDB4YjcsIDB4YjIsIDB4YjEsXG4gIDB4OTAsIDB4OTMsIDB4OTYsIDB4OTUsIDB4OWMsIDB4OWYsIDB4OWEsIDB4OTksIDB4ODgsIDB4OGIsIDB4OGUsIDB4OGQsIDB4ODQsIDB4ODcsIDB4ODIsIDB4ODEsXG4gIDB4OWIsIDB4OTgsIDB4OWQsIDB4OWUsIDB4OTcsIDB4OTQsIDB4OTEsIDB4OTIsIDB4ODMsIDB4ODAsIDB4ODUsIDB4ODYsIDB4OGYsIDB4OGMsIDB4ODksIDB4OGEsXG4gIDB4YWIsIDB4YTgsIDB4YWQsIDB4YWUsIDB4YTcsIDB4YTQsIDB4YTEsIDB4YTIsIDB4YjMsIDB4YjAsIDB4YjUsIDB4YjYsIDB4YmYsIDB4YmMsIDB4YjksIDB4YmEsXG4gIDB4ZmIsIDB4ZjgsIDB4ZmQsIDB4ZmUsIDB4ZjcsIDB4ZjQsIDB4ZjEsIDB4ZjIsIDB4ZTMsIDB4ZTAsIDB4ZTUsIDB4ZTYsIDB4ZWYsIDB4ZWMsIDB4ZTksIDB4ZWEsXG4gIDB4Y2IsIDB4YzgsIDB4Y2QsIDB4Y2UsIDB4YzcsIDB4YzQsIDB4YzEsIDB4YzIsIDB4ZDMsIDB4ZDAsIDB4ZDUsIDB4ZDYsIDB4ZGYsIDB4ZGMsIDB4ZDksIDB4ZGEsXG4gIDB4NWIsIDB4NTgsIDB4NWQsIDB4NWUsIDB4NTcsIDB4NTQsIDB4NTEsIDB4NTIsIDB4NDMsIDB4NDAsIDB4NDUsIDB4NDYsIDB4NGYsIDB4NGMsIDB4NDksIDB4NGEsXG4gIDB4NmIsIDB4NjgsIDB4NmQsIDB4NmUsIDB4NjcsIDB4NjQsIDB4NjEsIDB4NjIsIDB4NzMsIDB4NzAsIDB4NzUsIDB4NzYsIDB4N2YsIDB4N2MsIDB4NzksIDB4N2EsXG4gIDB4M2IsIDB4MzgsIDB4M2QsIDB4M2UsIDB4MzcsIDB4MzQsIDB4MzEsIDB4MzIsIDB4MjMsIDB4MjAsIDB4MjUsIDB4MjYsIDB4MmYsIDB4MmMsIDB4MjksIDB4MmEsXG4gIDB4MGIsIDB4MDgsIDB4MGQsIDB4MGUsIDB4MDcsIDB4MDQsIDB4MDEsIDB4MDIsIDB4MTMsIDB4MTAsIDB4MTUsIDB4MTYsIDB4MWYsIDB4MWMsIDB4MTksIDB4MWEsXG5dO1xuXG4vLyBDb252ZXJ0IHRleHQgdG8gYSBzdGF0ZSBtYXRyaXggLSByZXR1cm5zIGFycmF5IG9mIGJ5dGVzXG5leHBvcnQgY29uc3QgdGV4dFRvU3RhdGUgPSAodGV4dDogc3RyaW5nKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh0ZXh0KTtcbiAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRBcnJheS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHdvcmQgPSB3b3JkQXJyYXkud29yZHNbaV07XG4gICAgY29uc3QgYnl0ZXNJblRoaXNXb3JkID0gTWF0aC5taW4oNCwgc2lnQnl0ZXMgLSBpICogNCk7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAxKSBieXRlcy5wdXNoKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDIpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDE2KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMykgYnl0ZXMucHVzaCgod29yZCA+Pj4gOCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDQpIGJ5dGVzLnB1c2god29yZCAmIDB4ZmYpO1xuICB9XG4gIFxuICAvLyBQYWQgdG8gMTYgYnl0ZXMgaWYgbmVlZGVkXG4gIHdoaWxlIChieXRlcy5sZW5ndGggPCAxNikge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIGNvbnN0IGJsb2NrID0gYnl0ZXMuc2xpY2UoMCwgMTYpO1xuICAvLyBBRVMgc3RhdGUgaXMgY29sdW1uLW1ham9yOiBzdGF0ZVtyICsgNCpjXSA9IGlucHV0WzQqYyArIHJdXG4gIHJldHVybiBibG9jaztcbn07XG5cbi8vIENvbnZlcnQgYSBoZXgga2V5IHRvIGFycmF5IG9mIGJ5dGVzXG5leHBvcnQgY29uc3Qga2V5VG9CeXRlcyA9IChrZXk6IHN0cmluZyk6IG51bWJlcltdID0+IHtcbiAgLy8gUmVtb3ZlIHNwYWNlcyBhbmQgY29udmVydCB0byBsb3dlcmNhc2VcbiAgY29uc3QgY2xlYW5LZXkgPSBrZXkucmVwbGFjZSgvXFxzL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBcbiAgLy8gSWYgaXQncyBhIGhleCBzdHJpbmcsIGNvbnZlcnQgaXRcbiAgaWYgKC9eWzAtOWEtZl0rJC8udGVzdChjbGVhbktleSkpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oY2xlYW5LZXkubGVuZ3RoLCAzMik7IGkgKz0gMikge1xuICAgICAgYnl0ZXMucHVzaChwYXJzZUludChjbGVhbktleS5zdWJzdHIoaSwgMiksIDE2KSk7XG4gICAgfVxuICAgIC8vIFBhZCB0byAxNiBieXRlcyBpZiBuZWVkZWRcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5zbGljZSgwLCAxNik7XG4gIH0gXG4gIFxuICAvLyBPdGhlcndpc2UsIHRyZWF0IGFzIFVURi04IHRleHRcbiAgcmV0dXJuIHRleHRUb1N0YXRlKGtleSk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHJhbmRvbSBrZXkgYXMgYnl0ZSBhcnJheSBiYXNlZCBvbiBrZXkgbGVuZ3RoXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21LZXkgPSAoa2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCk6IG51bWJlcltdID0+IHtcbiAgY29uc3Qga2V5Qnl0ZXMgPSBrZXlMZW5ndGggLyA4O1xuICBjb25zdCBieXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUJ5dGVzOyBpKyspIHtcbiAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn07XG5cbi8vIEZvcm1hdCBieXRlcyBhcyBoZXhcbmV4cG9ydCBjb25zdCBieXRlc1RvSGV4ID0gKGJ5dGVzOiBudW1iZXJbXSwgam9pbkNoYXI6IHN0cmluZyA9ICcgJyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBieXRlcy5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKGpvaW5DaGFyKTtcbn07XG5cbi8vIEZvcm1hdCBieXRlcyBhcyBiaW5hcnlcbmV4cG9ydCBjb25zdCBieXRlc1RvQmluYXJ5ID0gKGJ5dGVzOiBudW1iZXJbXSwgam9pbkNoYXI6IHN0cmluZyA9ICcgJyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBieXRlcy5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDgsICcwJykpLmpvaW4oam9pbkNoYXIpO1xufTtcblxuLy8gU3ViQnl0ZXMgb3BlcmF0aW9uIC0gc3Vic3RpdHV0ZSBlYWNoIGJ5dGUgd2l0aCBpdHMgUy1ib3ggdmFsdWVcbmV4cG9ydCBjb25zdCBzdWJCeXRlcyA9IChzdGF0ZTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIHJldHVybiBzdGF0ZS5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbn07XG5cbi8vIFNoaWZ0Um93cyBvcGVyYXRpb24gLSByb3RhdGUgcm93cyBvZiB0aGUgc3RhdGUgbWF0cml4XG5leHBvcnQgY29uc3Qgc2hpZnRSb3dzID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gWy4uLnN0YXRlXTtcbiAgXG4gIC8vIENvbHVtbi1tYWpvciBzdGF0ZSBpbmRleCBoZWxwZXI6IGlkeChyb3csIGNvbCkgPSByb3cgKyA0KmNvbFxuICBjb25zdCBpZHggPSAocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKSA9PiByb3cgKyA0ICogY29sO1xuXG4gIGZvciAobGV0IHJvdyA9IDE7IHJvdyA8IDQ7IHJvdysrKSB7XG4gICAgY29uc3Qgcm93VmFsdWVzID0gW3N0YXRlW2lkeChyb3csIDApXSwgc3RhdGVbaWR4KHJvdywgMSldLCBzdGF0ZVtpZHgocm93LCAyKV0sIHN0YXRlW2lkeChyb3csIDMpXV07XG4gICAgY29uc3Qgc2hpZnRlZCA9IHJvd1ZhbHVlcy5zbGljZShyb3cpLmNvbmNhdChyb3dWYWx1ZXMuc2xpY2UoMCwgcm93KSk7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgNDsgY29sKyspIHtcbiAgICAgIHJlc3VsdFtpZHgocm93LCBjb2wpXSA9IHNoaWZ0ZWRbY29sXTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBNaXhDb2x1bW5zIG9wZXJhdGlvbiAtIG1peCBkYXRhIHdpdGhpbiBjb2x1bW5zXG5leHBvcnQgY29uc3QgbWl4Q29sdW1ucyA9IChzdGF0ZTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFsuLi5zdGF0ZV07XG4gIGNvbnN0IGlkeCA9IChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpID0+IHJvdyArIDQgKiBjb2w7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgczAgPSBzdGF0ZVtpZHgoMCwgaSldO1xuICAgIGNvbnN0IHMxID0gc3RhdGVbaWR4KDEsIGkpXTtcbiAgICBjb25zdCBzMiA9IHN0YXRlW2lkeCgyLCBpKV07XG4gICAgY29uc3QgczMgPSBzdGF0ZVtpZHgoMywgaSldO1xuICAgIFxuICAgIHJlc3VsdFtpZHgoMCwgaSldID0gR0FMT0lTX01VTF8yW3MwXSBeIEdBTE9JU19NVUxfM1tzMV0gXiBzMiBeIHMzO1xuICAgIHJlc3VsdFtpZHgoMSwgaSldID0gczAgXiBHQUxPSVNfTVVMXzJbczFdIF4gR0FMT0lTX01VTF8zW3MyXSBeIHMzO1xuICAgIHJlc3VsdFtpZHgoMiwgaSldID0gczAgXiBzMSBeIEdBTE9JU19NVUxfMltzMl0gXiBHQUxPSVNfTVVMXzNbczNdO1xuICAgIHJlc3VsdFtpZHgoMywgaSldID0gR0FMT0lTX01VTF8zW3MwXSBeIHMxIF4gczIgXiBHQUxPSVNfTVVMXzJbczNdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBBZGRSb3VuZEtleSBvcGVyYXRpb24gLSBYT1Igc3RhdGUgd2l0aCByb3VuZCBrZXlcbmV4cG9ydCBjb25zdCBhZGRSb3VuZEtleSA9IChzdGF0ZTogbnVtYmVyW10sIHJvdW5kS2V5OiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgcmV0dXJuIHN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIHJvdW5kS2V5W2ldKTtcbn07XG5cbi8vIEthbGl0bmkga2VuZ2F5dGlyaXNoIOKAlCByYXVuZCBrYWxpdGxhcmluaSBnZW5lcmF0c2l5YSBxaWxpc2hcbmV4cG9ydCBjb25zdCBrZXlFeHBhbnNpb24gPSAoa2V5OiBudW1iZXJbXSwga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCk6IG51bWJlcltdW10gPT4ge1xuICBjb25zdCBrZXlXb3JkcyA9IGtleS5sZW5ndGggLyA0O1xuICBjb25zdCBudW1Sb3VuZHMgPSBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTI4ID8gMTAgOiBcbiAgICAgICAgICAgICAgICAgICAga2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzE5MiA/IDEyIDogMTQ7XG4gIFxuICBjb25zdCByb3VuZEtleXM6IG51bWJlcltdW10gPSBba2V5LnNsaWNlKCldOyAvLyAxLXJhdW5kIGthbGl0aSBib3NobGFuZ+KAmGljaCBrYWxpdG5pbmcgb+KAmHppIGhpc29ibGFuYWRpXG4gIFxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGNvbnN0IHByZXZLZXkgPSByb3VuZEtleXNbcm91bmQgLSAxXTtcbiAgICBjb25zdCBuZXdLZXkgPSBwcmV2S2V5LnNsaWNlKCk7XG4gICAgXG4gICAgLy8gT3hpcmdpIHdvcmQgbmkgYXlsYW50aXJpYiwgUy1ib3ggbmkgcW/igJhsbGFuZ1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHByZXZLZXkubGVuZ3RoIC0gNDtcbiAgICBjb25zdCBsYXN0V29yZCA9IFtwcmV2S2V5W2xhc3RJbmRleF0sIHByZXZLZXlbbGFzdEluZGV4ICsgMV0sIHByZXZLZXlbbGFzdEluZGV4ICsgMl0sIHByZXZLZXlbbGFzdEluZGV4ICsgM11dO1xuICAgIGNvbnN0IHJvdFdvcmQgPSBbbGFzdFdvcmRbMV0sIGxhc3RXb3JkWzJdLCBsYXN0V29yZFszXSwgbGFzdFdvcmRbMF1dO1xuICAgIGNvbnN0IHN1YldvcmQgPSByb3RXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgIFxuICAgIC8vIEJpcmluY2hpIGJheXRuaSBSY29uIGJpbGFuIFhPUiBxaWxpbmFkaVxuICAgIHN1YldvcmRbMF0gXj0gUkNPTltyb3VuZF07XG4gICAgXG4gICAgLy8gWWFuZ2kga2FsaXRuaW5nIGJpcmluY2hpIHdvcmQgaSBnZW5lcmF0c2l5YSBxaWxpbmFkaVxuICAgIG5ld0tleVswXSA9IHByZXZLZXlbMF0gXiBzdWJXb3JkWzBdO1xuICAgIG5ld0tleVsxXSA9IHByZXZLZXlbMV0gXiBzdWJXb3JkWzFdO1xuICAgIG5ld0tleVsyXSA9IHByZXZLZXlbMl0gXiBzdWJXb3JkWzJdO1xuICAgIG5ld0tleVszXSA9IHByZXZLZXlbM10gXiBzdWJXb3JkWzNdO1xuICAgIFxuICAgIC8vIFFvbGdhbiB3b3JkIGxhciBob3NpbCBxaWxpbmFkaVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5V29yZHM7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG4gICAgICAvLyBBRVMtMjU2IGhvbGF0aWRhIGhhciB0b+KAmHJ0aW5jaGkgd29yZCBnYSBxb+KAmHNoaW1jaGEgUy1ib3ggKFN1YldvcmQpIHFv4oCYbGxhbmFkaVxuICAgICAgaWYgKGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18yNTYgJiYgaSA9PT0gNCkge1xuICAgICAgICBjb25zdCB0ZW1wV29yZCA9IFtuZXdLZXlbb2Zmc2V0IC0gNF0sIG5ld0tleVtvZmZzZXQgLSAzXSwgbmV3S2V5W29mZnNldCAtIDJdLCBuZXdLZXlbb2Zmc2V0IC0gMV1dO1xuICAgICAgICBjb25zdCBzdWJUZW1wV29yZCA9IHRlbXBXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgICAgICBcbiAgICAgICAgbmV3S2V5W29mZnNldF0gPSBwcmV2S2V5W29mZnNldF0gXiBzdWJUZW1wV29yZFswXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDFdID0gcHJldktleVtvZmZzZXQgKyAxXSBeIHN1YlRlbXBXb3JkWzFdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBwcmV2S2V5W29mZnNldCArIDJdIF4gc3ViVGVtcFdvcmRbMl07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAzXSA9IHByZXZLZXlbb2Zmc2V0ICsgM10gXiBzdWJUZW1wV29yZFszXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0tleVtvZmZzZXRdID0gbmV3S2V5W29mZnNldCAtIDRdIF4gcHJldktleVtvZmZzZXRdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMV0gPSBuZXdLZXlbb2Zmc2V0IC0gM10gXiBwcmV2S2V5W29mZnNldCArIDFdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBuZXdLZXlbb2Zmc2V0IC0gMl0gXiBwcmV2S2V5W29mZnNldCArIDJdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgM10gPSBuZXdLZXlbb2Zmc2V0IC0gMV0gXiBwcmV2S2V5W29mZnNldCArIDNdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByb3VuZEtleXMucHVzaChuZXdLZXkpO1xuICB9XG4gIFxuICByZXR1cm4gcm91bmRLZXlzO1xufTtcblxuLy8gUGVyZm9ybSBvbmUgcm91bmQgb2YgQUVTXG5leHBvcnQgY29uc3QgYWVzUm91bmQgPSAoc3RhdGU6IG51bWJlcltdLCByb3VuZEtleTogbnVtYmVyW10sIGlzTGFzdFJvdW5kOiBib29sZWFuKTogbnVtYmVyW10gPT4ge1xuICBsZXQgbmV3U3RhdGUgPSBzdWJCeXRlcyhzdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2hpZnRSb3dzKG5ld1N0YXRlKTtcbiAgaWYgKCFpc0xhc3RSb3VuZCkge1xuICAgIG5ld1N0YXRlID0gbWl4Q29sdW1ucyhuZXdTdGF0ZSk7XG4gIH1cbiAgbmV3U3RhdGUgPSBhZGRSb3VuZEtleShuZXdTdGF0ZSwgcm91bmRLZXkpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vLyBDb21wbGV0ZSBBRVMgZW5jcnlwdGlvblxuZXhwb3J0IGNvbnN0IGFlc0VuY3J5cHQgPSAocGxhaW50ZXh0OiBzdHJpbmcsIGtleTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIC8vIEluaXRpYWwgc3RhdGVcbiAgY29uc3Qgc3RhdGUgPSB0ZXh0VG9TdGF0ZShwbGFpbnRleHQpO1xuICBcbiAgLy8gS2V5IGV4cGFuc2lvblxuICBjb25zdCByb3VuZEtleXMgPSBrZXlFeHBhbnNpb24oa2V5KTtcbiAgXG4gIC8vIEluaXRpYWwgcm91bmQgLSBqdXN0IEFkZFJvdW5kS2V5XG4gIGxldCBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShzdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgXG4gIC8vIE1haW4gcm91bmRzXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICBjdXJyZW50U3RhdGUgPSBhZXNSb3VuZChjdXJyZW50U3RhdGUsIHJvdW5kS2V5c1tyb3VuZF0sIHJvdW5kID09PSAxMCk7XG4gIH1cbiAgXG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59O1xuXG4vLyBDb252ZXJ0IGZ1bGwgdGV4dCB0byBhcnJheSBvZiAxNi1ieXRlIGJsb2Nrc1xuZXhwb3J0IGNvbnN0IHRleHRUb0Jsb2NrcyA9ICh0ZXh0OiBzdHJpbmcsIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcpOiBudW1iZXJbXVtdID0+IHtcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodGV4dCk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBcbiAgLy8gQ29udmVydCBDcnlwdG9KUyBXb3JkQXJyYXkgdG8gYnl0ZSBhcnJheSwgcmVzcGVjdGluZyBzaWdCeXRlc1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIFxuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgcGFkZGluZ1xuICBsZXQgcGFkZGVkQnl0ZXM6IG51bWJlcltdO1xuICBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuUEtDUzcpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5UEtDUzdQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSBQYWRkaW5nVHlwZS5BTlNJX1g5MjMpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5QW5zaVg5MjNQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIHsgLy8gTk9ORVxuICAgIHBhZGRlZEJ5dGVzID0gWy4uLmJ5dGVzXTtcbiAgICAvLyBGb3IgTk9ORSBwYWRkaW5nLCBtdXN0IGJlIG11bHRpcGxlIG9mIDE2XG4gICAgd2hpbGUgKHBhZGRlZEJ5dGVzLmxlbmd0aCAlIDE2ICE9PSAwKSB7XG4gICAgICBwYWRkZWRCeXRlcy5wdXNoKDApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3BsaXQgaW50byAxNi1ieXRlIGJsb2Nrc1xuICBjb25zdCBibG9ja3M6IG51bWJlcltdW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCeXRlcy5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBibG9ja3MucHVzaChwYWRkZWRCeXRlcy5zbGljZShpLCBpICsgMTYpKTtcbiAgfVxuICBcbiAgcmV0dXJuIGJsb2Nrcztcbn07XG5cbi8vIEFwcGx5IFBLQ1M3IHBhZGRpbmdcbmV4cG9ydCBjb25zdCBhcHBseVBLQ1M3UGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGVkID0gWy4uLmRhdGFdO1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmdMZW5ndGg7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKHBhZGRpbmdMZW5ndGgpO1xuICB9XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gQXBwbHkgQU5TSSBYLjkyMyBwYWRkaW5nXG5leHBvcnQgY29uc3QgYXBwbHlBbnNpWDkyM1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRlZCA9IFsuLi5kYXRhXTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICBcbiAgLy8gQWRkIHBhZGRpbmcgYnl0ZXMgKDB4MDApIGV4Y2VwdCB0aGUgbGFzdCBieXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGluZ0xlbmd0aCAtIDE7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKDB4MDApO1xuICB9XG4gIFxuICAvLyBBZGQgdGhlIHBhZGRpbmcgbGVuZ3RoIGFzIHRoZSBsYXN0IGJ5dGVcbiAgcGFkZGVkLnB1c2gocGFkZGluZ0xlbmd0aCk7XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gUmVtb3ZlIEFOU0kgWC45MjMgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IHJlbW92ZUFuc2lYOTIzUGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBwYWRkaW5nTGVuZ3RoKTtcbn07XG5cbi8vIEdldCBJViBmb3IgQ0JDIG1vZGVcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUlWID0gKCk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaXYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgaXYucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgfVxuICByZXR1cm4gaXY7XG59O1xuXG4vLyBHZXQgYWxsIGludGVybWVkaWF0ZSBzdGF0ZXMgZm9yIHZpc3VhbGl6YXRpb25cbmV4cG9ydCB0eXBlIEFlc1N0ZXAgPSB7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHN0YXRlOiBudW1iZXJbXTtcbiAgYWN0aXZlSW5kaWNlcz86IG51bWJlcltdOyAgLy8gRm9yIGhpZ2hsaWdodGluZyBzcGVjaWZpYyBjZWxsc1xuICBleHBsYW5hdGlvbj86IHN0cmluZzsgICAgICAvLyBNb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uXG4gIHJvdW5kS2V5PzogbnVtYmVyW107XG4gIHByZXZpb3VzU3RhdGU/OiBudW1iZXJbXTsgIC8vIEZvciBzaG93aW5nIGJlZm9yZS9hZnRlciBjb21wYXJpc29uXG59O1xuXG4vLyBHZXQgQUVTIHN0ZXBzIGZvciBhIHNpbmdsZSBibG9jayAoMTYgYnl0ZXMpXG5leHBvcnQgY29uc3QgZ2V0QWVzU3RlcHNGb3JCbG9jayA9IChcbiAgYmxvY2s6IG51bWJlcltdLFxuICBrZXk6IG51bWJlcltdLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIGJsb2NrSW5kZXg6IG51bWJlciA9IDAsXG4gIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrPzogbnVtYmVyW10sXG4gIGl2PzogbnVtYmVyW11cbik6IHtcbiAgc3RlcHM6IEFlc1N0ZXBbXSxcbiAgZmluYWxTdGF0ZTogbnVtYmVyW11cbn0gPT4ge1xuICBjb25zdCBzdGVwczogQWVzU3RlcFtdID0gW107XG4gIFxuICAvLyBFbnN1cmUgYmxvY2sgaXMgZXhhY3RseSAxNiBieXRlc1xuICBjb25zdCBwbGFpbnRleHRCeXRlcyA9IFsuLi5ibG9ja107XG4gIHdoaWxlIChwbGFpbnRleHRCeXRlcy5sZW5ndGggPCAxNikge1xuICAgIHBsYWludGV4dEJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIEFzbCBvY2hpcSBtYXRuYCwgXG4gICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSBiYXl0Z2EgYXlsYW50aXJpbGFkaSB2YSA0w5c0IG1hdHJpdHNhIHNoYWtsaWRhIGlmb2RhbGFuYWRpLmBcbiAgfSk7XG4gIFxuICBjb25zdCBpbml0aWFsU3RhdGUgPSBwbGFpbnRleHRCeXRlcztcbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSk7XG4gIFxuICBsZXQgY3VycmVudFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoYmxvY2tJbmRleCA9PT0gMCAmJiBpdikge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaXZbaV0pO1xuICAgICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBJViBiaWxhbiBYT1JgLCBcbiAgICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHJvdW5kS2V5OiBpdixcbiAgICAgICAgICBleHBsYW5hdGlvbjogYENCQzogYmlyaW5jaGkgYmxvayBJViBiaWxhbiBYT1IgcWlsaW5hZGkuYFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2spIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrW2ldKTtcbiAgICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgT2xkaW5naSBjaXBoZXJ0ZXh0IGJpbGFuIFhPUmAsIFxuICAgICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgICAgcm91bmRLZXk6IHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ0JDOiBrZXlpbmdpIGJsb2tsYXIgb2xkaW5naSBjaXBoZXJ0ZXh0IGJsb2tpIGJpbGFuIFhPUiBxaWxpbmFkaS5gXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGlmICghaXYpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcHM6IFtdLCBmaW5hbFN0YXRlOiBwbGFpbnRleHRCeXRlcyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY291bnRlckJsb2NrID0gWy4uLml2XTtcbiAgICAgIGxldCBjb3VudGVyVmFsdWUgPSBibG9ja0luZGV4O1xuICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDAgJiYgY291bnRlclZhbHVlID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJCbG9ja1tpXSArIChjb3VudGVyVmFsdWUgJiAweGZmKTtcbiAgICAgICAgY291bnRlckJsb2NrW2ldID0gc3VtICYgMHhmZjtcbiAgICAgICAgY291bnRlclZhbHVlID0gKGNvdW50ZXJWYWx1ZSA+PiA4KSArIChzdW0gPj4gOCk7XG4gICAgICB9XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQ291bnRlcmAsIFxuICAgICAgICBzdGF0ZTogY291bnRlckJsb2NrLFxuICAgICAgICBleHBsYW5hdGlvbjogYENUUjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSB1Y2h1biBjb3VudGVyLmBcbiAgICAgIH0pO1xuICAgICAgY3VycmVudFN0YXRlID0gY291bnRlckJsb2NrO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQm9zaGxhbmcnaWNoYCwgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgRUNCOiBibG9rICR7YmxvY2tJbmRleCArIDF9IG11c3RhcWlsIHNoaWZybGFuYWRpLmBcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGNvbnN0IGFmdGVySW5pdGlhbFJvdW5kID0gYWRkUm91bmRLZXkoY3VycmVudFN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAwLWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgc3RhdGU6IGFmdGVySW5pdGlhbFJvdW5kLFxuICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgZXhwbGFuYXRpb246ICcnLFxuICAgIHJvdW5kS2V5OiByb3VuZEtleXNbMF0sXG4gICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlLFxuICB9KTtcbiAgXG4gIGN1cnJlbnRTdGF0ZSA9IGFmdGVySW5pdGlhbFJvdW5kO1xuICBcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSAxMDsgcm91bmQrKykge1xuICAgIGNvbnN0IGFmdGVyU3ViQnl0ZXMgPSBzdWJCeXRlcyhjdXJyZW50U3RhdGUpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgU3ViQnl0ZXNgLCBcbiAgICAgIHN0YXRlOiBhZnRlclN1YkJ5dGVzLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IGFmdGVyU2hpZnRSb3dzID0gc2hpZnRSb3dzKGFmdGVyU3ViQnl0ZXMpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgU2hpZnRSb3dzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTaGlmdFJvd3MsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBbMSwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExLCAxMywgMTQsIDE1XSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHByZXZpb3VzU3RhdGU6IGFmdGVyU3ViQnl0ZXNcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5OiBudW1iZXJbXTtcbiAgICBcbiAgICBpZiAocm91bmQgPCAxMCkge1xuICAgICAgY29uc3QgYWZ0ZXJNaXhDb2x1bW5zID0gbWl4Q29sdW1ucyhhZnRlclNoaWZ0Um93cyk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgTWl4Q29sdW1uc2AsIFxuICAgICAgICBzdGF0ZTogYWZ0ZXJNaXhDb2x1bW5zLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGFmdGVyU2hpZnRSb3dzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJNaXhDb2x1bW5zLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyTWl4Q29sdW1ucztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJTaGlmdFJvd3MsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJTaGlmdFJvd3M7XG4gICAgfVxuICAgIFxuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgQWRkUm91bmRLZXlgLCBcbiAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcm91bmRLZXk6IHJvdW5kS2V5c1tyb3VuZF0sXG4gICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXksXG4gICAgfSk7XG4gIH1cbiAgXG4gIGxldCBmaW5hbFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaW5pdGlhbFN0YXRlW2ldKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBDb3VudGVyIFhPUmAsIFxuICAgICAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246IGBDVFI6IGJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4gY291bnRlciBYT1IuYCxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogY3VycmVudFN0YXRlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIFlha3VuaXlgLCBcbiAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4geWFrdW5peSBzaGlmcmxhbmdhbiBuYXRpamEuYFxuICB9KTtcbiAgXG4gIHJldHVybiB7IHN0ZXBzLCBmaW5hbFN0YXRlIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWVzU3RlcHMgPSAoXG4gIHBsYWludGV4dDogc3RyaW5nLCBcbiAga2V5OiBudW1iZXJbXSwgXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgcHJvdmlkZWRJdj86IG51bWJlcltdXG4pOiB7XG4gIHN0ZXBzOiBBZXNTdGVwW10sXG4gIGZpbmFsQ2lwaGVydGV4dDoge1xuICAgIGJhc2U2NDogc3RyaW5nO1xuICAgIGhleDogc3RyaW5nO1xuICAgIGJpbmFyeTogc3RyaW5nO1xuICB9LFxuICBpdj86IG51bWJlcltdLFxuICBhbGxCbG9ja3M/OiB7IGJsb2NrSW5kZXg6IG51bWJlciwgc3RlcHM6IEFlc1N0ZXBbXSwgZmluYWxTdGF0ZTogbnVtYmVyW10gfVtdXG59ID0+IHtcbiAgY29uc3Qgc3RlcHM6IEFlc1N0ZXBbXSA9IFtdO1xuICBsZXQgaXY6IG51bWJlcltdIHwgdW5kZWZpbmVkID0gcHJvdmlkZWRJdiA/IFsuLi5wcm92aWRlZEl2XSA6IHVuZGVmaW5lZDtcbiAgXG4gIC8vIENvbnZlcnQgZnVsbCB0ZXh0IHRvIGJsb2Nrc1xuICBjb25zdCBibG9ja3MgPSB0ZXh0VG9CbG9ja3MocGxhaW50ZXh0LCBwYWRkaW5nKTtcbiAgY29uc3QgYWxsQmxvY2tzOiB7IGJsb2NrSW5kZXg6IG51bWJlciwgc3RlcHM6IEFlc1N0ZXBbXSwgZmluYWxTdGF0ZTogbnVtYmVyW10gfVtdID0gW107XG4gIFxuICAvLyBDb252ZXJ0IHBsYWludGV4dCB0byBieXRlcyAoZm9yIGZpcnN0IGJsb2NrIHZpc3VhbGl6YXRpb24pXG4gIGxldCBwbGFpbnRleHRCeXRlcyA9IGJsb2Nrc1swXSB8fCB0ZXh0VG9TdGF0ZShwbGFpbnRleHQpO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICdBc2wgb2NoaXEgbWF0bicsIFxuICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICBleHBsYW5hdGlvbjogYE9jaGlxIG1hdG4gXCIke3BsYWludGV4dH1cIiBiYXl0Z2EgYXlsYW50aXJpbGFkaSB2YSA0w5c0IG1hdHJpdHNhIHNoYWtsaWRhIGlmb2RhbGFuYWRpLmBcbiAgfSk7XG4gIFxuICAvLyBBcHBseSBwYWRkaW5nIGlmIG5lZWRlZFxuICBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuQU5TSV9YOTIzKSB7XG4gICAgcGxhaW50ZXh0Qnl0ZXMgPSBhcHBseUFuc2lYOTIzUGFkZGluZyhwbGFpbnRleHRCeXRlcyk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246ICdBTlNJIFguOTIzIHRv4oCYbGRpcmlzaGRhbiBrZXlpbicsIFxuICAgICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgICAgZXhwbGFuYXRpb246ICdBTlNJIFguOTIzIHRv4oCYbGRpcmlzaCBub2xsYXIgYmlsYW4gdG/igJhsZGlyYWRpIHZhIG94aXJnaSBieXRlIGdhIHRv4oCYbGRpcmlzaCB1enVubGlnaW5pIHFv4oCYeWFkaS4nXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEdlbmVyYXRlIElWIGZvciBDQkMvQ1RSIG1vZGUgb25seSBpZiBub3QgcHJvdmlkZWRcbiAgaWYgKChtb2RlID09PSBBZXNNb2RlLkNCQyB8fCBtb2RlID09PSBBZXNNb2RlLkNUUikgJiYgIWl2KSB7XG4gICAgaXYgPSBnZW5lcmF0ZUlWKCk7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIE9ubHkgc2hvdyBJViBzdGVwIGlmIHNpbmdsZSBibG9jayAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBjb25zdCBpdkRlc2NyaXB0aW9uID0gbW9kZSA9PT0gQWVzTW9kZS5DQkMgXG4gICAgICAgID8gJ0Jvc2hsYW5nXFwnaWNoIHZla3RvciAoSW5pdGlhbGl6YXRpb24gVmVjdG9yLCBJViknIFxuICAgICAgICA6ICdDb3VudGVyIChOb25jZSknO1xuICAgICAgY29uc3QgaXZFeHBsYW5hdGlvbiA9IGAke21vZGUgPT09IEFlc01vZGUuQ0JDID8gJ0NCQycgOiAnQ1RSJ30gcmVqaW1pIHVjaHVuIDE2LWJheXQgdGFzb2RpZml5ICR7bW9kZSA9PT0gQWVzTW9kZS5DQkMgPyAnSVYnIDogJ05vbmNlJ30geWFyYXRpbGFkaS5gO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogaXZEZXNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6IGl2LFxuICAgICAgICBleHBsYW5hdGlvbjogaXZFeHBsYW5hdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdGFydCBlbmNyeXB0aW9uIHByb2Nlc3MgKGZvciBmaXJzdCBibG9jayB2aXN1YWxpemF0aW9uKVxuICBjb25zdCBpbml0aWFsU3RhdGUgPSBwbGFpbnRleHRCeXRlcztcbiAgXG4gIC8vIEtleSBleHBhbnNpb25cbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSk7XG4gIFxuICAvLyBJbml0aWFsIHNldHVwIGJhc2VkIG9uIG1vZGVcbiAgbGV0IGN1cnJlbnRTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKCFpdikgaXYgPSBnZW5lcmF0ZUlWKCk7IC8vIEZhaWxzYWZlXG4gICAgICAvLyBYT1IgcGxhaW50ZXh0IHdpdGggSVZcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBpdiFbaV0pXG5cbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ1xcJ2ljaCBob2xhdG5pIElWIGJpbGFuIFhPUiBxaWxpc2gnLCBcbiAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogaXYsIC8vIElWIG5pIHJvdW5kS2V5IHNpZmF0aWRhIGtvJ3JzYXRpc2ggdWNodW5cbiAgICAgICAgZXhwbGFuYXRpb246IGBDQkMgcmVqaW1pZGEgc2hpZnJsYXNoIGJvc2hsYW5pc2hpZGFuIG9sZGluIG9jaGlxIG1hdG4gSVYgYmlsYW4gWE9SIHFpbGluYWRpLiBCdSBqYXJheW9uIENCQyByZWppbWluaW5nIGFzb3NpeSB4dXN1c2l5YXRpZGlyIC0gaGFyIGJpciBvY2hpcSBtYXRuIGJsb2tpIGF2dmFsZ2kgc2hpZnJsYW5nYW4gbWF0biBibG9raSAoeW9raSBiaXJpbmNoaSBibG9rIHVjaHVuIElWKSBiaWxhbiBYT1IgcWlsaW5hZGksIGtleWluIHNoaWZybGFuYWRpLiBCdSBiaXIgeGlsIG9jaGlxIG1hdG4gYmxva2xhcmluaSB0dXJsaSBzaGlmcmxhbmdhbiBtYXRuIGJsb2tsYXJnYSBheWxhbnRpcmFkaSB2YSBzaGlmcmxhbmdhbiBtYXRuZGFnaSBuYXFzaGxhcm5pIHlhc2hpcmlzaGdhIHlvcmRhbSBiZXJhZGkuYFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgLy8gSW4gQ1RSIG1vZGUsIHdlIGVuY3J5cHQgYSBjb3VudGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIHBsYWludGV4dFxuICAgICAgY29uc3QgY291bnRlciA9IGl2IHx8IGdlbmVyYXRlSVYoKTtcbiAgICAgIGlmICghaXYpIGl2ID0gY291bnRlcjtcbiAgICAgIFxuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvdW50ZXIgcWl5bWF0aScsIFxuICAgICAgICBzdGF0ZTogY291bnRlcixcbiAgICAgICAgZXhwbGFuYXRpb246ICdDVFIgcmVqaW1pZGEgb2NoaXEgbWF0biBv4oCYcm5pZ2EgY291bnRlciBxaXltYXRpIHNoaWZybGFuYWRpLidcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjdXJyZW50U3RhdGUgPSBjb3VudGVyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQm9zaGxhbmfigJhpY2ggaG9sYXQgKG9jaGlxIG1hdG4pJywgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnRUNCIHJlamltaWRhIG9jaGlxIG1hdG4gYmxva2xhcmkgbXVzdGFxaWwgcmF2aXNoZGEgc2hpZnJsYW5hZGkuJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgLy8gSW5pdGlhbCByb3VuZCAtIGp1c3QgQWRkUm91bmRLZXkgKFJvdW5kIDApXG4gIGNvbnN0IGFmdGVySW5pdGlhbFJvdW5kID0gYWRkUm91bmRLZXkoY3VycmVudFN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICcwLWJvc3FpY2gg4oCUIEJvc2hsYW5nXFwnaWNoIEFkZFJvdW5kS2V5JywgXG4gICAgc3RhdGU6IGFmdGVySW5pdGlhbFJvdW5kLFxuICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgZXhwbGFuYXRpb246ICcnLFxuICAgIHJvdW5kS2V5OiByb3VuZEtleXNbMF0sXG4gICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlLFxuICB9KTtcbiAgXG4gIGN1cnJlbnRTdGF0ZSA9IGFmdGVySW5pdGlhbFJvdW5kO1xuICBcbiAgLy8gTWFpbiByb3VuZHNcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSAxMDsgcm91bmQrKykge1xuICAgIC8vIFN1YkJ5dGVzXG4gICAgY29uc3QgYWZ0ZXJTdWJCeXRlcyA9IHN1YkJ5dGVzKGN1cnJlbnRTdGF0ZSk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGAke3JvdW5kfS1ib3NxaWNoIOKAlCBTdWJCeXRlc2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU3ViQnl0ZXMsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlIC8vIEFkZCBwcmV2aW91cyBzdGF0ZSBmb3IgUy1ib3ggbG9va3VwXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2hpZnRSb3dzXG4gICAgY29uc3QgYWZ0ZXJTaGlmdFJvd3MgPSBzaGlmdFJvd3MoYWZ0ZXJTdWJCeXRlcyk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGAke3JvdW5kfS1ib3NxaWNoIOKAlCBTaGlmdFJvd3NgLCBcbiAgICAgIHN0YXRlOiBhZnRlclNoaWZ0Um93cyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IFsxLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTEsIDEzLCAxNCwgMTVdLCAvLyBSb3dzIDEsIDIsIDMgKG5vdCBSb3cgMCkgaW4gY29sdW1uLW1ham9yXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclN1YkJ5dGVzIC8vIEFkZCBwcmV2aW91cyBzdGF0ZSBmb3IgY29tcGFyaXNvblxuICAgIH0pO1xuICAgIFxuICAgIGxldCBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXk6IG51bWJlcltdO1xuICAgIFxuICAgIGlmIChyb3VuZCA8IDEwKSB7XG4gICAgICAvLyBNaXhDb2x1bW5zIChub3QgaW4gZmluYWwgcm91bmQpXG4gICAgICBjb25zdCBhZnRlck1peENvbHVtbnMgPSBtaXhDb2x1bW5zKGFmdGVyU2hpZnRSb3dzKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGAke3JvdW5kfS1ib3NxaWNoIOKAlCBNaXhDb2x1bW5zYCwgXG4gICAgICAgIHN0YXRlOiBhZnRlck1peENvbHVtbnMsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTaGlmdFJvd3MgLy8gQWRkIHByZXZpb3VzIHN0YXRlIGZvciBNaXhDb2x1bW5zIGNvbXBhcmlzb25cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBZGRSb3VuZEtleVxuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJNaXhDb2x1bW5zLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyTWl4Q29sdW1ucztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluYWwgcm91bmQgaGFzIG5vIE1peENvbHVtbnNcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyU2hpZnRSb3dzLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyU2hpZnRSb3dzO1xuICAgIH1cbiAgICBcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHJvdW5kS2V5OiByb3VuZEtleXNbcm91bmRdLFxuICAgICAgcHJldmlvdXNTdGF0ZTogcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5LFxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBGaW5hbCBvdXRwdXQgYmFzZWQgb24gbW9kZVxuICBsZXQgZmluYWxTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgLy8gT3V0cHV0IGlzIHRoZSBjdXJyZW50IHN0YXRlIChhbHJlYWR5IGNvbXBsZXRlZCBlbmNyeXB0aW9uKVxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICAvLyBYT1IgdGhlIGVuY3J5cHRlZCBjb3VudGVyIHdpdGggcGxhaW50ZXh0XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGluaXRpYWxTdGF0ZVtpXSk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnT2NoaXEgbWF0biBzaGlmcmxhbmdhbiBoaXNvYmxhZ2ljaCBiaWxhbiBYT1IgYW1hbGl5b3RpZGEgYmlybGFzaHRpcmlsYWRpLicsIFxuICAgICAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246ICdDVFIgcmVqaW1pZGEsIHlha3VuaXkgYm9zcWljaGRhIHNoaWZybGFuZ2FuIGhpc29ibGFnaWNoIG9jaGlxIG1hdG4gYmlsYW4gWE9SIGFtYWxpeW90aSBvcnFhbGkgYmlybGFzaHRpcmlsYWRpIHZhIG5hdGlqYWRhIHNoaWZybGFuZ2FuIG1hdG4gaG9zaWwgYm/igJhsYWRpLicsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcm91bmRLZXk6IGN1cnJlbnRTdGF0ZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBFQ0JcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiAnWWFrdW5peSBzaGlmcmxhbmdhbiBtYXRuJywgXG4gICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgZXhwbGFuYXRpb246IGAke21vZGV9IHJlamltaWRhIEFFUy0xMjggeW9yZGFtaWRhIG9saW5nYW4geWFrdW5peSBzaGlmcmxhbmdhbiBuYXRpamEuYFxuICB9KTtcbiAgXG4gIC8vIFByb2Nlc3MgYWxsIGJsb2NrcyBmb3IgbXVsdGktYmxvY2sgc3VwcG9ydFxuICBsZXQgcHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2s6IG51bWJlcltdIHwgdW5kZWZpbmVkO1xuICBjb25zdCBjb21iaW5lZEZpbmFsU3RhdGVzOiBudW1iZXJbXSA9IFtdO1xuICBcbiAgLy8gR2VuZXJhdGUgSVYgaWYgbmVlZGVkXG4gIGlmICgobW9kZSA9PT0gQWVzTW9kZS5DQkMgfHwgbW9kZSA9PT0gQWVzTW9kZS5DVFIpICYmICFpdikge1xuICAgIGl2ID0gZ2VuZXJhdGVJVigpO1xuICB9XG4gIFxuICBmb3IgKGxldCBibG9ja0luZGV4ID0gMDsgYmxvY2tJbmRleCA8IGJsb2Nrcy5sZW5ndGg7IGJsb2NrSW5kZXgrKykge1xuICAgIGNvbnN0IGJsb2NrUmVzdWx0ID0gZ2V0QWVzU3RlcHNGb3JCbG9jayhcbiAgICAgIGJsb2Nrc1tibG9ja0luZGV4XSxcbiAgICAgIGtleSxcbiAgICAgIG1vZGUsXG4gICAgICBibG9ja0luZGV4LFxuICAgICAgcHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2ssXG4gICAgICBpdlxuICAgICk7XG4gICAgXG4gICAgYWxsQmxvY2tzLnB1c2goe1xuICAgICAgYmxvY2tJbmRleCxcbiAgICAgIHN0ZXBzOiBibG9ja1Jlc3VsdC5zdGVwcyxcbiAgICAgIGZpbmFsU3RhdGU6IGJsb2NrUmVzdWx0LmZpbmFsU3RhdGVcbiAgICB9KTtcbiAgICBcbiAgICBjb21iaW5lZEZpbmFsU3RhdGVzLnB1c2goLi4uYmxvY2tSZXN1bHQuZmluYWxTdGF0ZSk7XG4gICAgXG4gICAgLy8gRm9yIENCQyBtb2RlLCB1c2UgY3VycmVudCBjaXBoZXJ0ZXh0IGFzIHByZXZpb3VzIGZvciBuZXh0IGJsb2NrXG4gICAgaWYgKG1vZGUgPT09IEFlc01vZGUuQ0JDKSB7XG4gICAgICBwcmV2aW91c0NpcGhlcnRleHRCbG9jayA9IGJsb2NrUmVzdWx0LmZpbmFsU3RhdGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBVc2UgY29tYmluZWQgZmluYWwgc3RhdGVzIGlmIHdlIGhhdmUgbXVsdGlwbGUgYmxvY2tzLCBvdGhlcndpc2UgdXNlIHNpbmdsZSBibG9jayByZXN1bHRcbiAgY29uc3QgZmluYWxTdGF0ZVRvVXNlID0gYmxvY2tzLmxlbmd0aCA+IDEgPyBjb21iaW5lZEZpbmFsU3RhdGVzIDogZmluYWxTdGF0ZTtcbiAgXG4gIC8vIENvbnZlcnQgdGhlIGZpbmFsIHN0YXRlIHRvIHRoZSByZXF1ZXN0ZWQgb3V0cHV0IGZvcm1hdFxuICBjb25zdCBmaW5hbFdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFxuICAgIG5ldyBVaW50OEFycmF5KGZpbmFsU3RhdGVUb1VzZSkgYXMgYW55XG4gICk7XG4gIFxuICBjb25zdCBmaW5hbENpcGhlcnRleHRCYXNlNjQgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShmaW5hbFdvcmRBcnJheSk7XG4gIGNvbnN0IGZpbmFsQ2lwaGVydGV4dEhleCA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KGZpbmFsV29yZEFycmF5KTtcbiAgY29uc3QgZmluYWxDaXBoZXJ0ZXh0QmluYXJ5ID0gYnl0ZXNUb0JpbmFyeShmaW5hbFN0YXRlVG9Vc2UsICcnKTtcbiAgXG4gIHJldHVybiB7IFxuICAgIHN0ZXBzLCBcbiAgICBmaW5hbENpcGhlcnRleHQ6IHtcbiAgICAgIGJhc2U2NDogZmluYWxDaXBoZXJ0ZXh0QmFzZTY0LFxuICAgICAgaGV4OiBmaW5hbENpcGhlcnRleHRIZXgsXG4gICAgICBiaW5hcnk6IGZpbmFsQ2lwaGVydGV4dEJpbmFyeVxuICAgIH0sIFxuICAgIGl2LFxuICAgIGFsbEJsb2NrczogYWxsQmxvY2tzLmxlbmd0aCA+IDEgPyBhbGxCbG9ja3MgOiB1bmRlZmluZWRcbiAgfTtcbn07XG5cbi8vIEdldCBrZXkgZXhwYW5zaW9uIHN0ZXBzIHdpdGggZGV0YWlsZWQgZXhwbGFuYXRpb25zXG5leHBvcnQgY29uc3QgZ2V0S2V5RXhwYW5zaW9uU3RlcHMgPSAoa2V5OiBudW1iZXJbXSk6IHsgXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsIFxuICBrZXk6IG51bWJlcltdLFxuICBleHBsYW5hdGlvbj86IHN0cmluZyxcbiAgaGlnaGxpZ2h0ZWRDZWxscz86IG51bWJlcltdXG59W10gPT4ge1xuICBjb25zdCByb3VuZEtleXMgPSBrZXlFeHBhbnNpb24oa2V5KTtcbiAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgXG4gIHN0ZXBzLnB1c2goe1xuICAgIGRlc2NyaXB0aW9uOiAnQm9zaGxhbmfigJhpY2gga2FsaXQnLFxuICAgIGtleTogcm91bmRLZXlzWzBdLFxuICAgIGV4cGxhbmF0aW9uOiAnQnUgZm95ZGFsYW51dmNoaSB0b21vbmlkYW4gYmVyaWxnYW4gYXNsIDEyOC1iaXRsaSBrYWxpdGRpci4nXG4gIH0pO1xuICBcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSAxMDsgcm91bmQrKykge1xuICAgIGNvbnN0IHByZXZLZXkgPSByb3VuZEtleXNbcm91bmQgLSAxXTtcbiAgICBjb25zdCBjdXJyZW50S2V5ID0gcm91bmRLZXlzW3JvdW5kXTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRyYW5zZm9ybWF0aW9ucyBmb3IgYSBtb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uXG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVsxMl0sIHByZXZLZXlbMTNdLCBwcmV2S2V5WzE0XSwgcHJldktleVsxNV1dO1xuICAgIGNvbnN0IHJvdFdvcmQgPSBbbGFzdFdvcmRbMV0sIGxhc3RXb3JkWzJdLCBsYXN0V29yZFszXSwgbGFzdFdvcmRbMF1dO1xuICAgIGNvbnN0IHNib3hXb3JkID0gcm90V29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICBjb25zdCByY29uVmFsdWUgPSBSQ09OW3JvdW5kXTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFdvcmQgPSBbLi4uc2JveFdvcmRdO1xuICAgIHRyYW5zZm9ybWVkV29yZFswXSBePSByY29uVmFsdWU7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBwcmV2aW91cyBrZXkgYW5kIGl0cyBYT1Igd2l0aCB0aGUgdHJhbnNmb3JtZWQgd29yZFxuICAgIGNvbnN0IGZpcnN0V29yZFByZXYgPSBbcHJldktleVswXSwgcHJldktleVsxXSwgcHJldktleVsyXSwgcHJldktleVszXV07XG4gICAgY29uc3QgeG9yUmVzdWx0ID0gZmlyc3RXb3JkUHJldi5tYXAoKGJ5dGUsIGluZGV4KSA9PiBieXRlIF4gdHJhbnNmb3JtZWRXb3JkW2luZGV4XSk7XG5cblxuICAgIC8vIFNob3cgdGhlIGtleSB3aXRoIGhpZ2hsaWdodGVkIGNlbGxzIGZvciB0aGUgbmV3IHdvcmRcbiAgICBzdGVwcy5wdXNoKHtcbiAgICAgIGRlc2NyaXB0aW9uOiBgUmF1bmQga2FsaXRpICR7cm91bmR9YCxcbiAgICAgIGtleTogY3VycmVudEtleSxcbiAgICAgIGV4cGxhbmF0aW9uOiBgXG4gICAgICAgICR7cm91bmR9LXJhdW5kIHVjaHVuIGthbGl0bmkga2VuZ2F5dGlyaXNoIGphcmF5b25pOlxuICAgICAgICAxLiBPbGRpbmdpIGthbGl0bmluZyBveGlyZ2kgd29yZCBxaXNtaW5pIG9saW5nOiBbJHtsYXN0V29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgMi4gV29yZG5pIGF5bGFudGlyaW5nOiBbJHtyb3RXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICAzLiBBeWxhbnRpcmlsZ2FuIHdvcmQgZ2EgUy1ib3ggbmkgcW/igJhsbGFuZzogWyR7c2JveFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDQuIEJpcmluY2hpIGJheXRnYSBSQ09OIChSb3VuZCBDb25zdGFudCAke3Jjb25WYWx1ZS50b1N0cmluZygxNil9KSBuaSBxb+KAmGxsYW5nOlxuICAgICAgICAgIE5hdGlqYTogWyR7dHJhbnNmb3JtZWRXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICA1LiBPbGRpbmdpIGthbGl0bmluZyBiaXJpbmNoaSB3b3JkIGk6IFske2ZpcnN0V29yZFByZXYubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dIG5pIG/igJh6Z2FydGlyaWxnYW4gd29yZCBiaWxhbiBYT1IgcWlsaW5nOiBbJHt0cmFuc2Zvcm1lZFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dLCBuYXRpamFkYTogWyR7eG9yUmVzdWx0Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XSBob3NpbCBib+KAmGxhZGkuIFNv4oCYbmdyYSBxb2xnYW4gd29yZCBsYXIgc2h1IHRhcnpkYSBob3NpbCBxaWxpbmFkaS5cbiAgICAgIGAsXG4gICAgICBoaWdobGlnaHRlZENlbGxzOiBbMCwgMSwgMiwgM10gLy8gSGlnaGxpZ2h0IHRoZSBmaXJzdCB3b3JkIHRoYXQncyBkaXJlY3RseSB0cmFuc2Zvcm1lZFxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gc3RlcHM7XG59O1xuXG4vLyBSZXR1cm4gaW50ZXJtZWRpYXRlIHN0ZXBzIGZvciBlYWNoIHdvcmQgZXhwYW5zaW9uIGZvciB2aXN1YWxpemF0aW9uXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5U2NoZWR1bGVEZXRhaWxlZFN0ZXBzKGtleTogbnVtYmVyW10sIGtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4KSB7XG4gIGNvbnN0IGtleVdvcmRzID0ga2V5Lmxlbmd0aCAvIDQ7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xMjggPyAxMCA6IGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xOTIgPyAxMiA6IDE0O1xuXG4gIC8vIEZsYXR0ZW4gYnl0ZSBhcnJheSAtPiB3b3Jkc1xuICBsZXQgcHJldktleSA9IGtleS5zbGljZSgpO1xuICBsZXQgcm91bmRLZXlzID0gW3ByZXZLZXkuc2xpY2UoKV07XG5cbiAgLy8gRm9yIHJlc3VsdCB2aXN1YWxpemF0aW9uOiBlYWNoIHN0ZXAgZm9yIGVhY2ggcm91bmRcbiAgbGV0IHN0ZXBzUGVyUm91bmQgPSBbXTtcblxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGxldCBzdGVwRGV0YWlscyA9IFtdO1xuICAgIGxldCBuZXdLZXkgPSBwcmV2S2V5LnNsaWNlKCk7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gcHJldktleS5sZW5ndGggLSA0O1xuICAgIGNvbnN0IGxhc3RXb3JkID0gW3ByZXZLZXlbbGFzdEluZGV4XSwgcHJldktleVtsYXN0SW5kZXggKyAxXSwgcHJldktleVtsYXN0SW5kZXggKyAyXSwgcHJldktleVtsYXN0SW5kZXggKyAzXV07XG5cbiAgICAvLyBTdGVwIDE6IFJvdFdvcmRcbiAgICBjb25zdCByb3RXb3JkID0gW2xhc3RXb3JkWzFdLCBsYXN0V29yZFsyXSwgbGFzdFdvcmRbM10sIGxhc3RXb3JkWzBdXTtcbiAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgIHN0ZXA6ICdSb3RXb3JkJywgaW5wdXQ6IGxhc3RXb3JkLnNsaWNlKCksIG91dHB1dDogcm90V29yZC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU3RlcCAyOiBTdWJCeXRlcyAoUy1ib3gpXG4gICAgY29uc3Qgc2JveFdvcmQgPSByb3RXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1N1YkJ5dGVzJywgaW5wdXQ6IHJvdFdvcmQuc2xpY2UoKSwgb3V0cHV0OiBzYm94V29yZC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU3RlcCAzOiBSY29uIHRvIGZpcnN0IGJ5dGVcbiAgICBjb25zdCByY29uVmFsdWUgPSBSQ09OW3JvdW5kXTtcbiAgICBjb25zdCByY29uV29yZCA9IHNib3hXb3JkLnNsaWNlKCk7XG4gICAgcmNvbldvcmRbMF0gXj0gcmNvblZhbHVlO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ0FwcGx5IFJjb24nLCBpbnB1dDogc2JveFdvcmQuc2xpY2UoKSwgcmNvbjogcmNvblZhbHVlLCBvdXRwdXQ6IHJjb25Xb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDQ6IFhPUiB3aXRoIHByZXZpb3VzIChmaXJzdCB3b3JkKVxuICAgIGNvbnN0IHhvclJlc3VsdCA9IFtcbiAgICAgIHByZXZLZXlbMF0gXiByY29uV29yZFswXSxcbiAgICAgIHByZXZLZXlbMV0gXiByY29uV29yZFsxXSxcbiAgICAgIHByZXZLZXlbMl0gXiByY29uV29yZFsyXSxcbiAgICAgIHByZXZLZXlbM10gXiByY29uV29yZFszXSxcbiAgICBdO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1hPUiB3aXRoIHByZXZpb3VzJywgaW5wdXRzOiBbcHJldktleS5zbGljZSgwLDQpLCByY29uV29yZC5zbGljZSgpXSwgb3V0cHV0OiB4b3JSZXN1bHQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFNhdmUgYW5kIHVwZGF0ZSBuZXdLZXlcbiAgICBuZXdLZXlbMF0gPSB4b3JSZXN1bHRbMF07XG4gICAgbmV3S2V5WzFdID0geG9yUmVzdWx0WzFdO1xuICAgIG5ld0tleVsyXSA9IHhvclJlc3VsdFsyXTtcbiAgICBuZXdLZXlbM10gPSB4b3JSZXN1bHRbM107XG4gICAgLy8gT3RoZXIgd29yZHMgKG9ubHkgc2ltcGxlIHhvcilcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleVdvcmRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuICAgICAgbmV3S2V5W29mZnNldF0gPSBuZXdLZXlbb2Zmc2V0IC0gNF0gXiBwcmV2S2V5W29mZnNldF07XG4gICAgICBuZXdLZXlbb2Zmc2V0ICsgMV0gPSBuZXdLZXlbb2Zmc2V0IC0gM10gXiBwcmV2S2V5W29mZnNldCArIDFdO1xuICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gbmV3S2V5W29mZnNldCAtIDJdIF4gcHJldktleVtvZmZzZXQgKyAyXTtcbiAgICAgIG5ld0tleVtvZmZzZXQgKyAzXSA9IG5ld0tleVtvZmZzZXQgLSAxXSBeIHByZXZLZXlbb2Zmc2V0ICsgM107XG4gICAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgICAgc3RlcDogJ1hPUiBjaGFpbicsIGlucHV0czogW1xuICAgICAgICAgIG5ld0tleS5zbGljZShvZmZzZXQgLSA0LCBvZmZzZXQpLFxuICAgICAgICAgIHByZXZLZXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0KVxuICAgICAgICBdLCBvdXRwdXQ6IG5ld0tleS5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLCB3b3JkSW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGVwc1BlclJvdW5kLnB1c2goeyByb3VuZCwgc3RlcERldGFpbHMsIHJvdW5kS2V5OiBuZXdLZXkuc2xpY2UoKSB9KTtcbiAgICBwcmV2S2V5ID0gbmV3S2V5LnNsaWNlKCk7XG4gICAgcm91bmRLZXlzLnB1c2gocHJldktleSk7XG4gIH1cbiAgcmV0dXJuIHN0ZXBzUGVyUm91bmQ7XG59XG5cbi8vIFJlYWwgQUVTIGVuY3J5cHRpb24gdXNpbmcgQ3J5cHRvSlMgZm9yIHZlcmlmaWNhdGlvblxuZXhwb3J0IGNvbnN0IHJlYWxBZXNFbmNyeXB0ID0gKFxuICBwbGFpbnRleHQ6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgb3V0cHV0Rm9ybWF0OiBPdXRwdXRGb3JtYXQgPSBPdXRwdXRGb3JtYXQuQkFTRTY0LFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4LFxuICBpdlN0cmluZz86IHN0cmluZ1xuKTogeyBjaXBoZXJ0ZXh0OiBzdHJpbmcsIGl2Pzogc3RyaW5nLCBmb3JtYXRzOiB7IGJhc2U2NDogc3RyaW5nLCBoZXg6IHN0cmluZywgYmluYXJ5OiBzdHJpbmcgfSB9ID0+IHtcbiAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUga2V5IGlzIHNob3J0ZXIgdGhhbiByZXF1aXJlZCBieSBrZXlMZW5ndGhcbiAgY29uc3QgY2xlYW5LZXkgPSBrZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgbGV0IGtleUhleCA9IGNsZWFuS2V5Lmxlbmd0aCAlIDIgPT09IDEgPyBjbGVhbktleSArICcwJyA6IGNsZWFuS2V5O1xuICBcbiAgLy8gRW5zdXJlIGtleSBpcyBvZiBjb3JyZWN0IGxlbmd0aCBmb3IgdGhlIHNlbGVjdGVkIGtleSBsZW5ndGhcbiAgY29uc3QgcmVxdWlyZWRIZXhDaGFycyA9IGtleUxlbmd0aCAvIDQ7IC8vIEVhY2ggaGV4IGNoYXIgaXMgNCBiaXRzXG4gIGlmIChrZXlIZXgubGVuZ3RoIDwgcmVxdWlyZWRIZXhDaGFycykge1xuICAgIC8vIFBhZCBrZXkgaWYgdG9vIHNob3J0XG4gICAga2V5SGV4ID0ga2V5SGV4LnBhZEVuZChyZXF1aXJlZEhleENoYXJzLCAnMCcpO1xuICB9IGVsc2UgaWYgKGtleUhleC5sZW5ndGggPiByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgLy8gVHJ1bmNhdGUga2V5IGlmIHRvbyBsb25nXG4gICAga2V5SGV4ID0ga2V5SGV4LnN1YnN0cmluZygwLCByZXF1aXJlZEhleENoYXJzKTtcbiAgfVxuICBcbiAgY29uc3Qga2V5V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShrZXlIZXgpO1xuICBcbiAgbGV0IHBhZGRpbmdPcHRpb246IGFueTtcbiAgc3dpdGNoIChwYWRkaW5nKSB7XG4gICAgY2FzZSBQYWRkaW5nVHlwZS5BTlNJX1g5MjM6XG4gICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuQW5zaVg5MjMgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUGFkZGluZ1R5cGUuTk9ORTpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYWRkaW5nT3B0aW9uID0ge307IC8vIGRlZmF1bHQgaXMgUEtDUzdcbiAgfVxuICBcbiAgbGV0IG1vZGVPcHRpb246IGFueTtcbiAgbGV0IGl2OiBhbnk7XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKGl2U3RyaW5nKSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuICAgICAgfVxuICAgICAgbW9kZU9wdGlvbiA9IHsgXG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgICBpdjogaXYsXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgaWYgKGl2U3RyaW5nKSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuICAgICAgfVxuICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DVFIsXG4gICAgICAgIGl2OiBpdixcbiAgICAgICAgY291bnRlcjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzAsIDAsIDAsIDBdLCAxNiksXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBFQ0JcbiAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuRUNCLFxuICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGNvbnN0IGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KHBsYWludGV4dCwga2V5V29yZEFycmF5LCBtb2RlT3B0aW9uKTtcbiAgXG4gIC8vIEdldCBhbGwgb3V0cHV0IGZvcm1hdHNcbiAgY29uc3QgYmFzZTY0T3V0cHV0ID0gZW5jcnlwdGVkLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICBjaXBoZXJ0ZXh0OiBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NE91dHB1dClcbiAgfSk7XG4gIGNvbnN0IGhleE91dHB1dCA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG4gIFxuICAvLyBGb3IgYmluYXJ5LCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGhleCB0byBiaW5hcnlcbiAgY29uc3QgaGV4Qnl0ZXMgPSBoZXhPdXRwdXQubWF0Y2goLy57Mn0vZykhLm1hcChoZXggPT4gcGFyc2VJbnQoaGV4LCAxNikpO1xuICBjb25zdCBiaW5hcnlPdXRwdXQgPSBieXRlc1RvQmluYXJ5KGhleEJ5dGVzLCAnJyk7XG4gIFxuICAvLyBTZWxlY3QgdGhlIHJlcXVlc3RlZCBmb3JtYXQgZm9yIHByaW1hcnkgb3V0cHV0XG4gIGxldCBwcmltYXJ5T3V0cHV0OiBzdHJpbmc7XG4gIHN3aXRjaCAob3V0cHV0Rm9ybWF0KSB7XG4gICAgY2FzZSBPdXRwdXRGb3JtYXQuSEVYOlxuICAgICAgcHJpbWFyeU91dHB1dCA9IGhleE91dHB1dDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkJJTkFSWTpcbiAgICAgIHByaW1hcnlPdXRwdXQgPSBiaW5hcnlPdXRwdXQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBCQVNFNjRcbiAgICAgIHByaW1hcnlPdXRwdXQgPSBiYXNlNjRPdXRwdXQ7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgcmV0dXJuIHsgXG4gICAgY2lwaGVydGV4dDogcHJpbWFyeU91dHB1dCxcbiAgICBpdjogaXYgPyBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeShpdikgOiB1bmRlZmluZWQsXG4gICAgZm9ybWF0czoge1xuICAgICAgYmFzZTY0OiBiYXNlNjRPdXRwdXQsXG4gICAgICBoZXg6IGhleE91dHB1dCxcbiAgICAgIGJpbmFyeTogYmluYXJ5T3V0cHV0XG4gICAgfVxuICB9O1xufTtcblxuLy8gUmVhbCBBRVMgZGVjcnlwdGlvbiB1c2luZyBDcnlwdG9KU1xuZXhwb3J0IGNvbnN0IHJlYWxBZXNEZWNyeXB0ID0gKFxuICBjaXBoZXJ0ZXh0OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcsXG4gIGlucHV0Rm9ybWF0OiBPdXRwdXRGb3JtYXQgPSBPdXRwdXRGb3JtYXQuQkFTRTY0LFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4LFxuICBpdlN0cmluZz86IHN0cmluZ1xuKTogeyBwbGFpbnRleHQ6IHN0cmluZywgZXJyb3I/OiBzdHJpbmcgfSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUga2V5IGlzIHNob3J0ZXIgdGhhbiByZXF1aXJlZCBieSBrZXlMZW5ndGhcbiAgICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGxldCBrZXlIZXggPSBjbGVhbktleS5sZW5ndGggJSAyID09PSAxID8gY2xlYW5LZXkgKyAnMCcgOiBjbGVhbktleTtcbiAgICBcbiAgICAvLyBFbnN1cmUga2V5IGlzIG9mIGNvcnJlY3QgbGVuZ3RoIGZvciB0aGUgc2VsZWN0ZWQga2V5IGxlbmd0aFxuICAgIGNvbnN0IHJlcXVpcmVkSGV4Q2hhcnMgPSBrZXlMZW5ndGggLyA0OyAvLyBFYWNoIGhleCBjaGFyIGlzIDQgYml0c1xuICAgIGlmIChrZXlIZXgubGVuZ3RoIDwgcmVxdWlyZWRIZXhDaGFycykge1xuICAgICAgLy8gUGFkIGtleSBpZiB0b28gc2hvcnRcbiAgICAgIGtleUhleCA9IGtleUhleC5wYWRFbmQocmVxdWlyZWRIZXhDaGFycywgJzAnKTtcbiAgICB9IGVsc2UgaWYgKGtleUhleC5sZW5ndGggPiByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgICAvLyBUcnVuY2F0ZSBrZXkgaWYgdG9vIGxvbmdcbiAgICAgIGtleUhleCA9IGtleUhleC5zdWJzdHJpbmcoMCwgcmVxdWlyZWRIZXhDaGFycyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGtleVdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2Uoa2V5SGV4KTtcbiAgICBcbiAgICAvLyBQYXJzZSBjaXBoZXJ0ZXh0IGJhc2VkIG9uIGlucHV0IGZvcm1hdFxuICAgIGxldCBjaXBoZXJ0ZXh0V29yZEFycmF5OiBhbnk7XG4gICAgc3dpdGNoIChpbnB1dEZvcm1hdCkge1xuICAgICAgY2FzZSBPdXRwdXRGb3JtYXQuSEVYOlxuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShjaXBoZXJ0ZXh0LnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkJJTkFSWTpcbiAgICAgICAgLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nIHRvIGhleCBmaXJzdFxuICAgICAgICBjb25zdCBoZXhGcm9tQmluYXJ5ID0gY2lwaGVydGV4dC5yZXBsYWNlKC9cXHMvZywgJycpLm1hdGNoKC8uezh9L2cpPy5tYXAoYmluID0+IHBhcnNlSW50KGJpbiwgMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpIHx8ICcnO1xuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhGcm9tQmluYXJ5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBCQVNFNjRcbiAgICAgICAgY2lwaGVydGV4dFdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoY2lwaGVydGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcGFkZGluZ09wdGlvbjogYW55O1xuICAgIHN3aXRjaCAocGFkZGluZykge1xuICAgICAgY2FzZSBQYWRkaW5nVHlwZS5BTlNJX1g5MjM6XG4gICAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5BbnNpWDkyMyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFkZGluZ1R5cGUuTk9ORTpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBhZGRpbmdPcHRpb24gPSB7fTsgLy8gZGVmYXVsdCBpcyBQS0NTN1xuICAgIH1cbiAgICBcbiAgICBsZXQgbW9kZU9wdGlvbjogYW55O1xuICAgIGxldCBpdjogYW55O1xuICAgIFxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgICAgaWYgKCFpdlN0cmluZykge1xuICAgICAgICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiAnQ0JDIHJlamltaSB1Y2h1biBJViBrZXJhaycgfTtcbiAgICAgICAgfVxuICAgICAgICBpdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaXZTdHJpbmcucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIG1vZGVPcHRpb24gPSB7IFxuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgICAgaWYgKCFpdlN0cmluZykge1xuICAgICAgICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiAnQ1RSIHJlamltaSB1Y2h1biBJViAoTm9uY2UpIGtlcmFrJyB9O1xuICAgICAgICB9XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNUUixcbiAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgY291bnRlcjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzAsIDAsIDAsIDBdLCAxNiksXG4gICAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuRUNCLFxuICAgICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRlY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KFxuICAgICAgeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5IH0gYXMgYW55LFxuICAgICAga2V5V29yZEFycmF5LFxuICAgICAgbW9kZU9wdGlvblxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcGxhaW50ZXh0ID0gZGVjcnlwdGVkLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICBcbiAgICBpZiAoIXBsYWludGV4dCkge1xuICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdEZXNoaWZybGFzaCBtdXZhZmZhcWl5YXRzaXouIEthbGl0IHlva2kgc2hpZnJsYW5nYW4gbWF0biBub3RvXFwnZ1xcJ3JpLicgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgcGxhaW50ZXh0IH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRGVzaGlmcmxhc2hkYSB4YXRvbGlrIHl1eiBiZXJkaScgfTtcbiAgfVxufTtcblxuLy8gVGVzdCBzcGVjaWZpYyBjYXNlIGZvciBcIlNhbG9tLCBBRVMhXCIgd2l0aCBrZXkgXCJjYyAwZSBjMSA3MCAyNCAyNCAwMSA4ZCA0ZSBmZCA1ZSBmMyA4ZCAxNSAyZiA2M1wiXG5leHBvcnQgY29uc3QgdGVzdFNwZWNpZmljQ2FzZSA9ICgpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBwbGFpbnRleHQgPSBcIlNhbG9tLCBBRVMhXCI7XG4gIGNvbnN0IGtleSA9IFwiY2MgMGUgYzEgNzAgMjQgMjQgMDEgOGQgNGUgZmQgNWUgZjMgOGQgMTUgMmYgNjNcIjtcbiAgXG4gIC8vIENyZWF0ZSBrZXkgYW5kIGlucHV0IGFzIGJ5dGUgYXJyYXlzXG4gIGNvbnN0IGtleUJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAga2V5Qnl0ZXMucHVzaChwYXJzZUludChrZXkuc3Vic3RyKGksIDIpLCAxNikpO1xuICB9XG4gIFxuICAvLyBVc2Ugb3VyIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IHsgZmluYWxDaXBoZXJ0ZXh0IH0gPSBnZXRBZXNTdGVwcyhwbGFpbnRleHQsIGtleUJ5dGVzLCBBZXNNb2RlLkVDQiwgUGFkZGluZ1R5cGUuUEtDUzcpO1xuICBcbiAgLy8gVXNlIENyeXB0b0pTIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IGNyeXB0b1Jlc3VsdCA9IHJlYWxBZXNFbmNyeXB0KHBsYWludGV4dCwga2V5LCBBZXNNb2RlLkVDQiwgUGFkZGluZ1R5cGUuUEtDUzcsIE91dHB1dEZvcm1hdC5IRVgpO1xuICBcbiAgcmV0dXJuIGBcbiAgICBCaXpuaW5nIGltcGxlbWVudGF0c2l5YW1peiAoSEVYKTogJHtmaW5hbENpcGhlcnRleHQuaGV4fVxuICAgIENyeXB0b0pTIGltcGxlbWVudGF0c2l5YXNpIChIRVgpOiAke2NyeXB0b1Jlc3VsdC5mb3JtYXRzLmhleH1cbiAgICBLdXRpbGF5b3RnYW4gbmF0aWphOiAzMDQ4NEI4RjhDNkJCMDlDQTNGOTRDNkY4NEYwMzA1RVxuICBgO1xufTtcbiJdLCJuYW1lcyI6WyJDcnlwdG9KUyIsIkFlc01vZGUiLCJQYWRkaW5nVHlwZSIsIk91dHB1dEZvcm1hdCIsIktleUxlbmd0aCIsImdldE51bVJvdW5kcyIsImtleUxlbmd0aCIsImdldEtleUJ5dGVMZW5ndGgiLCJTQk9YIiwiUkNPTiIsIkdBTE9JU19NVUxfMiIsIkdBTE9JU19NVUxfMyIsInRleHRUb1N0YXRlIiwidGV4dCIsIndvcmRBcnJheSIsImVuYyIsIlV0ZjgiLCJwYXJzZSIsImJ5dGVzIiwic2lnQnl0ZXMiLCJpIiwid29yZHMiLCJsZW5ndGgiLCJ3b3JkIiwiYnl0ZXNJblRoaXNXb3JkIiwiTWF0aCIsIm1pbiIsInB1c2giLCJibG9jayIsInNsaWNlIiwia2V5VG9CeXRlcyIsImtleSIsImNsZWFuS2V5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidGVzdCIsInBhcnNlSW50Iiwic3Vic3RyIiwiZ2VuZXJhdGVSYW5kb21LZXkiLCJrZXlCeXRlcyIsImZsb29yIiwicmFuZG9tIiwiYnl0ZXNUb0hleCIsImpvaW5DaGFyIiwibWFwIiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiYnl0ZXNUb0JpbmFyeSIsInN1YkJ5dGVzIiwic3RhdGUiLCJzaGlmdFJvd3MiLCJyZXN1bHQiLCJpZHgiLCJyb3ciLCJjb2wiLCJyb3dWYWx1ZXMiLCJzaGlmdGVkIiwiY29uY2F0IiwibWl4Q29sdW1ucyIsInMwIiwiczEiLCJzMiIsInMzIiwiYWRkUm91bmRLZXkiLCJyb3VuZEtleSIsImtleUV4cGFuc2lvbiIsImtleVdvcmRzIiwibnVtUm91bmRzIiwicm91bmRLZXlzIiwicm91bmQiLCJwcmV2S2V5IiwibmV3S2V5IiwibGFzdEluZGV4IiwibGFzdFdvcmQiLCJyb3RXb3JkIiwic3ViV29yZCIsIm9mZnNldCIsInRlbXBXb3JkIiwic3ViVGVtcFdvcmQiLCJhZXNSb3VuZCIsImlzTGFzdFJvdW5kIiwibmV3U3RhdGUiLCJhZXNFbmNyeXB0IiwicGxhaW50ZXh0IiwiY3VycmVudFN0YXRlIiwidGV4dFRvQmxvY2tzIiwicGFkZGluZyIsInBhZGRlZEJ5dGVzIiwiYXBwbHlQS0NTN1BhZGRpbmciLCJhcHBseUFuc2lYOTIzUGFkZGluZyIsImJsb2NrcyIsImRhdGEiLCJwYWRkZWQiLCJwYWRkaW5nTGVuZ3RoIiwicmVtb3ZlQW5zaVg5MjNQYWRkaW5nIiwiZ2VuZXJhdGVJViIsIml2IiwiZ2V0QWVzU3RlcHNGb3JCbG9jayIsIm1vZGUiLCJibG9ja0luZGV4IiwicHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2siLCJzdGVwcyIsInBsYWludGV4dEJ5dGVzIiwiZGVzY3JpcHRpb24iLCJleHBsYW5hdGlvbiIsImluaXRpYWxTdGF0ZSIsImFjdGl2ZUluZGljZXMiLCJBcnJheSIsImZyb20iLCJrZXlzIiwicHJldmlvdXNTdGF0ZSIsImZpbmFsU3RhdGUiLCJjb3VudGVyQmxvY2siLCJjb3VudGVyVmFsdWUiLCJzdW0iLCJhZnRlckluaXRpYWxSb3VuZCIsImFmdGVyU3ViQnl0ZXMiLCJhZnRlclNoaWZ0Um93cyIsInByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSIsImFmdGVyTWl4Q29sdW1ucyIsImdldEFlc1N0ZXBzIiwicHJvdmlkZWRJdiIsInVuZGVmaW5lZCIsImFsbEJsb2NrcyIsIml2RGVzY3JpcHRpb24iLCJpdkV4cGxhbmF0aW9uIiwiY291bnRlciIsImNvbWJpbmVkRmluYWxTdGF0ZXMiLCJibG9ja1Jlc3VsdCIsImZpbmFsU3RhdGVUb1VzZSIsImZpbmFsV29yZEFycmF5IiwibGliIiwiV29yZEFycmF5IiwiY3JlYXRlIiwiVWludDhBcnJheSIsImZpbmFsQ2lwaGVydGV4dEJhc2U2NCIsIkJhc2U2NCIsInN0cmluZ2lmeSIsImZpbmFsQ2lwaGVydGV4dEhleCIsIkhleCIsImZpbmFsQ2lwaGVydGV4dEJpbmFyeSIsImZpbmFsQ2lwaGVydGV4dCIsImJhc2U2NCIsImhleCIsImJpbmFyeSIsImdldEtleUV4cGFuc2lvblN0ZXBzIiwiY3VycmVudEtleSIsInNib3hXb3JkIiwicmNvblZhbHVlIiwidHJhbnNmb3JtZWRXb3JkIiwiZmlyc3RXb3JkUHJldiIsInhvclJlc3VsdCIsImluZGV4IiwiYiIsImhpZ2hsaWdodGVkQ2VsbHMiLCJnZXRLZXlTY2hlZHVsZURldGFpbGVkU3RlcHMiLCJzdGVwc1BlclJvdW5kIiwic3RlcERldGFpbHMiLCJzdGVwIiwiaW5wdXQiLCJvdXRwdXQiLCJyY29uV29yZCIsInJjb24iLCJpbnB1dHMiLCJ3b3JkSW5kZXgiLCJyZWFsQWVzRW5jcnlwdCIsIm91dHB1dEZvcm1hdCIsIml2U3RyaW5nIiwia2V5SGV4IiwicmVxdWlyZWRIZXhDaGFycyIsInBhZEVuZCIsInN1YnN0cmluZyIsImtleVdvcmRBcnJheSIsInBhZGRpbmdPcHRpb24iLCJwYWQiLCJBbnNpWDkyMyIsIk5vUGFkZGluZyIsIm1vZGVPcHRpb24iLCJDQkMiLCJDVFIiLCJFQ0IiLCJlbmNyeXB0ZWQiLCJBRVMiLCJlbmNyeXB0IiwiYmFzZTY0T3V0cHV0IiwiY2lwaGVyUGFyYW1zIiwiQ2lwaGVyUGFyYW1zIiwiY2lwaGVydGV4dCIsImhleE91dHB1dCIsImZvcm1hdCIsImhleEJ5dGVzIiwibWF0Y2giLCJiaW5hcnlPdXRwdXQiLCJwcmltYXJ5T3V0cHV0IiwiZm9ybWF0cyIsInJlYWxBZXNEZWNyeXB0IiwiaW5wdXRGb3JtYXQiLCJjaXBoZXJ0ZXh0V29yZEFycmF5IiwiaGV4RnJvbUJpbmFyeSIsImJpbiIsImVycm9yIiwiZGVjcnlwdGVkIiwiZGVjcnlwdCIsIm1lc3NhZ2UiLCJ0ZXN0U3BlY2lmaWNDYXNlIiwiY3J5cHRvUmVzdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/aes.ts\n"));

/***/ })

});