"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/aes.ts":
/*!**************************!*\
  !*** ./src/utils/aes.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AesMode: () => (/* binding */ AesMode),\n/* harmony export */   GALOIS_MUL_2: () => (/* binding */ GALOIS_MUL_2),\n/* harmony export */   GALOIS_MUL_3: () => (/* binding */ GALOIS_MUL_3),\n/* harmony export */   KeyLength: () => (/* binding */ KeyLength),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   PaddingType: () => (/* binding */ PaddingType),\n/* harmony export */   RCON: () => (/* binding */ RCON),\n/* harmony export */   SBOX: () => (/* binding */ SBOX),\n/* harmony export */   addRoundKey: () => (/* binding */ addRoundKey),\n/* harmony export */   aesEncrypt: () => (/* binding */ aesEncrypt),\n/* harmony export */   aesRound: () => (/* binding */ aesRound),\n/* harmony export */   applyAnsiX923Padding: () => (/* binding */ applyAnsiX923Padding),\n/* harmony export */   applyPKCS7Padding: () => (/* binding */ applyPKCS7Padding),\n/* harmony export */   bytesToBinary: () => (/* binding */ bytesToBinary),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   generateIV: () => (/* binding */ generateIV),\n/* harmony export */   generateRandomKey: () => (/* binding */ generateRandomKey),\n/* harmony export */   getAesSteps: () => (/* binding */ getAesSteps),\n/* harmony export */   getAesStepsForBlock: () => (/* binding */ getAesStepsForBlock),\n/* harmony export */   getKeyExpansionSteps: () => (/* binding */ getKeyExpansionSteps),\n/* harmony export */   getKeyScheduleDetailedSteps: () => (/* binding */ getKeyScheduleDetailedSteps),\n/* harmony export */   keyExpansion: () => (/* binding */ keyExpansion),\n/* harmony export */   keyToBytes: () => (/* binding */ keyToBytes),\n/* harmony export */   mixColumns: () => (/* binding */ mixColumns),\n/* harmony export */   realAesDecrypt: () => (/* binding */ realAesDecrypt),\n/* harmony export */   realAesEncrypt: () => (/* binding */ realAesEncrypt),\n/* harmony export */   removeAnsiX923Padding: () => (/* binding */ removeAnsiX923Padding),\n/* harmony export */   shiftRows: () => (/* binding */ shiftRows),\n/* harmony export */   subBytes: () => (/* binding */ subBytes),\n/* harmony export */   testSpecificCase: () => (/* binding */ testSpecificCase),\n/* harmony export */   textToBlocks: () => (/* binding */ textToBlocks),\n/* harmony export */   textToState: () => (/* binding */ textToState)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(pages-dir-browser)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// AES mode enum\nvar AesMode = /*#__PURE__*/ function(AesMode) {\n    AesMode[\"ECB\"] = \"ECB\";\n    AesMode[\"CBC\"] = \"CBC\";\n    AesMode[\"CTR\"] = \"CTR\";\n    return AesMode;\n}({});\n// Padding enum\nvar PaddingType = /*#__PURE__*/ function(PaddingType) {\n    PaddingType[\"PKCS7\"] = \"PKCS7\";\n    PaddingType[\"ANSI_X923\"] = \"ANSI X.923\";\n    PaddingType[\"NONE\"] = \"None\";\n    return PaddingType;\n}({});\n// Output format enum\nvar OutputFormat = /*#__PURE__*/ function(OutputFormat) {\n    OutputFormat[\"BASE64\"] = \"Base64\";\n    OutputFormat[\"HEX\"] = \"Hex\";\n    OutputFormat[\"BINARY\"] = \"Binary\";\n    return OutputFormat;\n}({});\n// Key length enum\nvar KeyLength = /*#__PURE__*/ function(KeyLength) {\n    KeyLength[KeyLength[\"AES_128\"] = 128] = \"AES_128\";\n    KeyLength[KeyLength[\"AES_192\"] = 192] = \"AES_192\";\n    KeyLength[KeyLength[\"AES_256\"] = 256] = \"AES_256\";\n    return KeyLength;\n}({});\nconst getNumRounds = (keyLength)=>keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\nconst getKeyByteLength = (keyLength)=>keyLength / 8;\n// AES S-Box (Standard Rijndael S-box)\nconst SBOX = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\n// AES Rcon (Round Constants)\nconst RCON = [\n    0x00,\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a\n];\n// Used in MixColumns\nconst GALOIS_MUL_2 = [\n    0x00,\n    0x02,\n    0x04,\n    0x06,\n    0x08,\n    0x0a,\n    0x0c,\n    0x0e,\n    0x10,\n    0x12,\n    0x14,\n    0x16,\n    0x18,\n    0x1a,\n    0x1c,\n    0x1e,\n    0x20,\n    0x22,\n    0x24,\n    0x26,\n    0x28,\n    0x2a,\n    0x2c,\n    0x2e,\n    0x30,\n    0x32,\n    0x34,\n    0x36,\n    0x38,\n    0x3a,\n    0x3c,\n    0x3e,\n    0x40,\n    0x42,\n    0x44,\n    0x46,\n    0x48,\n    0x4a,\n    0x4c,\n    0x4e,\n    0x50,\n    0x52,\n    0x54,\n    0x56,\n    0x58,\n    0x5a,\n    0x5c,\n    0x5e,\n    0x60,\n    0x62,\n    0x64,\n    0x66,\n    0x68,\n    0x6a,\n    0x6c,\n    0x6e,\n    0x70,\n    0x72,\n    0x74,\n    0x76,\n    0x78,\n    0x7a,\n    0x7c,\n    0x7e,\n    0x80,\n    0x82,\n    0x84,\n    0x86,\n    0x88,\n    0x8a,\n    0x8c,\n    0x8e,\n    0x90,\n    0x92,\n    0x94,\n    0x96,\n    0x98,\n    0x9a,\n    0x9c,\n    0x9e,\n    0xa0,\n    0xa2,\n    0xa4,\n    0xa6,\n    0xa8,\n    0xaa,\n    0xac,\n    0xae,\n    0xb0,\n    0xb2,\n    0xb4,\n    0xb6,\n    0xb8,\n    0xba,\n    0xbc,\n    0xbe,\n    0xc0,\n    0xc2,\n    0xc4,\n    0xc6,\n    0xc8,\n    0xca,\n    0xcc,\n    0xce,\n    0xd0,\n    0xd2,\n    0xd4,\n    0xd6,\n    0xd8,\n    0xda,\n    0xdc,\n    0xde,\n    0xe0,\n    0xe2,\n    0xe4,\n    0xe6,\n    0xe8,\n    0xea,\n    0xec,\n    0xee,\n    0xf0,\n    0xf2,\n    0xf4,\n    0xf6,\n    0xf8,\n    0xfa,\n    0xfc,\n    0xfe,\n    0x1b,\n    0x19,\n    0x1f,\n    0x1d,\n    0x13,\n    0x11,\n    0x17,\n    0x15,\n    0x0b,\n    0x09,\n    0x0f,\n    0x0d,\n    0x03,\n    0x01,\n    0x07,\n    0x05,\n    0x3b,\n    0x39,\n    0x3f,\n    0x3d,\n    0x33,\n    0x31,\n    0x37,\n    0x35,\n    0x2b,\n    0x29,\n    0x2f,\n    0x2d,\n    0x23,\n    0x21,\n    0x27,\n    0x25,\n    0x5b,\n    0x59,\n    0x5f,\n    0x5d,\n    0x53,\n    0x51,\n    0x57,\n    0x55,\n    0x4b,\n    0x49,\n    0x4f,\n    0x4d,\n    0x43,\n    0x41,\n    0x47,\n    0x45,\n    0x7b,\n    0x79,\n    0x7f,\n    0x7d,\n    0x73,\n    0x71,\n    0x77,\n    0x75,\n    0x6b,\n    0x69,\n    0x6f,\n    0x6d,\n    0x63,\n    0x61,\n    0x67,\n    0x65,\n    0x9b,\n    0x99,\n    0x9f,\n    0x9d,\n    0x93,\n    0x91,\n    0x97,\n    0x95,\n    0x8b,\n    0x89,\n    0x8f,\n    0x8d,\n    0x83,\n    0x81,\n    0x87,\n    0x85,\n    0xbb,\n    0xb9,\n    0xbf,\n    0xbd,\n    0xb3,\n    0xb1,\n    0xb7,\n    0xb5,\n    0xab,\n    0xa9,\n    0xaf,\n    0xad,\n    0xa3,\n    0xa1,\n    0xa7,\n    0xa5,\n    0xdb,\n    0xd9,\n    0xdf,\n    0xdd,\n    0xd3,\n    0xd1,\n    0xd7,\n    0xd5,\n    0xcb,\n    0xc9,\n    0xcf,\n    0xcd,\n    0xc3,\n    0xc1,\n    0xc7,\n    0xc5,\n    0xfb,\n    0xf9,\n    0xff,\n    0xfd,\n    0xf3,\n    0xf1,\n    0xf7,\n    0xf5,\n    0xeb,\n    0xe9,\n    0xef,\n    0xed,\n    0xe3,\n    0xe1,\n    0xe7,\n    0xe5\n];\nconst GALOIS_MUL_3 = [\n    0x00,\n    0x03,\n    0x06,\n    0x05,\n    0x0c,\n    0x0f,\n    0x0a,\n    0x09,\n    0x18,\n    0x1b,\n    0x1e,\n    0x1d,\n    0x14,\n    0x17,\n    0x12,\n    0x11,\n    0x30,\n    0x33,\n    0x36,\n    0x35,\n    0x3c,\n    0x3f,\n    0x3a,\n    0x39,\n    0x28,\n    0x2b,\n    0x2e,\n    0x2d,\n    0x24,\n    0x27,\n    0x22,\n    0x21,\n    0x60,\n    0x63,\n    0x66,\n    0x65,\n    0x6c,\n    0x6f,\n    0x6a,\n    0x69,\n    0x78,\n    0x7b,\n    0x7e,\n    0x7d,\n    0x74,\n    0x77,\n    0x72,\n    0x71,\n    0x50,\n    0x53,\n    0x56,\n    0x55,\n    0x5c,\n    0x5f,\n    0x5a,\n    0x59,\n    0x48,\n    0x4b,\n    0x4e,\n    0x4d,\n    0x44,\n    0x47,\n    0x42,\n    0x41,\n    0xc0,\n    0xc3,\n    0xc6,\n    0xc5,\n    0xcc,\n    0xcf,\n    0xca,\n    0xc9,\n    0xd8,\n    0xdb,\n    0xde,\n    0xdd,\n    0xd4,\n    0xd7,\n    0xd2,\n    0xd1,\n    0xf0,\n    0xf3,\n    0xf6,\n    0xf5,\n    0xfc,\n    0xff,\n    0xfa,\n    0xf9,\n    0xe8,\n    0xeb,\n    0xee,\n    0xed,\n    0xe4,\n    0xe7,\n    0xe2,\n    0xe1,\n    0xa0,\n    0xa3,\n    0xa6,\n    0xa5,\n    0xac,\n    0xaf,\n    0xaa,\n    0xa9,\n    0xb8,\n    0xbb,\n    0xbe,\n    0xbd,\n    0xb4,\n    0xb7,\n    0xb2,\n    0xb1,\n    0x90,\n    0x93,\n    0x96,\n    0x95,\n    0x9c,\n    0x9f,\n    0x9a,\n    0x99,\n    0x88,\n    0x8b,\n    0x8e,\n    0x8d,\n    0x84,\n    0x87,\n    0x82,\n    0x81,\n    0x9b,\n    0x98,\n    0x9d,\n    0x9e,\n    0x97,\n    0x94,\n    0x91,\n    0x92,\n    0x83,\n    0x80,\n    0x85,\n    0x86,\n    0x8f,\n    0x8c,\n    0x89,\n    0x8a,\n    0xab,\n    0xa8,\n    0xad,\n    0xae,\n    0xa7,\n    0xa4,\n    0xa1,\n    0xa2,\n    0xb3,\n    0xb0,\n    0xb5,\n    0xb6,\n    0xbf,\n    0xbc,\n    0xb9,\n    0xba,\n    0xfb,\n    0xf8,\n    0xfd,\n    0xfe,\n    0xf7,\n    0xf4,\n    0xf1,\n    0xf2,\n    0xe3,\n    0xe0,\n    0xe5,\n    0xe6,\n    0xef,\n    0xec,\n    0xe9,\n    0xea,\n    0xcb,\n    0xc8,\n    0xcd,\n    0xce,\n    0xc7,\n    0xc4,\n    0xc1,\n    0xc2,\n    0xd3,\n    0xd0,\n    0xd5,\n    0xd6,\n    0xdf,\n    0xdc,\n    0xd9,\n    0xda,\n    0x5b,\n    0x58,\n    0x5d,\n    0x5e,\n    0x57,\n    0x54,\n    0x51,\n    0x52,\n    0x43,\n    0x40,\n    0x45,\n    0x46,\n    0x4f,\n    0x4c,\n    0x49,\n    0x4a,\n    0x6b,\n    0x68,\n    0x6d,\n    0x6e,\n    0x67,\n    0x64,\n    0x61,\n    0x62,\n    0x73,\n    0x70,\n    0x75,\n    0x76,\n    0x7f,\n    0x7c,\n    0x79,\n    0x7a,\n    0x3b,\n    0x38,\n    0x3d,\n    0x3e,\n    0x37,\n    0x34,\n    0x31,\n    0x32,\n    0x23,\n    0x20,\n    0x25,\n    0x26,\n    0x2f,\n    0x2c,\n    0x29,\n    0x2a,\n    0x0b,\n    0x08,\n    0x0d,\n    0x0e,\n    0x07,\n    0x04,\n    0x01,\n    0x02,\n    0x13,\n    0x10,\n    0x15,\n    0x16,\n    0x1f,\n    0x1c,\n    0x19,\n    0x1a\n];\n// Convert text to a state matrix - returns array of bytes\nconst textToState = (text)=>{\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Pad to 16 bytes if needed\n    while(bytes.length < 16){\n        bytes.push(0);\n    }\n    const block = bytes.slice(0, 16);\n    // AES state is column-major: state[r + 4*c] = input[4*c + r]\n    return block;\n};\n// Convert a key string to bytes using selected key length\nconst keyToBytes = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const requiredHexLength = requiredBytes * 2;\n    // Remove spaces and convert to lowercase\n    const cleanKey = key.replace(/\\s/g, '').toLowerCase();\n    // If it's a hex string, convert it\n    if (/^[0-9a-f]+$/.test(cleanKey)) {\n        const bytes = [];\n        for(let i = 0; i < Math.min(cleanKey.length, requiredHexLength); i += 2){\n            bytes.push(parseInt(cleanKey.substr(i, 2), 16));\n        }\n        while(bytes.length < requiredBytes){\n            bytes.push(0);\n        }\n        return bytes.slice(0, requiredBytes);\n    }\n    // Otherwise, treat as UTF-8 text and normalize to selected key size\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(key);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    while(bytes.length < requiredBytes){\n        bytes.push(0);\n    }\n    return bytes.slice(0, requiredBytes);\n};\n// Generate a random key as byte array based on key length\nconst generateRandomKey = function() {\n    let keyLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;\n    const keyBytes = getKeyByteLength(keyLength);\n    const bytes = [];\n    for(let i = 0; i < keyBytes; i++){\n        bytes.push(Math.floor(Math.random() * 256));\n    }\n    return bytes;\n};\n// Format bytes as hex\nconst bytesToHex = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(16).padStart(2, '0')).join(joinChar);\n};\n// Format bytes as binary\nconst bytesToBinary = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(2).padStart(8, '0')).join(joinChar);\n};\n// SubBytes operation - substitute each byte with its S-box value\nconst subBytes = (state)=>{\n    return state.map((byte)=>SBOX[byte]);\n};\n// ShiftRows operation - rotate rows of the state matrix\nconst shiftRows = (state)=>{\n    const result = [\n        ...state\n    ];\n    // Column-major state index helper: idx(row, col) = row + 4*col\n    const idx = (row, col)=>row + 4 * col;\n    for(let row = 1; row < 4; row++){\n        const rowValues = [\n            state[idx(row, 0)],\n            state[idx(row, 1)],\n            state[idx(row, 2)],\n            state[idx(row, 3)]\n        ];\n        const shifted = rowValues.slice(row).concat(rowValues.slice(0, row));\n        for(let col = 0; col < 4; col++){\n            result[idx(row, col)] = shifted[col];\n        }\n    }\n    return result;\n};\n// MixColumns operation - mix data within columns\nconst mixColumns = (state)=>{\n    const result = [\n        ...state\n    ];\n    const idx = (row, col)=>row + 4 * col;\n    for(let i = 0; i < 4; i++){\n        const s0 = state[idx(0, i)];\n        const s1 = state[idx(1, i)];\n        const s2 = state[idx(2, i)];\n        const s3 = state[idx(3, i)];\n        result[idx(0, i)] = GALOIS_MUL_2[s0] ^ GALOIS_MUL_3[s1] ^ s2 ^ s3;\n        result[idx(1, i)] = s0 ^ GALOIS_MUL_2[s1] ^ GALOIS_MUL_3[s2] ^ s3;\n        result[idx(2, i)] = s0 ^ s1 ^ GALOIS_MUL_2[s2] ^ GALOIS_MUL_3[s3];\n        result[idx(3, i)] = GALOIS_MUL_3[s0] ^ s1 ^ s2 ^ GALOIS_MUL_2[s3];\n    }\n    return result;\n};\n// AddRoundKey operation - XOR state with round key\nconst addRoundKey = (state, roundKey)=>{\n    return state.map((byte, i)=>byte ^ roundKey[i]);\n};\n// Kalitni kengaytirish — raund kalitlarini generatsiya qilish\nconst keyExpansion = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const normalizedKey = key.slice(0, requiredBytes);\n    while(normalizedKey.length < requiredBytes){\n        normalizedKey.push(0);\n    }\n    const keyWords = normalizedKey.length / 4;\n    const numRounds = getNumRounds(keyLength);\n    const roundKeys = [\n        normalizedKey.slice()\n    ]; // 1-raund kaliti boshlang‘ich kalitning o‘zi hisoblanadi\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const newKey = prevKey.slice();\n        // Oxirgi word ni aylantirib, S-box ni qo‘llang\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const subWord = rotWord.map((byte)=>SBOX[byte]);\n        // Birinchi baytni Rcon bilan XOR qilinadi\n        subWord[0] ^= RCON[round];\n        // Yangi kalitning birinchi word i generatsiya qilinadi\n        newKey[0] = prevKey[0] ^ subWord[0];\n        newKey[1] = prevKey[1] ^ subWord[1];\n        newKey[2] = prevKey[2] ^ subWord[2];\n        newKey[3] = prevKey[3] ^ subWord[3];\n        // Qolgan word lar hosil qilinadi\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            // AES-256 holatida har to‘rtinchi word ga qo‘shimcha S-box (SubWord) qo‘llanadi\n            if (keyLength === 256 && i === 4) {\n                const tempWord = [\n                    newKey[offset - 4],\n                    newKey[offset - 3],\n                    newKey[offset - 2],\n                    newKey[offset - 1]\n                ];\n                const subTempWord = tempWord.map((byte)=>SBOX[byte]);\n                newKey[offset] = prevKey[offset] ^ subTempWord[0];\n                newKey[offset + 1] = prevKey[offset + 1] ^ subTempWord[1];\n                newKey[offset + 2] = prevKey[offset + 2] ^ subTempWord[2];\n                newKey[offset + 3] = prevKey[offset + 3] ^ subTempWord[3];\n            } else {\n                newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n                newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n                newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n                newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            }\n        }\n        roundKeys.push(newKey);\n    }\n    return roundKeys;\n};\n// Perform one round of AES\nconst aesRound = (state, roundKey, isLastRound)=>{\n    let newState = subBytes(state);\n    newState = shiftRows(newState);\n    if (!isLastRound) {\n        newState = mixColumns(newState);\n    }\n    newState = addRoundKey(newState, roundKey);\n    return newState;\n};\n// Complete AES encryption\nconst aesEncrypt = (plaintext, key)=>{\n    // Initial state\n    const state = textToState(plaintext);\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial round - just AddRoundKey\n    let currentState = addRoundKey(state, roundKeys[0]);\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        currentState = aesRound(currentState, roundKeys[round], round === 10);\n    }\n    return currentState;\n};\n// Convert full text to array of 16-byte blocks\nconst textToBlocks = function(text) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"PKCS7\";\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    // Convert CryptoJS WordArray to byte array, respecting sigBytes\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Apply padding\n    let paddedBytes;\n    if (padding === \"PKCS7\") {\n        paddedBytes = applyPKCS7Padding(bytes);\n    } else if (padding === \"ANSI X.923\") {\n        paddedBytes = applyAnsiX923Padding(bytes);\n    } else {\n        paddedBytes = [\n            ...bytes\n        ];\n        // For NONE padding, must be multiple of 16\n        while(paddedBytes.length % 16 !== 0){\n            paddedBytes.push(0);\n        }\n    }\n    // Split into 16-byte blocks\n    const blocks = [];\n    for(let i = 0; i < paddedBytes.length; i += 16){\n        blocks.push(paddedBytes.slice(i, i + 16));\n    }\n    return blocks;\n};\n// Apply PKCS7 padding\nconst applyPKCS7Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    for(let i = 0; i < paddingLength; i++){\n        padded.push(paddingLength);\n    }\n    return padded;\n};\n// Apply ANSI X.923 padding\nconst applyAnsiX923Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    // Add padding bytes (0x00) except the last byte\n    for(let i = 0; i < paddingLength - 1; i++){\n        padded.push(0x00);\n    }\n    // Add the padding length as the last byte\n    padded.push(paddingLength);\n    return padded;\n};\n// Remove ANSI X.923 padding\nconst removeAnsiX923Padding = (data)=>{\n    const paddingLength = data[data.length - 1];\n    return data.slice(0, data.length - paddingLength);\n};\n// Get IV for CBC mode\nconst generateIV = ()=>{\n    const iv = [];\n    for(let i = 0; i < 16; i++){\n        iv.push(Math.floor(Math.random() * 256));\n    }\n    return iv;\n};\n// Get AES steps for a single block (16 bytes)\nconst getAesStepsForBlock = function(block, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", blockIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, previousCiphertextBlock = arguments.length > 4 ? arguments[4] : void 0, iv = arguments.length > 5 ? arguments[5] : void 0;\n    const steps = [];\n    // Ensure block is exactly 16 bytes\n    const plaintextBytes = [\n        ...block\n    ];\n    while(plaintextBytes.length < 16){\n        plaintextBytes.push(0);\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Asl ochiq matn\"),\n        state: plaintextBytes,\n        explanation: \"Blok \".concat(blockIndex + 1, \" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.\")\n    });\n    const initialState = plaintextBytes;\n    const roundKeys = keyExpansion(key);\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (blockIndex === 0 && iv) {\n                currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — IV bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: iv,\n                    explanation: \"CBC: birinchi blok IV bilan XOR qilinadi.\"\n                });\n            } else if (previousCiphertextBlock) {\n                currentState = initialState.map((byte, i)=>byte ^ previousCiphertextBlock[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — Oldingi ciphertext bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: previousCiphertextBlock,\n                    explanation: \"CBC: keyingi bloklar oldingi ciphertext bloki bilan XOR qilinadi.\"\n                });\n            } else {\n                currentState = initialState;\n            }\n            break;\n        case \"CTR\":\n            if (!iv) {\n                return {\n                    steps: [],\n                    finalState: plaintextBytes\n                };\n            }\n            const counterBlock = [\n                ...iv\n            ];\n            let counterValue = blockIndex;\n            for(let i = 15; i >= 0 && counterValue > 0; i--){\n                const sum = counterBlock[i] + (counterValue & 0xff);\n                counterBlock[i] = sum & 0xff;\n                counterValue = (counterValue >> 8) + (sum >> 8);\n            }\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter\"),\n                state: counterBlock,\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter.\")\n            });\n            currentState = counterBlock;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Boshlang'ich\"),\n                state: currentState,\n                explanation: \"ECB: blok \".concat(blockIndex + 1, \" mustaqil shifrlanadi.\")\n            });\n            break;\n    }\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — 0-bosqich — AddRoundKey\"),\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    for(let round = 1; round <= 10; round++){\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState\n        });\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows\n            });\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter XOR\"),\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter XOR.\"),\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Yakuniy\"),\n        state: finalState,\n        explanation: \"Blok \".concat(blockIndex + 1, \" uchun yakuniy shifrlangan natija.\")\n    });\n    return {\n        steps,\n        finalState\n    };\n};\nconst getAesSteps = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", providedIv = arguments.length > 4 ? arguments[4] : void 0;\n    const steps = [];\n    let iv = providedIv ? [\n        ...providedIv\n    ] : undefined;\n    // Convert full text to blocks\n    const blocks = textToBlocks(plaintext, padding);\n    const allBlocks = [];\n    // Convert plaintext to bytes (for first block visualization)\n    let plaintextBytes = blocks[0] || textToState(plaintext);\n    steps.push({\n        description: 'Asl ochiq matn',\n        state: plaintextBytes,\n        explanation: 'Ochiq matn \"'.concat(plaintext, '\" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.')\n    });\n    // Apply padding if needed\n    if (padding === \"ANSI X.923\") {\n        plaintextBytes = applyAnsiX923Padding(plaintextBytes);\n        steps.push({\n            description: 'ANSI X.923 to‘ldirishdan keyin',\n            state: plaintextBytes,\n            explanation: 'ANSI X.923 to‘ldirish nollar bilan to‘ldiradi va oxirgi byte ga to‘ldirish uzunligini qo‘yadi.'\n        });\n    }\n    // Generate IV for CBC/CTR mode only if not provided\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n        if (blocks.length === 1) {\n            // Only show IV step if single block (for backward compatibility)\n            const ivDescription = mode === \"CBC\" ? 'Boshlang\\'ich vektor (Initialization Vector, IV)' : 'Counter (Nonce)';\n            const ivExplanation = \"\".concat(mode === \"CBC\" ? 'CBC' : 'CTR', \" rejimi uchun 16-bayt tasodifiy \").concat(mode === \"CBC\" ? 'IV' : 'Nonce', \" yaratiladi.\");\n            steps.push({\n                description: ivDescription,\n                state: iv,\n                explanation: ivExplanation\n            });\n        }\n    }\n    // Start encryption process (for first block visualization)\n    const initialState = plaintextBytes;\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial setup based on mode\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (!iv) iv = generateIV(); // Failsafe\n            // XOR plaintext with IV\n            currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n            steps.push({\n                description: 'Boshlang\\'ich holatni IV bilan XOR qilish',\n                state: currentState,\n                activeIndices: Array.from(Array(16).keys()),\n                previousState: initialState,\n                roundKey: iv,\n                explanation: \"CBC rejimida shifrlash boshlanishidan oldin ochiq matn IV bilan XOR qilinadi. Bu jarayon CBC rejimining asosiy xususiyatidir - har bir ochiq matn bloki avvalgi shifrlangan matn bloki (yoki birinchi blok uchun IV) bilan XOR qilinadi, keyin shifrlanadi. Bu bir xil ochiq matn bloklarini turli shifrlangan matn bloklarga aylantiradi va shifrlangan matndagi naqshlarni yashirishga yordam beradi.\"\n            });\n            break;\n        case \"CTR\":\n            // In CTR mode, we encrypt a counter value instead of the plaintext\n            const counter = iv || generateIV();\n            if (!iv) iv = counter;\n            steps.push({\n                description: 'Counter qiymati',\n                state: counter,\n                explanation: 'CTR rejimida ochiq matn o‘rniga counter qiymati shifrlanadi.'\n            });\n            currentState = counter;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: 'Boshlang‘ich holat (ochiq matn)',\n                state: currentState,\n                explanation: 'ECB rejimida ochiq matn bloklari mustaqil ravishda shifrlanadi.'\n            });\n            break;\n    }\n    // Initial round - just AddRoundKey (Round 0)\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: '0-bosqich — Boshlang\\'ich AddRoundKey',\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        // SubBytes\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState // Add previous state for S-box lookup\n        });\n        // ShiftRows\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes // Add previous state for comparison\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            // MixColumns (not in final round)\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"\".concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows // Add previous state for MixColumns comparison\n            });\n            // AddRoundKey\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            // Final round has no MixColumns\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    // Final output based on mode\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            // Output is the current state (already completed encryption)\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            // XOR the encrypted counter with plaintext\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: 'Ochiq matn shifrlangan hisoblagich bilan XOR amaliyotida birlashtiriladi.',\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: 'CTR rejimida, yakuniy bosqichda shifrlangan hisoblagich ochiq matn bilan XOR amaliyoti orqali birlashtiriladi va natijada shifrlangan matn hosil bo‘ladi.',\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: 'Yakuniy shifrlangan matn',\n        state: finalState,\n        explanation: \"\".concat(mode, \" rejimida AES-128 yordamida olingan yakuniy shifrlangan natija.\")\n    });\n    // Process all blocks for multi-block support\n    let previousCiphertextBlock;\n    const combinedFinalStates = [];\n    // Generate IV if needed\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n    }\n    for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){\n        const blockResult = getAesStepsForBlock(blocks[blockIndex], key, mode, blockIndex, previousCiphertextBlock, iv);\n        allBlocks.push({\n            blockIndex,\n            steps: blockResult.steps,\n            finalState: blockResult.finalState\n        });\n        combinedFinalStates.push(...blockResult.finalState);\n        // For CBC mode, use current ciphertext as previous for next block\n        if (mode === \"CBC\") {\n            previousCiphertextBlock = blockResult.finalState;\n        }\n    }\n    // Use combined final states if we have multiple blocks, otherwise use single block result\n    const finalStateToUse = blocks.length > 1 ? combinedFinalStates : finalState;\n    // Convert the final state to the requested output format\n    const finalWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create(new Uint8Array(finalStateToUse));\n    const finalCiphertextBase64 = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.stringify(finalWordArray);\n    const finalCiphertextHex = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(finalWordArray);\n    const finalCiphertextBinary = bytesToBinary(finalStateToUse, '');\n    return {\n        steps,\n        finalCiphertext: {\n            base64: finalCiphertextBase64,\n            hex: finalCiphertextHex,\n            binary: finalCiphertextBinary\n        },\n        iv,\n        allBlocks: allBlocks.length > 1 ? allBlocks : undefined\n    };\n};\n// Get key expansion steps with detailed explanations\nconst getKeyExpansionSteps = (key)=>{\n    const roundKeys = keyExpansion(key);\n    const steps = [];\n    steps.push({\n        description: 'Boshlang‘ich kalit',\n        key: roundKeys[0],\n        explanation: 'Bu foydalanuvchi tomonidan berilgan asl 128-bitli kalitdir.'\n    });\n    for(let round = 1; round <= 10; round++){\n        const prevKey = roundKeys[round - 1];\n        const currentKey = roundKeys[round];\n        // Calculate the transformations for a more detailed explanation\n        const lastWord = [\n            prevKey[12],\n            prevKey[13],\n            prevKey[14],\n            prevKey[15]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        const rconValue = RCON[round];\n        const transformedWord = [\n            ...sboxWord\n        ];\n        transformedWord[0] ^= rconValue;\n        // Calculate the first word of the previous key and its XOR with the transformed word\n        const firstWordPrev = [\n            prevKey[0],\n            prevKey[1],\n            prevKey[2],\n            prevKey[3]\n        ];\n        const xorResult = firstWordPrev.map((byte, index)=>byte ^ transformedWord[index]);\n        // Show the key with highlighted cells for the new word\n        steps.push({\n            description: \"Raund kaliti \".concat(round),\n            key: currentKey,\n            explanation: \"\\n        \".concat(round, \"-raund uchun kalitni kengaytirish jarayoni:\\n        1. Oldingi kalitning oxirgi word qismini oling: [\").concat(lastWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        2. Wordni aylantiring: [\").concat(rotWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        3. Aylantirilgan word ga S-box ni qo‘llang: [\").concat(sboxWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        4. Birinchi baytga RCON (Round Constant \").concat(rconValue.toString(16), \") ni qo‘llang:\\n          Natija: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        5. Oldingi kalitning birinchi word i: [\").concat(firstWordPrev.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] ni o‘zgartirilgan word bilan XOR qiling: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"], natijada: [\").concat(xorResult.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] hosil bo‘ladi. So‘ngra qolgan word lar shu tarzda hosil qilinadi.\\n      \"),\n            highlightedCells: [\n                0,\n                1,\n                2,\n                3\n            ] // Highlight the first word that's directly transformed\n        });\n    }\n    return steps;\n};\n// Return intermediate steps for each word expansion for visualization\nfunction getKeyScheduleDetailedSteps(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    // Flatten byte array -> words\n    let prevKey = key.slice();\n    let roundKeys = [\n        prevKey.slice()\n    ];\n    // For result visualization: each step for each round\n    let stepsPerRound = [];\n    for(let round = 1; round <= numRounds; round++){\n        let stepDetails = [];\n        let newKey = prevKey.slice();\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        // Step 1: RotWord\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        stepDetails.push({\n            step: 'RotWord',\n            input: lastWord.slice(),\n            output: rotWord.slice()\n        });\n        // Step 2: SubBytes (S-box)\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        stepDetails.push({\n            step: 'SubBytes',\n            input: rotWord.slice(),\n            output: sboxWord.slice()\n        });\n        // Step 3: Rcon to first byte\n        const rconValue = RCON[round];\n        const rconWord = sboxWord.slice();\n        rconWord[0] ^= rconValue;\n        stepDetails.push({\n            step: 'Apply Rcon',\n            input: sboxWord.slice(),\n            rcon: rconValue,\n            output: rconWord.slice()\n        });\n        // Step 4: XOR with previous (first word)\n        const xorResult = [\n            prevKey[0] ^ rconWord[0],\n            prevKey[1] ^ rconWord[1],\n            prevKey[2] ^ rconWord[2],\n            prevKey[3] ^ rconWord[3]\n        ];\n        stepDetails.push({\n            step: 'XOR with previous',\n            inputs: [\n                prevKey.slice(0, 4),\n                rconWord.slice()\n            ],\n            output: xorResult.slice()\n        });\n        // Save and update newKey\n        newKey[0] = xorResult[0];\n        newKey[1] = xorResult[1];\n        newKey[2] = xorResult[2];\n        newKey[3] = xorResult[3];\n        // Other words (only simple xor)\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n            newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n            newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n            newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            stepDetails.push({\n                step: 'XOR chain',\n                inputs: [\n                    newKey.slice(offset - 4, offset),\n                    prevKey.slice(offset, offset + 4)\n                ],\n                output: newKey.slice(offset, offset + 4),\n                wordIndex: i\n            });\n        }\n        stepsPerRound.push({\n            round,\n            stepDetails,\n            roundKey: newKey.slice()\n        });\n        prevKey = newKey.slice();\n        roundKeys.push(prevKey);\n    }\n    return stepsPerRound;\n}\n// Real AES encryption using CryptoJS for verification\nconst realAesEncrypt = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", outputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    // Handle case where key is shorter than required by keyLength\n    const cleanKey = key.replace(/\\s/g, '');\n    let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n    // Ensure key is of correct length for the selected key length\n    const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n    if (keyHex.length < requiredHexChars) {\n        // Pad key if too short\n        keyHex = keyHex.padEnd(requiredHexChars, '0');\n    } else if (keyHex.length > requiredHexChars) {\n        // Truncate key if too long\n        keyHex = keyHex.substring(0, requiredHexChars);\n    }\n    const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n    let paddingOption;\n    switch(padding){\n        case \"ANSI X.923\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n            };\n            break;\n        case \"None\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n            };\n            break;\n        default:\n            paddingOption = {}; // default is PKCS7\n    }\n    let modeOption;\n    let iv;\n    switch(mode){\n        case \"CBC\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                iv: iv,\n                ...paddingOption\n            };\n            break;\n        case \"CTR\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                iv: iv,\n                counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                    0,\n                    0,\n                    0,\n                    0\n                ], 16),\n                ...paddingOption\n            };\n            break;\n        default:\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                ...paddingOption\n            };\n            break;\n    }\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(plaintext, keyWordArray, modeOption);\n    // Get all output formats\n    const base64Output = encrypted.toString();\n    const cipherParams = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.CipherParams.create({\n        ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(base64Output)\n    });\n    const hexOutput = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().format.Hex.stringify(cipherParams);\n    // For binary, we need to convert the hex to binary\n    const hexBytes = hexOutput.match(/.{2}/g).map((hex)=>parseInt(hex, 16));\n    const binaryOutput = bytesToBinary(hexBytes, '');\n    // Select the requested format for primary output\n    let primaryOutput;\n    switch(outputFormat){\n        case \"Hex\":\n            primaryOutput = hexOutput;\n            break;\n        case \"Binary\":\n            primaryOutput = binaryOutput;\n            break;\n        default:\n            primaryOutput = base64Output;\n            break;\n    }\n    return {\n        ciphertext: primaryOutput,\n        iv: iv ? crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(iv) : undefined,\n        formats: {\n            base64: base64Output,\n            hex: hexOutput,\n            binary: binaryOutput\n        }\n    };\n};\n// Real AES decryption using CryptoJS\nconst realAesDecrypt = function(ciphertext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", inputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    try {\n        // Handle case where key is shorter than required by keyLength\n        const cleanKey = key.replace(/\\s/g, '');\n        let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n        // Ensure key is of correct length for the selected key length\n        const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n        if (keyHex.length < requiredHexChars) {\n            // Pad key if too short\n            keyHex = keyHex.padEnd(requiredHexChars, '0');\n        } else if (keyHex.length > requiredHexChars) {\n            // Truncate key if too long\n            keyHex = keyHex.substring(0, requiredHexChars);\n        }\n        const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n        // Parse ciphertext based on input format\n        let ciphertextWordArray;\n        switch(inputFormat){\n            case \"Hex\":\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ciphertext.replace(/\\s/g, ''));\n                break;\n            case \"Binary\":\n                var _ciphertext_replace_match;\n                // Convert binary string to hex first\n                const hexFromBinary = ((_ciphertext_replace_match = ciphertext.replace(/\\s/g, '').match(/.{8}/g)) === null || _ciphertext_replace_match === void 0 ? void 0 : _ciphertext_replace_match.map((bin)=>parseInt(bin, 2).toString(16).padStart(2, '0')).join('')) || '';\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(hexFromBinary);\n                break;\n            default:\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(ciphertext);\n                break;\n        }\n        let paddingOption;\n        switch(padding){\n            case \"ANSI X.923\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n                };\n                break;\n            case \"None\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n                };\n                break;\n            default:\n                paddingOption = {}; // default is PKCS7\n        }\n        let modeOption;\n        let iv;\n        switch(mode){\n            case \"CBC\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CBC rejimi uchun IV kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                    iv: iv,\n                    ...paddingOption\n                };\n                break;\n            case \"CTR\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CTR rejimi uchun IV (Nonce) kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                    iv: iv,\n                    counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                        0,\n                        0,\n                        0,\n                        0\n                    ], 16),\n                    ...paddingOption\n                };\n                break;\n            default:\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                    ...paddingOption\n                };\n                break;\n        }\n        const decrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt({\n            ciphertext: ciphertextWordArray\n        }, keyWordArray, modeOption);\n        const plaintext = decrypted.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n        if (!plaintext) {\n            return {\n                plaintext: '',\n                error: 'Deshifrlash muvaffaqiyatsiz. Kalit yoki shifrlangan matn noto\\'g\\'ri.'\n            };\n        }\n        return {\n            plaintext\n        };\n    } catch (error) {\n        return {\n            plaintext: '',\n            error: error.message || 'Deshifrlashda xatolik yuz berdi'\n        };\n    }\n};\n// Test specific case for \"Salom, AES!\" with key \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\"\nconst testSpecificCase = ()=>{\n    const plaintext = \"Salom, AES!\";\n    const key = \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\";\n    // Create key and input as byte arrays\n    const keyBytes = [];\n    for(let i = 0; i < key.length; i += 2){\n        keyBytes.push(parseInt(key.substr(i, 2), 16));\n    }\n    // Use our implementation\n    const { finalCiphertext } = getAesSteps(plaintext, keyBytes, \"ECB\", \"PKCS7\");\n    // Use CryptoJS implementation\n    const cryptoResult = realAesEncrypt(plaintext, key, \"ECB\", \"PKCS7\", \"Hex\");\n    return \"\\n    Bizning implementatsiyamiz (HEX): \".concat(finalCiphertext.hex, \"\\n    CryptoJS implementatsiyasi (HEX): \").concat(cryptoResult.formats.hex, \"\\n    Kutilayotgan natija: 30484B8F8C6BB09CA3F94C6F84F0305E\\n  \");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9hZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUVqQyxnQkFBZ0I7QUFDVCxxQ0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELGVBQWU7QUFDUix5Q0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELHFCQUFxQjtBQUNkLDBDQUFLQzs7OztXQUFBQTtNQUlYO0FBRUQsa0JBQWtCO0FBQ1gsdUNBQUtDOzs7O1dBQUFBO01BSVg7QUFFRCxNQUFNQyxlQUFlLENBQUNDLFlBQ3BCQSxvQkFBa0MsS0FDbENBLG9CQUFrQyxLQUFLO0FBR3pDLE1BQU1DLG1CQUFtQixDQUFDRCxZQUFpQ0EsWUFBWTtBQUV2RSxzQ0FBc0M7QUFDL0IsTUFBTUUsT0FBTztJQUNsQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRixDQUFDO0FBRUYsNkJBQTZCO0FBQ3RCLE1BQU1DLE9BQU87SUFDbEI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLHFCQUFxQjtBQUNkLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVLLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxj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TSxDQUFDbkIsR0FBRyxJQUFJO0lBQzNDO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU0sRUFBRThILGVBQWUsRUFBRSxHQUFHckIsWUFBWXJDLFdBQVcvQztJQUVuRCw4QkFBOEI7SUFDOUIsTUFBTXlLLGVBQWV4QyxlQUFlbEYsV0FBV3pEO0lBRS9DLE9BQU8sMkNBRStCbUwsT0FEQWhFLGdCQUFnQkUsR0FBRyxFQUFDLDRDQUNLLE9BQXpCOEQsYUFBYVgsT0FBTyxDQUFDbkQsR0FBRyxFQUFDO0FBR2pFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdmljdHVzXFxEZXNrdG9wXFxhZXNcXEZpbmFsIEFFU1xcYWVzXFxzcmNcXHV0aWxzXFxhZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5cbi8vIEFFUyBtb2RlIGVudW1cbmV4cG9ydCBlbnVtIEFlc01vZGUge1xuICBFQ0IgPSAnRUNCJyxcbiAgQ0JDID0gJ0NCQycsXG4gIENUUiA9ICdDVFInXG59XG5cbi8vIFBhZGRpbmcgZW51bVxuZXhwb3J0IGVudW0gUGFkZGluZ1R5cGUge1xuICBQS0NTNyA9ICdQS0NTNycsXG4gIEFOU0lfWDkyMyA9ICdBTlNJIFguOTIzJyxcbiAgTk9ORSA9ICdOb25lJ1xufVxuXG4vLyBPdXRwdXQgZm9ybWF0IGVudW1cbmV4cG9ydCBlbnVtIE91dHB1dEZvcm1hdCB7XG4gIEJBU0U2NCA9ICdCYXNlNjQnLFxuICBIRVggPSAnSGV4JyxcbiAgQklOQVJZID0gJ0JpbmFyeSdcbn1cblxuLy8gS2V5IGxlbmd0aCBlbnVtXG5leHBvcnQgZW51bSBLZXlMZW5ndGgge1xuICBBRVNfMTI4ID0gMTI4LFxuICBBRVNfMTkyID0gMTkyLFxuICBBRVNfMjU2ID0gMjU2XG59XG5cbmNvbnN0IGdldE51bVJvdW5kcyA9IChrZXlMZW5ndGg6IEtleUxlbmd0aCk6IG51bWJlciA9PiAoXG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xMjggPyAxMCA6XG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xOTIgPyAxMiA6IDE0XG4pO1xuXG5jb25zdCBnZXRLZXlCeXRlTGVuZ3RoID0gKGtleUxlbmd0aDogS2V5TGVuZ3RoKTogbnVtYmVyID0+IGtleUxlbmd0aCAvIDg7XG5cbi8vIEFFUyBTLUJveCAoU3RhbmRhcmQgUmlqbmRhZWwgUy1ib3gpXG5leHBvcnQgY29uc3QgU0JPWCA9IFtcbiAgMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NixcbiAgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCxcbiAgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSxcbiAgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSxcbiAgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCxcbiAgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZixcbiAgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCxcbiAgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMixcbiAgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MyxcbiAgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYixcbiAgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSxcbiAgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCxcbiAgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSxcbiAgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSxcbiAgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZixcbiAgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNixcbl07XG5cbi8vIEFFUyBSY29uIChSb3VuZCBDb25zdGFudHMpXG5leHBvcnQgY29uc3QgUkNPTiA9IFtcbiAgMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSxcbl07XG5cbi8vIFVzZWQgaW4gTWl4Q29sdW1uc1xuZXhwb3J0IGNvbnN0IEdBTE9JU19NVUxfMiA9IFtcbiAgMHgwMCwgMHgwMiwgMHgwNCwgMHgwNiwgMHgwOCwgMHgwYSwgMHgwYywgMHgwZSwgMHgxMCwgMHgxMiwgMHgxNCwgMHgxNiwgMHgxOCwgMHgxYSwgMHgxYywgMHgxZSxcbiAgMHgyMCwgMHgyMiwgMHgyNCwgMHgyNiwgMHgyOCwgMHgyYSwgMHgyYywgMHgyZSwgMHgzMCwgMHgzMiwgMHgzNCwgMHgzNiwgMHgzOCwgMHgzYSwgMHgzYywgMHgzZSxcbiAgMHg0MCwgMHg0MiwgMHg0NCwgMHg0NiwgMHg0OCwgMHg0YSwgMHg0YywgMHg0ZSwgMHg1MCwgMHg1MiwgMHg1NCwgMHg1NiwgMHg1OCwgMHg1YSwgMHg1YywgMHg1ZSxcbiAgMHg2MCwgMHg2MiwgMHg2NCwgMHg2NiwgMHg2OCwgMHg2YSwgMHg2YywgMHg2ZSwgMHg3MCwgMHg3MiwgMHg3NCwgMHg3NiwgMHg3OCwgMHg3YSwgMHg3YywgMHg3ZSxcbiAgMHg4MCwgMHg4MiwgMHg4NCwgMHg4NiwgMHg4OCwgMHg4YSwgMHg4YywgMHg4ZSwgMHg5MCwgMHg5MiwgMHg5NCwgMHg5NiwgMHg5OCwgMHg5YSwgMHg5YywgMHg5ZSxcbiAgMHhhMCwgMHhhMiwgMHhhNCwgMHhhNiwgMHhhOCwgMHhhYSwgMHhhYywgMHhhZSwgMHhiMCwgMHhiMiwgMHhiNCwgMHhiNiwgMHhiOCwgMHhiYSwgMHhiYywgMHhiZSxcbiAgMHhjMCwgMHhjMiwgMHhjNCwgMHhjNiwgMHhjOCwgMHhjYSwgMHhjYywgMHhjZSwgMHhkMCwgMHhkMiwgMHhkNCwgMHhkNiwgMHhkOCwgMHhkYSwgMHhkYywgMHhkZSxcbiAgMHhlMCwgMHhlMiwgMHhlNCwgMHhlNiwgMHhlOCwgMHhlYSwgMHhlYywgMHhlZSwgMHhmMCwgMHhmMiwgMHhmNCwgMHhmNiwgMHhmOCwgMHhmYSwgMHhmYywgMHhmZSxcbiAgMHgxYiwgMHgxOSwgMHgxZiwgMHgxZCwgMHgxMywgMHgxMSwgMHgxNywgMHgxNSwgMHgwYiwgMHgwOSwgMHgwZiwgMHgwZCwgMHgwMywgMHgwMSwgMHgwNywgMHgwNSxcbiAgMHgzYiwgMHgzOSwgMHgzZiwgMHgzZCwgMHgzMywgMHgzMSwgMHgzNywgMHgzNSwgMHgyYiwgMHgyOSwgMHgyZiwgMHgyZCwgMHgyMywgMHgyMSwgMHgyNywgMHgyNSxcbiAgMHg1YiwgMHg1OSwgMHg1ZiwgMHg1ZCwgMHg1MywgMHg1MSwgMHg1NywgMHg1NSwgMHg0YiwgMHg0OSwgMHg0ZiwgMHg0ZCwgMHg0MywgMHg0MSwgMHg0NywgMHg0NSxcbiAgMHg3YiwgMHg3OSwgMHg3ZiwgMHg3ZCwgMHg3MywgMHg3MSwgMHg3NywgMHg3NSwgMHg2YiwgMHg2OSwgMHg2ZiwgMHg2ZCwgMHg2MywgMHg2MSwgMHg2NywgMHg2NSxcbiAgMHg5YiwgMHg5OSwgMHg5ZiwgMHg5ZCwgMHg5MywgMHg5MSwgMHg5NywgMHg5NSwgMHg4YiwgMHg4OSwgMHg4ZiwgMHg4ZCwgMHg4MywgMHg4MSwgMHg4NywgMHg4NSxcbiAgMHhiYiwgMHhiOSwgMHhiZiwgMHhiZCwgMHhiMywgMHhiMSwgMHhiNywgMHhiNSwgMHhhYiwgMHhhOSwgMHhhZiwgMHhhZCwgMHhhMywgMHhhMSwgMHhhNywgMHhhNSxcbiAgMHhkYiwgMHhkOSwgMHhkZiwgMHhkZCwgMHhkMywgMHhkMSwgMHhkNywgMHhkNSwgMHhjYiwgMHhjOSwgMHhjZiwgMHhjZCwgMHhjMywgMHhjMSwgMHhjNywgMHhjNSxcbiAgMHhmYiwgMHhmOSwgMHhmZiwgMHhmZCwgMHhmMywgMHhmMSwgMHhmNywgMHhmNSwgMHhlYiwgMHhlOSwgMHhlZiwgMHhlZCwgMHhlMywgMHhlMSwgMHhlNywgMHhlNSxcbl07XG5cbmV4cG9ydCBjb25zdCBHQUxPSVNfTVVMXzMgPSBbXG4gIDB4MDAsIDB4MDMsIDB4MDYsIDB4MDUsIDB4MGMsIDB4MGYsIDB4MGEsIDB4MDksIDB4MTgsIDB4MWIsIDB4MWUsIDB4MWQsIDB4MTQsIDB4MTcsIDB4MTIsIDB4MTEsXG4gIDB4MzAsIDB4MzMsIDB4MzYsIDB4MzUsIDB4M2MsIDB4M2YsIDB4M2EsIDB4MzksIDB4MjgsIDB4MmIsIDB4MmUsIDB4MmQsIDB4MjQsIDB4MjcsIDB4MjIsIDB4MjEsXG4gIDB4NjAsIDB4NjMsIDB4NjYsIDB4NjUsIDB4NmMsIDB4NmYsIDB4NmEsIDB4NjksIDB4NzgsIDB4N2IsIDB4N2UsIDB4N2QsIDB4NzQsIDB4NzcsIDB4NzIsIDB4NzEsXG4gIDB4NTAsIDB4NTMsIDB4NTYsIDB4NTUsIDB4NWMsIDB4NWYsIDB4NWEsIDB4NTksIDB4NDgsIDB4NGIsIDB4NGUsIDB4NGQsIDB4NDQsIDB4NDcsIDB4NDIsIDB4NDEsXG4gIDB4YzAsIDB4YzMsIDB4YzYsIDB4YzUsIDB4Y2MsIDB4Y2YsIDB4Y2EsIDB4YzksIDB4ZDgsIDB4ZGIsIDB4ZGUsIDB4ZGQsIDB4ZDQsIDB4ZDcsIDB4ZDIsIDB4ZDEsXG4gIDB4ZjAsIDB4ZjMsIDB4ZjYsIDB4ZjUsIDB4ZmMsIDB4ZmYsIDB4ZmEsIDB4ZjksIDB4ZTgsIDB4ZWIsIDB4ZWUsIDB4ZWQsIDB4ZTQsIDB4ZTcsIDB4ZTIsIDB4ZTEsXG4gIDB4YTAsIDB4YTMsIDB4YTYsIDB4YTUsIDB4YWMsIDB4YWYsIDB4YWEsIDB4YTksIDB4YjgsIDB4YmIsIDB4YmUsIDB4YmQsIDB4YjQsIDB4YjcsIDB4YjIsIDB4YjEsXG4gIDB4OTAsIDB4OTMsIDB4OTYsIDB4OTUsIDB4OWMsIDB4OWYsIDB4OWEsIDB4OTksIDB4ODgsIDB4OGIsIDB4OGUsIDB4OGQsIDB4ODQsIDB4ODcsIDB4ODIsIDB4ODEsXG4gIDB4OWIsIDB4OTgsIDB4OWQsIDB4OWUsIDB4OTcsIDB4OTQsIDB4OTEsIDB4OTIsIDB4ODMsIDB4ODAsIDB4ODUsIDB4ODYsIDB4OGYsIDB4OGMsIDB4ODksIDB4OGEsXG4gIDB4YWIsIDB4YTgsIDB4YWQsIDB4YWUsIDB4YTcsIDB4YTQsIDB4YTEsIDB4YTIsIDB4YjMsIDB4YjAsIDB4YjUsIDB4YjYsIDB4YmYsIDB4YmMsIDB4YjksIDB4YmEsXG4gIDB4ZmIsIDB4ZjgsIDB4ZmQsIDB4ZmUsIDB4ZjcsIDB4ZjQsIDB4ZjEsIDB4ZjIsIDB4ZTMsIDB4ZTAsIDB4ZTUsIDB4ZTYsIDB4ZWYsIDB4ZWMsIDB4ZTksIDB4ZWEsXG4gIDB4Y2IsIDB4YzgsIDB4Y2QsIDB4Y2UsIDB4YzcsIDB4YzQsIDB4YzEsIDB4YzIsIDB4ZDMsIDB4ZDAsIDB4ZDUsIDB4ZDYsIDB4ZGYsIDB4ZGMsIDB4ZDksIDB4ZGEsXG4gIDB4NWIsIDB4NTgsIDB4NWQsIDB4NWUsIDB4NTcsIDB4NTQsIDB4NTEsIDB4NTIsIDB4NDMsIDB4NDAsIDB4NDUsIDB4NDYsIDB4NGYsIDB4NGMsIDB4NDksIDB4NGEsXG4gIDB4NmIsIDB4NjgsIDB4NmQsIDB4NmUsIDB4NjcsIDB4NjQsIDB4NjEsIDB4NjIsIDB4NzMsIDB4NzAsIDB4NzUsIDB4NzYsIDB4N2YsIDB4N2MsIDB4NzksIDB4N2EsXG4gIDB4M2IsIDB4MzgsIDB4M2QsIDB4M2UsIDB4MzcsIDB4MzQsIDB4MzEsIDB4MzIsIDB4MjMsIDB4MjAsIDB4MjUsIDB4MjYsIDB4MmYsIDB4MmMsIDB4MjksIDB4MmEsXG4gIDB4MGIsIDB4MDgsIDB4MGQsIDB4MGUsIDB4MDcsIDB4MDQsIDB4MDEsIDB4MDIsIDB4MTMsIDB4MTAsIDB4MTUsIDB4MTYsIDB4MWYsIDB4MWMsIDB4MTksIDB4MWEsXG5dO1xuXG4vLyBDb252ZXJ0IHRleHQgdG8gYSBzdGF0ZSBtYXRyaXggLSByZXR1cm5zIGFycmF5IG9mIGJ5dGVzXG5leHBvcnQgY29uc3QgdGV4dFRvU3RhdGUgPSAodGV4dDogc3RyaW5nKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh0ZXh0KTtcbiAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRBcnJheS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHdvcmQgPSB3b3JkQXJyYXkud29yZHNbaV07XG4gICAgY29uc3QgYnl0ZXNJblRoaXNXb3JkID0gTWF0aC5taW4oNCwgc2lnQnl0ZXMgLSBpICogNCk7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAxKSBieXRlcy5wdXNoKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDIpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDE2KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMykgYnl0ZXMucHVzaCgod29yZCA+Pj4gOCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDQpIGJ5dGVzLnB1c2god29yZCAmIDB4ZmYpO1xuICB9XG4gIFxuICAvLyBQYWQgdG8gMTYgYnl0ZXMgaWYgbmVlZGVkXG4gIHdoaWxlIChieXRlcy5sZW5ndGggPCAxNikge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIGNvbnN0IGJsb2NrID0gYnl0ZXMuc2xpY2UoMCwgMTYpO1xuICAvLyBBRVMgc3RhdGUgaXMgY29sdW1uLW1ham9yOiBzdGF0ZVtyICsgNCpjXSA9IGlucHV0WzQqYyArIHJdXG4gIHJldHVybiBibG9jaztcbn07XG5cbi8vIENvbnZlcnQgYSBrZXkgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIHNlbGVjdGVkIGtleSBsZW5ndGhcbmV4cG9ydCBjb25zdCBrZXlUb0J5dGVzID0gKFxuICBrZXk6IHN0cmluZyxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXF1aXJlZEJ5dGVzID0gZ2V0S2V5Qnl0ZUxlbmd0aChrZXlMZW5ndGgpO1xuICBjb25zdCByZXF1aXJlZEhleExlbmd0aCA9IHJlcXVpcmVkQnl0ZXMgKiAyO1xuXG4gIC8vIFJlbW92ZSBzcGFjZXMgYW5kIGNvbnZlcnQgdG8gbG93ZXJjYXNlXG4gIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIElmIGl0J3MgYSBoZXggc3RyaW5nLCBjb252ZXJ0IGl0XG4gIGlmICgvXlswLTlhLWZdKyQvLnRlc3QoY2xlYW5LZXkpKSB7XG4gICAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihjbGVhbktleS5sZW5ndGgsIHJlcXVpcmVkSGV4TGVuZ3RoKTsgaSArPSAyKSB7XG4gICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGNsZWFuS2V5LnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgICB9XG4gICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCA8IHJlcXVpcmVkQnl0ZXMpIHtcbiAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5zbGljZSgwLCByZXF1aXJlZEJ5dGVzKTtcbiAgfVxuICBcbiAgLy8gT3RoZXJ3aXNlLCB0cmVhdCBhcyBVVEYtOCB0ZXh0IGFuZCBub3JtYWxpemUgdG8gc2VsZWN0ZWQga2V5IHNpemVcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2Uoa2V5KTtcbiAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRBcnJheS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHdvcmQgPSB3b3JkQXJyYXkud29yZHNbaV07XG4gICAgY29uc3QgYnl0ZXNJblRoaXNXb3JkID0gTWF0aC5taW4oNCwgc2lnQnl0ZXMgLSBpICogNCk7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAxKSBieXRlcy5wdXNoKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDIpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDE2KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMykgYnl0ZXMucHVzaCgod29yZCA+Pj4gOCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDQpIGJ5dGVzLnB1c2god29yZCAmIDB4ZmYpO1xuICB9XG4gIHdoaWxlIChieXRlcy5sZW5ndGggPCByZXF1aXJlZEJ5dGVzKSB7XG4gICAgYnl0ZXMucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgcmVxdWlyZWRCeXRlcyk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHJhbmRvbSBrZXkgYXMgYnl0ZSBhcnJheSBiYXNlZCBvbiBrZXkgbGVuZ3RoXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21LZXkgPSAoa2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCk6IG51bWJlcltdID0+IHtcbiAgY29uc3Qga2V5Qnl0ZXMgPSBnZXRLZXlCeXRlTGVuZ3RoKGtleUxlbmd0aCk7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Qnl0ZXM7IGkrKykge1xuICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gRm9ybWF0IGJ5dGVzIGFzIGhleFxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9IZXggPSAoYnl0ZXM6IG51bWJlcltdLCBqb2luQ2hhcjogc3RyaW5nID0gJyAnKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGJ5dGVzLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oam9pbkNoYXIpO1xufTtcblxuLy8gRm9ybWF0IGJ5dGVzIGFzIGJpbmFyeVxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9CaW5hcnkgPSAoYnl0ZXM6IG51bWJlcltdLCBqb2luQ2hhcjogc3RyaW5nID0gJyAnKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGJ5dGVzLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgJzAnKSkuam9pbihqb2luQ2hhcik7XG59O1xuXG4vLyBTdWJCeXRlcyBvcGVyYXRpb24gLSBzdWJzdGl0dXRlIGVhY2ggYnl0ZSB3aXRoIGl0cyBTLWJveCB2YWx1ZVxuZXhwb3J0IGNvbnN0IHN1YkJ5dGVzID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgcmV0dXJuIHN0YXRlLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xufTtcblxuLy8gU2hpZnRSb3dzIG9wZXJhdGlvbiAtIHJvdGF0ZSByb3dzIG9mIHRoZSBzdGF0ZSBtYXRyaXhcbmV4cG9ydCBjb25zdCBzaGlmdFJvd3MgPSAoc3RhdGU6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXN1bHQgPSBbLi4uc3RhdGVdO1xuICBcbiAgLy8gQ29sdW1uLW1ham9yIHN0YXRlIGluZGV4IGhlbHBlcjogaWR4KHJvdywgY29sKSA9IHJvdyArIDQqY29sXG4gIGNvbnN0IGlkeCA9IChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpID0+IHJvdyArIDQgKiBjb2w7XG5cbiAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgNDsgcm93KyspIHtcbiAgICBjb25zdCByb3dWYWx1ZXMgPSBbc3RhdGVbaWR4KHJvdywgMCldLCBzdGF0ZVtpZHgocm93LCAxKV0sIHN0YXRlW2lkeChyb3csIDIpXSwgc3RhdGVbaWR4KHJvdywgMyldXTtcbiAgICBjb25zdCBzaGlmdGVkID0gcm93VmFsdWVzLnNsaWNlKHJvdykuY29uY2F0KHJvd1ZhbHVlcy5zbGljZSgwLCByb3cpKTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA0OyBjb2wrKykge1xuICAgICAgcmVzdWx0W2lkeChyb3csIGNvbCldID0gc2hpZnRlZFtjb2xdO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIE1peENvbHVtbnMgb3BlcmF0aW9uIC0gbWl4IGRhdGEgd2l0aGluIGNvbHVtbnNcbmV4cG9ydCBjb25zdCBtaXhDb2x1bW5zID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gWy4uLnN0YXRlXTtcbiAgY29uc3QgaWR4ID0gKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4gcm93ICsgNCAqIGNvbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBzMCA9IHN0YXRlW2lkeCgwLCBpKV07XG4gICAgY29uc3QgczEgPSBzdGF0ZVtpZHgoMSwgaSldO1xuICAgIGNvbnN0IHMyID0gc3RhdGVbaWR4KDIsIGkpXTtcbiAgICBjb25zdCBzMyA9IHN0YXRlW2lkeCgzLCBpKV07XG4gICAgXG4gICAgcmVzdWx0W2lkeCgwLCBpKV0gPSBHQUxPSVNfTVVMXzJbczBdIF4gR0FMT0lTX01VTF8zW3MxXSBeIHMyIF4gczM7XG4gICAgcmVzdWx0W2lkeCgxLCBpKV0gPSBzMCBeIEdBTE9JU19NVUxfMltzMV0gXiBHQUxPSVNfTVVMXzNbczJdIF4gczM7XG4gICAgcmVzdWx0W2lkeCgyLCBpKV0gPSBzMCBeIHMxIF4gR0FMT0lTX01VTF8yW3MyXSBeIEdBTE9JU19NVUxfM1tzM107XG4gICAgcmVzdWx0W2lkeCgzLCBpKV0gPSBHQUxPSVNfTVVMXzNbczBdIF4gczEgXiBzMiBeIEdBTE9JU19NVUxfMltzM107XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEFkZFJvdW5kS2V5IG9wZXJhdGlvbiAtIFhPUiBzdGF0ZSB3aXRoIHJvdW5kIGtleVxuZXhwb3J0IGNvbnN0IGFkZFJvdW5kS2V5ID0gKHN0YXRlOiBudW1iZXJbXSwgcm91bmRLZXk6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICByZXR1cm4gc3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gcm91bmRLZXlbaV0pO1xufTtcblxuLy8gS2FsaXRuaSBrZW5nYXl0aXJpc2gg4oCUIHJhdW5kIGthbGl0bGFyaW5pIGdlbmVyYXRzaXlhIHFpbGlzaFxuZXhwb3J0IGNvbnN0IGtleUV4cGFuc2lvbiA9IChrZXk6IG51bWJlcltdLCBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4KTogbnVtYmVyW11bXSA9PiB7XG4gIGNvbnN0IHJlcXVpcmVkQnl0ZXMgPSBnZXRLZXlCeXRlTGVuZ3RoKGtleUxlbmd0aCk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc2xpY2UoMCwgcmVxdWlyZWRCeXRlcyk7XG4gIHdoaWxlIChub3JtYWxpemVkS2V5Lmxlbmd0aCA8IHJlcXVpcmVkQnl0ZXMpIHtcbiAgICBub3JtYWxpemVkS2V5LnB1c2goMCk7XG4gIH1cblxuICBjb25zdCBrZXlXb3JkcyA9IG5vcm1hbGl6ZWRLZXkubGVuZ3RoIC8gNDtcbiAgY29uc3QgbnVtUm91bmRzID0gZ2V0TnVtUm91bmRzKGtleUxlbmd0aCk7XG4gIFxuICBjb25zdCByb3VuZEtleXM6IG51bWJlcltdW10gPSBbbm9ybWFsaXplZEtleS5zbGljZSgpXTsgLy8gMS1yYXVuZCBrYWxpdGkgYm9zaGxhbmfigJhpY2gga2FsaXRuaW5nIG/igJh6aSBoaXNvYmxhbmFkaVxuICBcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICBjb25zdCBwcmV2S2V5ID0gcm91bmRLZXlzW3JvdW5kIC0gMV07XG4gICAgY29uc3QgbmV3S2V5ID0gcHJldktleS5zbGljZSgpO1xuICAgIFxuICAgIC8vIE94aXJnaSB3b3JkIG5pIGF5bGFudGlyaWIsIFMtYm94IG5pIHFv4oCYbGxhbmdcbiAgICBjb25zdCBsYXN0SW5kZXggPSBwcmV2S2V5Lmxlbmd0aCAtIDQ7XG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVtsYXN0SW5kZXhdLCBwcmV2S2V5W2xhc3RJbmRleCArIDFdLCBwcmV2S2V5W2xhc3RJbmRleCArIDJdLCBwcmV2S2V5W2xhc3RJbmRleCArIDNdXTtcbiAgICBjb25zdCByb3RXb3JkID0gW2xhc3RXb3JkWzFdLCBsYXN0V29yZFsyXSwgbGFzdFdvcmRbM10sIGxhc3RXb3JkWzBdXTtcbiAgICBjb25zdCBzdWJXb3JkID0gcm90V29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICBcbiAgICAvLyBCaXJpbmNoaSBiYXl0bmkgUmNvbiBiaWxhbiBYT1IgcWlsaW5hZGlcbiAgICBzdWJXb3JkWzBdIF49IFJDT05bcm91bmRdO1xuICAgIFxuICAgIC8vIFlhbmdpIGthbGl0bmluZyBiaXJpbmNoaSB3b3JkIGkgZ2VuZXJhdHNpeWEgcWlsaW5hZGlcbiAgICBuZXdLZXlbMF0gPSBwcmV2S2V5WzBdIF4gc3ViV29yZFswXTtcbiAgICBuZXdLZXlbMV0gPSBwcmV2S2V5WzFdIF4gc3ViV29yZFsxXTtcbiAgICBuZXdLZXlbMl0gPSBwcmV2S2V5WzJdIF4gc3ViV29yZFsyXTtcbiAgICBuZXdLZXlbM10gPSBwcmV2S2V5WzNdIF4gc3ViV29yZFszXTtcbiAgICBcbiAgICAvLyBRb2xnYW4gd29yZCBsYXIgaG9zaWwgcWlsaW5hZGlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleVdvcmRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuICAgICAgLy8gQUVTLTI1NiBob2xhdGlkYSBoYXIgdG/igJhydGluY2hpIHdvcmQgZ2EgcW/igJhzaGltY2hhIFMtYm94IChTdWJXb3JkKSBxb+KAmGxsYW5hZGlcbiAgICAgIGlmIChrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMjU2ICYmIGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgdGVtcFdvcmQgPSBbbmV3S2V5W29mZnNldCAtIDRdLCBuZXdLZXlbb2Zmc2V0IC0gM10sIG5ld0tleVtvZmZzZXQgLSAyXSwgbmV3S2V5W29mZnNldCAtIDFdXTtcbiAgICAgICAgY29uc3Qgc3ViVGVtcFdvcmQgPSB0ZW1wV29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICAgICAgXG4gICAgICAgIG5ld0tleVtvZmZzZXRdID0gcHJldktleVtvZmZzZXRdIF4gc3ViVGVtcFdvcmRbMF07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAxXSA9IHByZXZLZXlbb2Zmc2V0ICsgMV0gXiBzdWJUZW1wV29yZFsxXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gcHJldktleVtvZmZzZXQgKyAyXSBeIHN1YlRlbXBXb3JkWzJdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgM10gPSBwcmV2S2V5W29mZnNldCArIDNdIF4gc3ViVGVtcFdvcmRbM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdLZXlbb2Zmc2V0XSA9IG5ld0tleVtvZmZzZXQgLSA0XSBeIHByZXZLZXlbb2Zmc2V0XTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDFdID0gbmV3S2V5W29mZnNldCAtIDNdIF4gcHJldktleVtvZmZzZXQgKyAxXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gbmV3S2V5W29mZnNldCAtIDJdIF4gcHJldktleVtvZmZzZXQgKyAyXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDNdID0gbmV3S2V5W29mZnNldCAtIDFdIF4gcHJldktleVtvZmZzZXQgKyAzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcm91bmRLZXlzLnB1c2gobmV3S2V5KTtcbiAgfVxuICBcbiAgcmV0dXJuIHJvdW5kS2V5cztcbn07XG5cbi8vIFBlcmZvcm0gb25lIHJvdW5kIG9mIEFFU1xuZXhwb3J0IGNvbnN0IGFlc1JvdW5kID0gKHN0YXRlOiBudW1iZXJbXSwgcm91bmRLZXk6IG51bWJlcltdLCBpc0xhc3RSb3VuZDogYm9vbGVhbik6IG51bWJlcltdID0+IHtcbiAgbGV0IG5ld1N0YXRlID0gc3ViQnl0ZXMoc3RhdGUpO1xuICBuZXdTdGF0ZSA9IHNoaWZ0Um93cyhuZXdTdGF0ZSk7XG4gIGlmICghaXNMYXN0Um91bmQpIHtcbiAgICBuZXdTdGF0ZSA9IG1peENvbHVtbnMobmV3U3RhdGUpO1xuICB9XG4gIG5ld1N0YXRlID0gYWRkUm91bmRLZXkobmV3U3RhdGUsIHJvdW5kS2V5KTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLy8gQ29tcGxldGUgQUVTIGVuY3J5cHRpb25cbmV4cG9ydCBjb25zdCBhZXNFbmNyeXB0ID0gKHBsYWludGV4dDogc3RyaW5nLCBrZXk6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICAvLyBJbml0aWFsIHN0YXRlXG4gIGNvbnN0IHN0YXRlID0gdGV4dFRvU3RhdGUocGxhaW50ZXh0KTtcbiAgXG4gIC8vIEtleSBleHBhbnNpb25cbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSk7XG4gIFxuICAvLyBJbml0aWFsIHJvdW5kIC0ganVzdCBBZGRSb3VuZEtleVxuICBsZXQgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoc3RhdGUsIHJvdW5kS2V5c1swXSk7XG4gIFxuICAvLyBNYWluIHJvdW5kc1xuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IDEwOyByb3VuZCsrKSB7XG4gICAgY3VycmVudFN0YXRlID0gYWVzUm91bmQoY3VycmVudFN0YXRlLCByb3VuZEtleXNbcm91bmRdLCByb3VuZCA9PT0gMTApO1xuICB9XG4gIFxuICByZXR1cm4gY3VycmVudFN0YXRlO1xufTtcblxuLy8gQ29udmVydCBmdWxsIHRleHQgdG8gYXJyYXkgb2YgMTYtYnl0ZSBibG9ja3NcbmV4cG9ydCBjb25zdCB0ZXh0VG9CbG9ja3MgPSAodGV4dDogc3RyaW5nLCBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3KTogbnVtYmVyW11bXSA9PiB7XG4gIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHRleHQpO1xuICBjb25zdCBieXRlczogbnVtYmVyW10gPSBbXTtcbiAgXG4gIC8vIENvbnZlcnQgQ3J5cHRvSlMgV29yZEFycmF5IHRvIGJ5dGUgYXJyYXksIHJlc3BlY3Rpbmcgc2lnQnl0ZXNcbiAgY29uc3Qgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZEFycmF5LndvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgd29yZCA9IHdvcmRBcnJheS53b3Jkc1tpXTtcbiAgICBjb25zdCBieXRlc0luVGhpc1dvcmQgPSBNYXRoLm1pbig0LCBzaWdCeXRlcyAtIGkgKiA0KTtcbiAgICBcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDEpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMikgYnl0ZXMucHVzaCgod29yZCA+Pj4gMTYpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAzKSBieXRlcy5wdXNoKCh3b3JkID4+PiA4KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gNCkgYnl0ZXMucHVzaCh3b3JkICYgMHhmZik7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IHBhZGRpbmdcbiAgbGV0IHBhZGRlZEJ5dGVzOiBudW1iZXJbXTtcbiAgaWYgKHBhZGRpbmcgPT09IFBhZGRpbmdUeXBlLlBLQ1M3KSB7XG4gICAgcGFkZGVkQnl0ZXMgPSBhcHBseVBLQ1M3UGFkZGluZyhieXRlcyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuQU5TSV9YOTIzKSB7XG4gICAgcGFkZGVkQnl0ZXMgPSBhcHBseUFuc2lYOTIzUGFkZGluZyhieXRlcyk7XG4gIH0gZWxzZSB7IC8vIE5PTkVcbiAgICBwYWRkZWRCeXRlcyA9IFsuLi5ieXRlc107XG4gICAgLy8gRm9yIE5PTkUgcGFkZGluZywgbXVzdCBiZSBtdWx0aXBsZSBvZiAxNlxuICAgIHdoaWxlIChwYWRkZWRCeXRlcy5sZW5ndGggJSAxNiAhPT0gMCkge1xuICAgICAgcGFkZGVkQnl0ZXMucHVzaCgwKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNwbGl0IGludG8gMTYtYnl0ZSBibG9ja3NcbiAgY29uc3QgYmxvY2tzOiBudW1iZXJbXVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQnl0ZXMubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgYmxvY2tzLnB1c2gocGFkZGVkQnl0ZXMuc2xpY2UoaSwgaSArIDE2KSk7XG4gIH1cbiAgXG4gIHJldHVybiBibG9ja3M7XG59O1xuXG4vLyBBcHBseSBQS0NTNyBwYWRkaW5nXG5leHBvcnQgY29uc3QgYXBwbHlQS0NTN1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRlZCA9IFsuLi5kYXRhXTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nTGVuZ3RoOyBpKyspIHtcbiAgICBwYWRkZWQucHVzaChwYWRkaW5nTGVuZ3RoKTtcbiAgfVxuICBcbiAgcmV0dXJuIHBhZGRlZDtcbn07XG5cbi8vIEFwcGx5IEFOU0kgWC45MjMgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IGFwcGx5QW5zaVg5MjNQYWRkaW5nID0gKGRhdGE6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBwYWRkZWQgPSBbLi4uZGF0YV07XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcbiAgXG4gIC8vIEFkZCBwYWRkaW5nIGJ5dGVzICgweDAwKSBleGNlcHQgdGhlIGxhc3QgYnl0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmdMZW5ndGggLSAxOyBpKyspIHtcbiAgICBwYWRkZWQucHVzaCgweDAwKTtcbiAgfVxuICBcbiAgLy8gQWRkIHRoZSBwYWRkaW5nIGxlbmd0aCBhcyB0aGUgbGFzdCBieXRlXG4gIHBhZGRlZC5wdXNoKHBhZGRpbmdMZW5ndGgpO1xuICBcbiAgcmV0dXJuIHBhZGRlZDtcbn07XG5cbi8vIFJlbW92ZSBBTlNJIFguOTIzIHBhZGRpbmdcbmV4cG9ydCBjb25zdCByZW1vdmVBbnNpWDkyM1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gIHJldHVybiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aCk7XG59O1xuXG4vLyBHZXQgSVYgZm9yIENCQyBtb2RlXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJViA9ICgpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGl2ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGl2LnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gIH1cbiAgcmV0dXJuIGl2O1xufTtcblxuLy8gR2V0IGFsbCBpbnRlcm1lZGlhdGUgc3RhdGVzIGZvciB2aXN1YWxpemF0aW9uXG5leHBvcnQgdHlwZSBBZXNTdGVwID0ge1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBzdGF0ZTogbnVtYmVyW107XG4gIGFjdGl2ZUluZGljZXM/OiBudW1iZXJbXTsgIC8vIEZvciBoaWdobGlnaHRpbmcgc3BlY2lmaWMgY2VsbHNcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmc7ICAgICAgLy8gTW9yZSBkZXRhaWxlZCBleHBsYW5hdGlvblxuICByb3VuZEtleT86IG51bWJlcltdO1xuICBwcmV2aW91c1N0YXRlPzogbnVtYmVyW107ICAvLyBGb3Igc2hvd2luZyBiZWZvcmUvYWZ0ZXIgY29tcGFyaXNvblxufTtcblxuLy8gR2V0IEFFUyBzdGVwcyBmb3IgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKVxuZXhwb3J0IGNvbnN0IGdldEFlc1N0ZXBzRm9yQmxvY2sgPSAoXG4gIGJsb2NrOiBudW1iZXJbXSxcbiAga2V5OiBudW1iZXJbXSxcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBibG9ja0luZGV4OiBudW1iZXIgPSAwLFxuICBwcmV2aW91c0NpcGhlcnRleHRCbG9jaz86IG51bWJlcltdLFxuICBpdj86IG51bWJlcltdXG4pOiB7XG4gIHN0ZXBzOiBBZXNTdGVwW10sXG4gIGZpbmFsU3RhdGU6IG51bWJlcltdXG59ID0+IHtcbiAgY29uc3Qgc3RlcHM6IEFlc1N0ZXBbXSA9IFtdO1xuICBcbiAgLy8gRW5zdXJlIGJsb2NrIGlzIGV4YWN0bHkgMTYgYnl0ZXNcbiAgY29uc3QgcGxhaW50ZXh0Qnl0ZXMgPSBbLi4uYmxvY2tdO1xuICB3aGlsZSAocGxhaW50ZXh0Qnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICBwbGFpbnRleHRCeXRlcy5wdXNoKDApO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBBc2wgb2NoaXEgbWF0bmAsIFxuICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0gYmF5dGdhIGF5bGFudGlyaWxhZGkgdmEgNMOXNCBtYXRyaXRzYSBzaGFrbGlkYSBpZm9kYWxhbmFkaS5gXG4gIH0pO1xuICBcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGxhaW50ZXh0Qnl0ZXM7XG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXkpO1xuICBcbiAgbGV0IGN1cnJlbnRTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKGJsb2NrSW5kZXggPT09IDAgJiYgaXYpIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGl2W2ldKTtcbiAgICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgSVYgYmlsYW4gWE9SYCwgXG4gICAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgICByb3VuZEtleTogaXYsXG4gICAgICAgICAgZXhwbGFuYXRpb246IGBDQkM6IGJpcmluY2hpIGJsb2sgSVYgYmlsYW4gWE9SIHFpbGluYWRpLmBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBwcmV2aW91c0NpcGhlcnRleHRCbG9ja1tpXSk7XG4gICAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIE9sZGluZ2kgY2lwaGVydGV4dCBiaWxhbiBYT1JgLCBcbiAgICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHJvdW5kS2V5OiBwcmV2aW91c0NpcGhlcnRleHRCbG9jayxcbiAgICAgICAgICBleHBsYW5hdGlvbjogYENCQzoga2V5aW5naSBibG9rbGFyIG9sZGluZ2kgY2lwaGVydGV4dCBibG9raSBiaWxhbiBYT1IgcWlsaW5hZGkuYFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBpZiAoIWl2KSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBzOiBbXSwgZmluYWxTdGF0ZTogcGxhaW50ZXh0Qnl0ZXMgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvdW50ZXJCbG9jayA9IFsuLi5pdl07XG4gICAgICBsZXQgY291bnRlclZhbHVlID0gYmxvY2tJbmRleDtcbiAgICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwICYmIGNvdW50ZXJWYWx1ZSA+IDA7IGktLSkge1xuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyQmxvY2tbaV0gKyAoY291bnRlclZhbHVlICYgMHhmZik7XG4gICAgICAgIGNvdW50ZXJCbG9ja1tpXSA9IHN1bSAmIDB4ZmY7XG4gICAgICAgIGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyVmFsdWUgPj4gOCkgKyAoc3VtID4+IDgpO1xuICAgICAgfVxuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIENvdW50ZXJgLCBcbiAgICAgICAgc3RhdGU6IGNvdW50ZXJCbG9jayxcbiAgICAgICAgZXhwbGFuYXRpb246IGBDVFI6IGJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4gY291bnRlci5gXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGNvdW50ZXJCbG9jaztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIEJvc2hsYW5nJ2ljaGAsIFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBleHBsYW5hdGlvbjogYEVDQjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSBtdXN0YXFpbCBzaGlmcmxhbmFkaS5gXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBjb25zdCBhZnRlckluaXRpYWxSb3VuZCA9IGFkZFJvdW5kS2V5KGN1cnJlbnRTdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgMC1ib3NxaWNoIOKAlCBBZGRSb3VuZEtleWAsIFxuICAgIHN0YXRlOiBhZnRlckluaXRpYWxSb3VuZCxcbiAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICByb3VuZEtleTogcm91bmRLZXlzWzBdLFxuICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgfSk7XG4gIFxuICBjdXJyZW50U3RhdGUgPSBhZnRlckluaXRpYWxSb3VuZDtcbiAgXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICBjb25zdCBhZnRlclN1YkJ5dGVzID0gc3ViQnl0ZXMoY3VycmVudFN0YXRlKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFN1YkJ5dGVzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTdWJCeXRlcyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGVcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBhZnRlclNoaWZ0Um93cyA9IHNoaWZ0Um93cyhhZnRlclN1YkJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFNoaWZ0Um93c2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU2hpZnRSb3dzLFxuICAgICAgYWN0aXZlSW5kaWNlczogWzEsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMSwgMTMsIDE0LCAxNV0sXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclN1YkJ5dGVzXG4gICAgfSk7XG4gICAgXG4gICAgbGV0IHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleTogbnVtYmVyW107XG4gICAgXG4gICAgaWYgKHJvdW5kIDwgMTApIHtcbiAgICAgIGNvbnN0IGFmdGVyTWl4Q29sdW1ucyA9IG1peENvbHVtbnMoYWZ0ZXJTaGlmdFJvd3MpO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIE1peENvbHVtbnNgLCBcbiAgICAgICAgc3RhdGU6IGFmdGVyTWl4Q29sdW1ucyxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclNoaWZ0Um93c1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyTWl4Q29sdW1ucywgcm91bmRLZXlzW3JvdW5kXSk7XG4gICAgICBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkgPSBhZnRlck1peENvbHVtbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyU2hpZnRSb3dzLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyU2hpZnRSb3dzO1xuICAgIH1cbiAgICBcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHJvdW5kS2V5OiByb3VuZEtleXNbcm91bmRdLFxuICAgICAgcHJldmlvdXNTdGF0ZTogcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5LFxuICAgIH0pO1xuICB9XG4gIFxuICBsZXQgZmluYWxTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGluaXRpYWxTdGF0ZVtpXSk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQ291bnRlciBYT1JgLCBcbiAgICAgICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgQ1RSOiBibG9rICR7YmxvY2tJbmRleCArIDF9IHVjaHVuIGNvdW50ZXIgWE9SLmAsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcm91bmRLZXk6IGN1cnJlbnRTdGF0ZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBZYWt1bml5YCwgXG4gICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgZXhwbGFuYXRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IHVjaHVuIHlha3VuaXkgc2hpZnJsYW5nYW4gbmF0aWphLmBcbiAgfSk7XG4gIFxuICByZXR1cm4geyBzdGVwcywgZmluYWxTdGF0ZSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFlc1N0ZXBzID0gKFxuICBwbGFpbnRleHQ6IHN0cmluZywgXG4gIGtleTogbnVtYmVyW10sIFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcsXG4gIHByb3ZpZGVkSXY/OiBudW1iZXJbXVxuKToge1xuICBzdGVwczogQWVzU3RlcFtdLFxuICBmaW5hbENpcGhlcnRleHQ6IHtcbiAgICBiYXNlNjQ6IHN0cmluZztcbiAgICBoZXg6IHN0cmluZztcbiAgICBiaW5hcnk6IHN0cmluZztcbiAgfSxcbiAgaXY/OiBudW1iZXJbXSxcbiAgYWxsQmxvY2tzPzogeyBibG9ja0luZGV4OiBudW1iZXIsIHN0ZXBzOiBBZXNTdGVwW10sIGZpbmFsU3RhdGU6IG51bWJlcltdIH1bXVxufSA9PiB7XG4gIGNvbnN0IHN0ZXBzOiBBZXNTdGVwW10gPSBbXTtcbiAgbGV0IGl2OiBudW1iZXJbXSB8IHVuZGVmaW5lZCA9IHByb3ZpZGVkSXYgPyBbLi4ucHJvdmlkZWRJdl0gOiB1bmRlZmluZWQ7XG4gIFxuICAvLyBDb252ZXJ0IGZ1bGwgdGV4dCB0byBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gdGV4dFRvQmxvY2tzKHBsYWludGV4dCwgcGFkZGluZyk7XG4gIGNvbnN0IGFsbEJsb2NrczogeyBibG9ja0luZGV4OiBudW1iZXIsIHN0ZXBzOiBBZXNTdGVwW10sIGZpbmFsU3RhdGU6IG51bWJlcltdIH1bXSA9IFtdO1xuICBcbiAgLy8gQ29udmVydCBwbGFpbnRleHQgdG8gYnl0ZXMgKGZvciBmaXJzdCBibG9jayB2aXN1YWxpemF0aW9uKVxuICBsZXQgcGxhaW50ZXh0Qnl0ZXMgPSBibG9ja3NbMF0gfHwgdGV4dFRvU3RhdGUocGxhaW50ZXh0KTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiAnQXNsIG9jaGlxIG1hdG4nLCBcbiAgICBzdGF0ZTogcGxhaW50ZXh0Qnl0ZXMsXG4gICAgZXhwbGFuYXRpb246IGBPY2hpcSBtYXRuIFwiJHtwbGFpbnRleHR9XCIgYmF5dGdhIGF5bGFudGlyaWxhZGkgdmEgNMOXNCBtYXRyaXRzYSBzaGFrbGlkYSBpZm9kYWxhbmFkaS5gXG4gIH0pO1xuICBcbiAgLy8gQXBwbHkgcGFkZGluZyBpZiBuZWVkZWRcbiAgaWYgKHBhZGRpbmcgPT09IFBhZGRpbmdUeXBlLkFOU0lfWDkyMykge1xuICAgIHBsYWludGV4dEJ5dGVzID0gYXBwbHlBbnNpWDkyM1BhZGRpbmcocGxhaW50ZXh0Qnl0ZXMpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiAnQU5TSSBYLjkyMyB0b+KAmGxkaXJpc2hkYW4ga2V5aW4nLCBcbiAgICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICAgIGV4cGxhbmF0aW9uOiAnQU5TSSBYLjkyMyB0b+KAmGxkaXJpc2ggbm9sbGFyIGJpbGFuIHRv4oCYbGRpcmFkaSB2YSBveGlyZ2kgYnl0ZSBnYSB0b+KAmGxkaXJpc2ggdXp1bmxpZ2luaSBxb+KAmHlhZGkuJ1xuICAgIH0pO1xuICB9XG4gIFxuICAvLyBHZW5lcmF0ZSBJViBmb3IgQ0JDL0NUUiBtb2RlIG9ubHkgaWYgbm90IHByb3ZpZGVkXG4gIGlmICgobW9kZSA9PT0gQWVzTW9kZS5DQkMgfHwgbW9kZSA9PT0gQWVzTW9kZS5DVFIpICYmICFpdikge1xuICAgIGl2ID0gZ2VuZXJhdGVJVigpO1xuICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBPbmx5IHNob3cgSVYgc3RlcCBpZiBzaW5nbGUgYmxvY2sgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgY29uc3QgaXZEZXNjcmlwdGlvbiA9IG1vZGUgPT09IEFlc01vZGUuQ0JDIFxuICAgICAgICA/ICdCb3NobGFuZ1xcJ2ljaCB2ZWt0b3IgKEluaXRpYWxpemF0aW9uIFZlY3RvciwgSVYpJyBcbiAgICAgICAgOiAnQ291bnRlciAoTm9uY2UpJztcbiAgICAgIGNvbnN0IGl2RXhwbGFuYXRpb24gPSBgJHttb2RlID09PSBBZXNNb2RlLkNCQyA/ICdDQkMnIDogJ0NUUid9IHJlamltaSB1Y2h1biAxNi1iYXl0IHRhc29kaWZpeSAke21vZGUgPT09IEFlc01vZGUuQ0JDID8gJ0lWJyA6ICdOb25jZSd9IHlhcmF0aWxhZGkuYDtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGl2RGVzY3JpcHRpb24sXG4gICAgICAgIHN0YXRlOiBpdixcbiAgICAgICAgZXhwbGFuYXRpb246IGl2RXhwbGFuYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RhcnQgZW5jcnlwdGlvbiBwcm9jZXNzIChmb3IgZmlyc3QgYmxvY2sgdmlzdWFsaXphdGlvbilcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGxhaW50ZXh0Qnl0ZXM7XG4gIFxuICAvLyBLZXkgZXhwYW5zaW9uXG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXkpO1xuICBcbiAgLy8gSW5pdGlhbCBzZXR1cCBiYXNlZCBvbiBtb2RlXG4gIGxldCBjdXJyZW50U3RhdGU6IG51bWJlcltdO1xuICBcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgIGlmICghaXYpIGl2ID0gZ2VuZXJhdGVJVigpOyAvLyBGYWlsc2FmZVxuICAgICAgLy8gWE9SIHBsYWludGV4dCB3aXRoIElWXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaXYhW2ldKVxuXG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQm9zaGxhbmdcXCdpY2ggaG9sYXRuaSBJViBiaWxhbiBYT1IgcWlsaXNoJywgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcm91bmRLZXk6IGl2LCAvLyBJViBuaSByb3VuZEtleSBzaWZhdGlkYSBrbydyc2F0aXNoIHVjaHVuXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgQ0JDIHJlamltaWRhIHNoaWZybGFzaCBib3NobGFuaXNoaWRhbiBvbGRpbiBvY2hpcSBtYXRuIElWIGJpbGFuIFhPUiBxaWxpbmFkaS4gQnUgamFyYXlvbiBDQkMgcmVqaW1pbmluZyBhc29zaXkgeHVzdXNpeWF0aWRpciAtIGhhciBiaXIgb2NoaXEgbWF0biBibG9raSBhdnZhbGdpIHNoaWZybGFuZ2FuIG1hdG4gYmxva2kgKHlva2kgYmlyaW5jaGkgYmxvayB1Y2h1biBJVikgYmlsYW4gWE9SIHFpbGluYWRpLCBrZXlpbiBzaGlmcmxhbmFkaS4gQnUgYmlyIHhpbCBvY2hpcSBtYXRuIGJsb2tsYXJpbmkgdHVybGkgc2hpZnJsYW5nYW4gbWF0biBibG9rbGFyZ2EgYXlsYW50aXJhZGkgdmEgc2hpZnJsYW5nYW4gbWF0bmRhZ2kgbmFxc2hsYXJuaSB5YXNoaXJpc2hnYSB5b3JkYW0gYmVyYWRpLmBcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIC8vIEluIENUUiBtb2RlLCB3ZSBlbmNyeXB0IGEgY291bnRlciB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBwbGFpbnRleHRcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBpdiB8fCBnZW5lcmF0ZUlWKCk7XG4gICAgICBpZiAoIWl2KSBpdiA9IGNvdW50ZXI7XG4gICAgICBcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3VudGVyIHFpeW1hdGknLCBcbiAgICAgICAgc3RhdGU6IGNvdW50ZXIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQ1RSIHJlamltaWRhIG9jaGlxIG1hdG4gb+KAmHJuaWdhIGNvdW50ZXIgcWl5bWF0aSBzaGlmcmxhbmFkaS4nXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY3VycmVudFN0YXRlID0gY291bnRlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Jvc2hsYW5n4oCYaWNoIGhvbGF0IChvY2hpcSBtYXRuKScsIFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0VDQiByZWppbWlkYSBvY2hpcSBtYXRuIGJsb2tsYXJpIG11c3RhcWlsIHJhdmlzaGRhIHNoaWZybGFuYWRpLidcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIC8vIEluaXRpYWwgcm91bmQgLSBqdXN0IEFkZFJvdW5kS2V5IChSb3VuZCAwKVxuICBjb25zdCBhZnRlckluaXRpYWxSb3VuZCA9IGFkZFJvdW5kS2V5KGN1cnJlbnRTdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiAnMC1ib3NxaWNoIOKAlCBCb3NobGFuZ1xcJ2ljaCBBZGRSb3VuZEtleScsIFxuICAgIHN0YXRlOiBhZnRlckluaXRpYWxSb3VuZCxcbiAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICByb3VuZEtleTogcm91bmRLZXlzWzBdLFxuICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgfSk7XG4gIFxuICBjdXJyZW50U3RhdGUgPSBhZnRlckluaXRpYWxSb3VuZDtcbiAgXG4gIC8vIE1haW4gcm91bmRzXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICAvLyBTdWJCeXRlc1xuICAgIGNvbnN0IGFmdGVyU3ViQnl0ZXMgPSBzdWJCeXRlcyhjdXJyZW50U3RhdGUpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgU3ViQnl0ZXNgLCBcbiAgICAgIHN0YXRlOiBhZnRlclN1YkJ5dGVzLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIFMtYm94IGxvb2t1cFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNoaWZ0Um93c1xuICAgIGNvbnN0IGFmdGVyU2hpZnRSb3dzID0gc2hpZnRSb3dzKGFmdGVyU3ViQnl0ZXMpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgU2hpZnRSb3dzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTaGlmdFJvd3MsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBbMSwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExLCAxMywgMTQsIDE1XSwgLy8gUm93cyAxLCAyLCAzIChub3QgUm93IDApIGluIGNvbHVtbi1tYWpvclxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTdWJCeXRlcyAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIGNvbXBhcmlzb25cbiAgICB9KTtcbiAgICBcbiAgICBsZXQgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5OiBudW1iZXJbXTtcbiAgICBcbiAgICBpZiAocm91bmQgPCAxMCkge1xuICAgICAgLy8gTWl4Q29sdW1ucyAobm90IGluIGZpbmFsIHJvdW5kKVxuICAgICAgY29uc3QgYWZ0ZXJNaXhDb2x1bW5zID0gbWl4Q29sdW1ucyhhZnRlclNoaWZ0Um93cyk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgTWl4Q29sdW1uc2AsIFxuICAgICAgICBzdGF0ZTogYWZ0ZXJNaXhDb2x1bW5zLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGFmdGVyU2hpZnRSb3dzIC8vIEFkZCBwcmV2aW91cyBzdGF0ZSBmb3IgTWl4Q29sdW1ucyBjb21wYXJpc29uXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQWRkUm91bmRLZXlcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyTWl4Q29sdW1ucywgcm91bmRLZXlzW3JvdW5kXSk7XG4gICAgICBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkgPSBhZnRlck1peENvbHVtbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsIHJvdW5kIGhhcyBubyBNaXhDb2x1bW5zXG4gICAgICBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShhZnRlclNoaWZ0Um93cywgcm91bmRLZXlzW3JvdW5kXSk7XG4gICAgICBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkgPSBhZnRlclNoaWZ0Um93cztcbiAgICB9XG4gICAgXG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGAke3JvdW5kfS1ib3NxaWNoIOKAlCBBZGRSb3VuZEtleWAsIFxuICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICByb3VuZEtleTogcm91bmRLZXlzW3JvdW5kXSxcbiAgICAgIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSxcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gRmluYWwgb3V0cHV0IGJhc2VkIG9uIG1vZGVcbiAgbGV0IGZpbmFsU3RhdGU6IG51bWJlcltdO1xuICBcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgIC8vIE91dHB1dCBpcyB0aGUgY3VycmVudCBzdGF0ZSAoYWxyZWFkeSBjb21wbGV0ZWQgZW5jcnlwdGlvbilcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgLy8gWE9SIHRoZSBlbmNyeXB0ZWQgY291bnRlciB3aXRoIHBsYWludGV4dFxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBpbml0aWFsU3RhdGVbaV0pO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09jaGlxIG1hdG4gc2hpZnJsYW5nYW4gaGlzb2JsYWdpY2ggYmlsYW4gWE9SIGFtYWxpeW90aWRhIGJpcmxhc2h0aXJpbGFkaS4nLCBcbiAgICAgICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQ1RSIHJlamltaWRhLCB5YWt1bml5IGJvc3FpY2hkYSBzaGlmcmxhbmdhbiBoaXNvYmxhZ2ljaCBvY2hpcSBtYXRuIGJpbGFuIFhPUiBhbWFsaXlvdGkgb3JxYWxpIGJpcmxhc2h0aXJpbGFkaSB2YSBuYXRpamFkYSBzaGlmcmxhbmdhbiBtYXRuIGhvc2lsIGJv4oCYbGFkaS4nLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgIHJvdW5kS2V5OiBjdXJyZW50U3RhdGVcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogJ1lha3VuaXkgc2hpZnJsYW5nYW4gbWF0bicsIFxuICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgIGV4cGxhbmF0aW9uOiBgJHttb2RlfSByZWppbWlkYSBBRVMtMTI4IHlvcmRhbWlkYSBvbGluZ2FuIHlha3VuaXkgc2hpZnJsYW5nYW4gbmF0aWphLmBcbiAgfSk7XG4gIFxuICAvLyBQcm9jZXNzIGFsbCBibG9ja3MgZm9yIG11bHRpLWJsb2NrIHN1cHBvcnRcbiAgbGV0IHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrOiBudW1iZXJbXSB8IHVuZGVmaW5lZDtcbiAgY29uc3QgY29tYmluZWRGaW5hbFN0YXRlczogbnVtYmVyW10gPSBbXTtcbiAgXG4gIC8vIEdlbmVyYXRlIElWIGlmIG5lZWRlZFxuICBpZiAoKG1vZGUgPT09IEFlc01vZGUuQ0JDIHx8IG1vZGUgPT09IEFlc01vZGUuQ1RSKSAmJiAhaXYpIHtcbiAgICBpdiA9IGdlbmVyYXRlSVYoKTtcbiAgfVxuICBcbiAgZm9yIChsZXQgYmxvY2tJbmRleCA9IDA7IGJsb2NrSW5kZXggPCBibG9ja3MubGVuZ3RoOyBibG9ja0luZGV4KyspIHtcbiAgICBjb25zdCBibG9ja1Jlc3VsdCA9IGdldEFlc1N0ZXBzRm9yQmxvY2soXG4gICAgICBibG9ja3NbYmxvY2tJbmRleF0sXG4gICAgICBrZXksXG4gICAgICBtb2RlLFxuICAgICAgYmxvY2tJbmRleCxcbiAgICAgIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrLFxuICAgICAgaXZcbiAgICApO1xuICAgIFxuICAgIGFsbEJsb2Nrcy5wdXNoKHtcbiAgICAgIGJsb2NrSW5kZXgsXG4gICAgICBzdGVwczogYmxvY2tSZXN1bHQuc3RlcHMsXG4gICAgICBmaW5hbFN0YXRlOiBibG9ja1Jlc3VsdC5maW5hbFN0YXRlXG4gICAgfSk7XG4gICAgXG4gICAgY29tYmluZWRGaW5hbFN0YXRlcy5wdXNoKC4uLmJsb2NrUmVzdWx0LmZpbmFsU3RhdGUpO1xuICAgIFxuICAgIC8vIEZvciBDQkMgbW9kZSwgdXNlIGN1cnJlbnQgY2lwaGVydGV4dCBhcyBwcmV2aW91cyBmb3IgbmV4dCBibG9ja1xuICAgIGlmIChtb2RlID09PSBBZXNNb2RlLkNCQykge1xuICAgICAgcHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2sgPSBibG9ja1Jlc3VsdC5maW5hbFN0YXRlO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gVXNlIGNvbWJpbmVkIGZpbmFsIHN0YXRlcyBpZiB3ZSBoYXZlIG11bHRpcGxlIGJsb2Nrcywgb3RoZXJ3aXNlIHVzZSBzaW5nbGUgYmxvY2sgcmVzdWx0XG4gIGNvbnN0IGZpbmFsU3RhdGVUb1VzZSA9IGJsb2Nrcy5sZW5ndGggPiAxID8gY29tYmluZWRGaW5hbFN0YXRlcyA6IGZpbmFsU3RhdGU7XG4gIFxuICAvLyBDb252ZXJ0IHRoZSBmaW5hbCBzdGF0ZSB0byB0aGUgcmVxdWVzdGVkIG91dHB1dCBmb3JtYXRcbiAgY29uc3QgZmluYWxXb3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShcbiAgICBuZXcgVWludDhBcnJheShmaW5hbFN0YXRlVG9Vc2UpIGFzIGFueVxuICApO1xuICBcbiAgY29uc3QgZmluYWxDaXBoZXJ0ZXh0QmFzZTY0ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkoZmluYWxXb3JkQXJyYXkpO1xuICBjb25zdCBmaW5hbENpcGhlcnRleHRIZXggPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeShmaW5hbFdvcmRBcnJheSk7XG4gIGNvbnN0IGZpbmFsQ2lwaGVydGV4dEJpbmFyeSA9IGJ5dGVzVG9CaW5hcnkoZmluYWxTdGF0ZVRvVXNlLCAnJyk7XG4gIFxuICByZXR1cm4geyBcbiAgICBzdGVwcywgXG4gICAgZmluYWxDaXBoZXJ0ZXh0OiB7XG4gICAgICBiYXNlNjQ6IGZpbmFsQ2lwaGVydGV4dEJhc2U2NCxcbiAgICAgIGhleDogZmluYWxDaXBoZXJ0ZXh0SGV4LFxuICAgICAgYmluYXJ5OiBmaW5hbENpcGhlcnRleHRCaW5hcnlcbiAgICB9LCBcbiAgICBpdixcbiAgICBhbGxCbG9ja3M6IGFsbEJsb2Nrcy5sZW5ndGggPiAxID8gYWxsQmxvY2tzIDogdW5kZWZpbmVkXG4gIH07XG59O1xuXG4vLyBHZXQga2V5IGV4cGFuc2lvbiBzdGVwcyB3aXRoIGRldGFpbGVkIGV4cGxhbmF0aW9uc1xuZXhwb3J0IGNvbnN0IGdldEtleUV4cGFuc2lvblN0ZXBzID0gKGtleTogbnVtYmVyW10pOiB7IFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLCBcbiAga2V5OiBudW1iZXJbXSxcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmcsXG4gIGhpZ2hsaWdodGVkQ2VsbHM/OiBudW1iZXJbXVxufVtdID0+IHtcbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSk7XG4gIGNvbnN0IHN0ZXBzID0gW107XG4gIFxuICBzdGVwcy5wdXNoKHtcbiAgICBkZXNjcmlwdGlvbjogJ0Jvc2hsYW5n4oCYaWNoIGthbGl0JyxcbiAgICBrZXk6IHJvdW5kS2V5c1swXSxcbiAgICBleHBsYW5hdGlvbjogJ0J1IGZveWRhbGFudXZjaGkgdG9tb25pZGFuIGJlcmlsZ2FuIGFzbCAxMjgtYml0bGkga2FsaXRkaXIuJ1xuICB9KTtcbiAgXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICBjb25zdCBwcmV2S2V5ID0gcm91bmRLZXlzW3JvdW5kIC0gMV07XG4gICAgY29uc3QgY3VycmVudEtleSA9IHJvdW5kS2V5c1tyb3VuZF07XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGEgbW9yZSBkZXRhaWxlZCBleHBsYW5hdGlvblxuICAgIGNvbnN0IGxhc3RXb3JkID0gW3ByZXZLZXlbMTJdLCBwcmV2S2V5WzEzXSwgcHJldktleVsxNF0sIHByZXZLZXlbMTVdXTtcbiAgICBjb25zdCByb3RXb3JkID0gW2xhc3RXb3JkWzFdLCBsYXN0V29yZFsyXSwgbGFzdFdvcmRbM10sIGxhc3RXb3JkWzBdXTtcbiAgICBjb25zdCBzYm94V29yZCA9IHJvdFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgY29uc3QgcmNvblZhbHVlID0gUkNPTltyb3VuZF07XG4gICAgY29uc3QgdHJhbnNmb3JtZWRXb3JkID0gWy4uLnNib3hXb3JkXTtcbiAgICB0cmFuc2Zvcm1lZFdvcmRbMF0gXj0gcmNvblZhbHVlO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgcHJldmlvdXMga2V5IGFuZCBpdHMgWE9SIHdpdGggdGhlIHRyYW5zZm9ybWVkIHdvcmRcbiAgICBjb25zdCBmaXJzdFdvcmRQcmV2ID0gW3ByZXZLZXlbMF0sIHByZXZLZXlbMV0sIHByZXZLZXlbMl0sIHByZXZLZXlbM11dO1xuICAgIGNvbnN0IHhvclJlc3VsdCA9IGZpcnN0V29yZFByZXYubWFwKChieXRlLCBpbmRleCkgPT4gYnl0ZSBeIHRyYW5zZm9ybWVkV29yZFtpbmRleF0pO1xuXG5cbiAgICAvLyBTaG93IHRoZSBrZXkgd2l0aCBoaWdobGlnaHRlZCBjZWxscyBmb3IgdGhlIG5ldyB3b3JkXG4gICAgc3RlcHMucHVzaCh7XG4gICAgICBkZXNjcmlwdGlvbjogYFJhdW5kIGthbGl0aSAke3JvdW5kfWAsXG4gICAgICBrZXk6IGN1cnJlbnRLZXksXG4gICAgICBleHBsYW5hdGlvbjogYFxuICAgICAgICAke3JvdW5kfS1yYXVuZCB1Y2h1biBrYWxpdG5pIGtlbmdheXRpcmlzaCBqYXJheW9uaTpcbiAgICAgICAgMS4gT2xkaW5naSBrYWxpdG5pbmcgb3hpcmdpIHdvcmQgcWlzbWluaSBvbGluZzogWyR7bGFzdFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDIuIFdvcmRuaSBheWxhbnRpcmluZzogWyR7cm90V29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgMy4gQXlsYW50aXJpbGdhbiB3b3JkIGdhIFMtYm94IG5pIHFv4oCYbGxhbmc6IFske3Nib3hXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICA0LiBCaXJpbmNoaSBiYXl0Z2EgUkNPTiAoUm91bmQgQ29uc3RhbnQgJHtyY29uVmFsdWUudG9TdHJpbmcoMTYpfSkgbmkgcW/igJhsbGFuZzpcbiAgICAgICAgICBOYXRpamE6IFske3RyYW5zZm9ybWVkV29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgNS4gT2xkaW5naSBrYWxpdG5pbmcgYmlyaW5jaGkgd29yZCBpOiBbJHtmaXJzdFdvcmRQcmV2Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XSBuaSBv4oCYemdhcnRpcmlsZ2FuIHdvcmQgYmlsYW4gWE9SIHFpbGluZzogWyR7dHJhbnNmb3JtZWRXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XSwgbmF0aWphZGE6IFske3hvclJlc3VsdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV0gaG9zaWwgYm/igJhsYWRpLiBTb+KAmG5ncmEgcW9sZ2FuIHdvcmQgbGFyIHNodSB0YXJ6ZGEgaG9zaWwgcWlsaW5hZGkuXG4gICAgICBgLFxuICAgICAgaGlnaGxpZ2h0ZWRDZWxsczogWzAsIDEsIDIsIDNdIC8vIEhpZ2hsaWdodCB0aGUgZmlyc3Qgd29yZCB0aGF0J3MgZGlyZWN0bHkgdHJhbnNmb3JtZWRcbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIHN0ZXBzO1xufTtcblxuLy8gUmV0dXJuIGludGVybWVkaWF0ZSBzdGVwcyBmb3IgZWFjaCB3b3JkIGV4cGFuc2lvbiBmb3IgdmlzdWFsaXphdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVNjaGVkdWxlRGV0YWlsZWRTdGVwcyhrZXk6IG51bWJlcltdLCBrZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCkge1xuICBjb25zdCBrZXlXb3JkcyA9IGtleS5sZW5ndGggLyA0O1xuICBjb25zdCBudW1Sb3VuZHMgPSBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTI4ID8gMTAgOiBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTkyID8gMTIgOiAxNDtcblxuICAvLyBGbGF0dGVuIGJ5dGUgYXJyYXkgLT4gd29yZHNcbiAgbGV0IHByZXZLZXkgPSBrZXkuc2xpY2UoKTtcbiAgbGV0IHJvdW5kS2V5cyA9IFtwcmV2S2V5LnNsaWNlKCldO1xuXG4gIC8vIEZvciByZXN1bHQgdmlzdWFsaXphdGlvbjogZWFjaCBzdGVwIGZvciBlYWNoIHJvdW5kXG4gIGxldCBzdGVwc1BlclJvdW5kID0gW107XG5cbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICBsZXQgc3RlcERldGFpbHMgPSBbXTtcbiAgICBsZXQgbmV3S2V5ID0gcHJldktleS5zbGljZSgpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHByZXZLZXkubGVuZ3RoIC0gNDtcbiAgICBjb25zdCBsYXN0V29yZCA9IFtwcmV2S2V5W2xhc3RJbmRleF0sIHByZXZLZXlbbGFzdEluZGV4ICsgMV0sIHByZXZLZXlbbGFzdEluZGV4ICsgMl0sIHByZXZLZXlbbGFzdEluZGV4ICsgM11dO1xuXG4gICAgLy8gU3RlcCAxOiBSb3RXb3JkXG4gICAgY29uc3Qgcm90V29yZCA9IFtsYXN0V29yZFsxXSwgbGFzdFdvcmRbMl0sIGxhc3RXb3JkWzNdLCBsYXN0V29yZFswXV07XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnUm90V29yZCcsIGlucHV0OiBsYXN0V29yZC5zbGljZSgpLCBvdXRwdXQ6IHJvdFdvcmQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFN0ZXAgMjogU3ViQnl0ZXMgKFMtYm94KVxuICAgIGNvbnN0IHNib3hXb3JkID0gcm90V29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgIHN0ZXA6ICdTdWJCeXRlcycsIGlucHV0OiByb3RXb3JkLnNsaWNlKCksIG91dHB1dDogc2JveFdvcmQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFN0ZXAgMzogUmNvbiB0byBmaXJzdCBieXRlXG4gICAgY29uc3QgcmNvblZhbHVlID0gUkNPTltyb3VuZF07XG4gICAgY29uc3QgcmNvbldvcmQgPSBzYm94V29yZC5zbGljZSgpO1xuICAgIHJjb25Xb3JkWzBdIF49IHJjb25WYWx1ZTtcbiAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgIHN0ZXA6ICdBcHBseSBSY29uJywgaW5wdXQ6IHNib3hXb3JkLnNsaWNlKCksIHJjb246IHJjb25WYWx1ZSwgb3V0cHV0OiByY29uV29yZC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU3RlcCA0OiBYT1Igd2l0aCBwcmV2aW91cyAoZmlyc3Qgd29yZClcbiAgICBjb25zdCB4b3JSZXN1bHQgPSBbXG4gICAgICBwcmV2S2V5WzBdIF4gcmNvbldvcmRbMF0sXG4gICAgICBwcmV2S2V5WzFdIF4gcmNvbldvcmRbMV0sXG4gICAgICBwcmV2S2V5WzJdIF4gcmNvbldvcmRbMl0sXG4gICAgICBwcmV2S2V5WzNdIF4gcmNvbldvcmRbM10sXG4gICAgXTtcbiAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgIHN0ZXA6ICdYT1Igd2l0aCBwcmV2aW91cycsIGlucHV0czogW3ByZXZLZXkuc2xpY2UoMCw0KSwgcmNvbldvcmQuc2xpY2UoKV0sIG91dHB1dDogeG9yUmVzdWx0LnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTYXZlIGFuZCB1cGRhdGUgbmV3S2V5XG4gICAgbmV3S2V5WzBdID0geG9yUmVzdWx0WzBdO1xuICAgIG5ld0tleVsxXSA9IHhvclJlc3VsdFsxXTtcbiAgICBuZXdLZXlbMl0gPSB4b3JSZXN1bHRbMl07XG4gICAgbmV3S2V5WzNdID0geG9yUmVzdWx0WzNdO1xuICAgIC8vIE90aGVyIHdvcmRzIChvbmx5IHNpbXBsZSB4b3IpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBrZXlXb3JkczsgaSsrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcbiAgICAgIG5ld0tleVtvZmZzZXRdID0gbmV3S2V5W29mZnNldCAtIDRdIF4gcHJldktleVtvZmZzZXRdO1xuICAgICAgbmV3S2V5W29mZnNldCArIDFdID0gbmV3S2V5W29mZnNldCAtIDNdIF4gcHJldktleVtvZmZzZXQgKyAxXTtcbiAgICAgIG5ld0tleVtvZmZzZXQgKyAyXSA9IG5ld0tleVtvZmZzZXQgLSAyXSBeIHByZXZLZXlbb2Zmc2V0ICsgMl07XG4gICAgICBuZXdLZXlbb2Zmc2V0ICsgM10gPSBuZXdLZXlbb2Zmc2V0IC0gMV0gXiBwcmV2S2V5W29mZnNldCArIDNdO1xuICAgICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICAgIHN0ZXA6ICdYT1IgY2hhaW4nLCBpbnB1dHM6IFtcbiAgICAgICAgICBuZXdLZXkuc2xpY2Uob2Zmc2V0IC0gNCwgb2Zmc2V0KSxcbiAgICAgICAgICBwcmV2S2V5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNClcbiAgICAgICAgXSwgb3V0cHV0OiBuZXdLZXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0KSwgd29yZEluZGV4OiBpXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3RlcHNQZXJSb3VuZC5wdXNoKHsgcm91bmQsIHN0ZXBEZXRhaWxzLCByb3VuZEtleTogbmV3S2V5LnNsaWNlKCkgfSk7XG4gICAgcHJldktleSA9IG5ld0tleS5zbGljZSgpO1xuICAgIHJvdW5kS2V5cy5wdXNoKHByZXZLZXkpO1xuICB9XG4gIHJldHVybiBzdGVwc1BlclJvdW5kO1xufVxuXG4vLyBSZWFsIEFFUyBlbmNyeXB0aW9uIHVzaW5nIENyeXB0b0pTIGZvciB2ZXJpZmljYXRpb25cbmV4cG9ydCBjb25zdCByZWFsQWVzRW5jcnlwdCA9IChcbiAgcGxhaW50ZXh0OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcsXG4gIG91dHB1dEZvcm1hdDogT3V0cHV0Rm9ybWF0ID0gT3V0cHV0Rm9ybWF0LkJBU0U2NCxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCxcbiAgaXZTdHJpbmc/OiBzdHJpbmdcbik6IHsgY2lwaGVydGV4dDogc3RyaW5nLCBpdj86IHN0cmluZywgZm9ybWF0czogeyBiYXNlNjQ6IHN0cmluZywgaGV4OiBzdHJpbmcsIGJpbmFyeTogc3RyaW5nIH0gfSA9PiB7XG4gIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGtleSBpcyBzaG9ydGVyIHRoYW4gcmVxdWlyZWQgYnkga2V5TGVuZ3RoXG4gIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIGxldCBrZXlIZXggPSBjbGVhbktleS5sZW5ndGggJSAyID09PSAxID8gY2xlYW5LZXkgKyAnMCcgOiBjbGVhbktleTtcbiAgXG4gIC8vIEVuc3VyZSBrZXkgaXMgb2YgY29ycmVjdCBsZW5ndGggZm9yIHRoZSBzZWxlY3RlZCBrZXkgbGVuZ3RoXG4gIGNvbnN0IHJlcXVpcmVkSGV4Q2hhcnMgPSBrZXlMZW5ndGggLyA0OyAvLyBFYWNoIGhleCBjaGFyIGlzIDQgYml0c1xuICBpZiAoa2V5SGV4Lmxlbmd0aCA8IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAvLyBQYWQga2V5IGlmIHRvbyBzaG9ydFxuICAgIGtleUhleCA9IGtleUhleC5wYWRFbmQocmVxdWlyZWRIZXhDaGFycywgJzAnKTtcbiAgfSBlbHNlIGlmIChrZXlIZXgubGVuZ3RoID4gcmVxdWlyZWRIZXhDaGFycykge1xuICAgIC8vIFRydW5jYXRlIGtleSBpZiB0b28gbG9uZ1xuICAgIGtleUhleCA9IGtleUhleC5zdWJzdHJpbmcoMCwgcmVxdWlyZWRIZXhDaGFycyk7XG4gIH1cbiAgXG4gIGNvbnN0IGtleVdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2Uoa2V5SGV4KTtcbiAgXG4gIGxldCBwYWRkaW5nT3B0aW9uOiBhbnk7XG4gIHN3aXRjaCAocGFkZGluZykge1xuICAgIGNhc2UgUGFkZGluZ1R5cGUuQU5TSV9YOTIzOlxuICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLkFuc2lYOTIzIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFBhZGRpbmdUeXBlLk5PTkU6XG4gICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcGFkZGluZ09wdGlvbiA9IHt9OyAvLyBkZWZhdWx0IGlzIFBLQ1M3XG4gIH1cbiAgXG4gIGxldCBtb2RlT3B0aW9uOiBhbnk7XG4gIGxldCBpdjogYW55O1xuICBcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgIGlmIChpdlN0cmluZykge1xuICAgICAgICBpdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaXZTdHJpbmcucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdiA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcbiAgICAgIH1cbiAgICAgIG1vZGVPcHRpb24gPSB7IFxuICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgICAgaXY6IGl2LFxuICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGlmIChpdlN0cmluZykge1xuICAgICAgICBpdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaXZTdHJpbmcucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdiA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcbiAgICAgIH1cbiAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ1RSLFxuICAgICAgICBpdjogaXYsXG4gICAgICAgIGNvdW50ZXI6IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFswLCAwLCAwLCAwXSwgMTYpLFxuICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkVDQixcbiAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBjb25zdCBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChwbGFpbnRleHQsIGtleVdvcmRBcnJheSwgbW9kZU9wdGlvbik7XG4gIFxuICAvLyBHZXQgYWxsIG91dHB1dCBmb3JtYXRzXG4gIGNvbnN0IGJhc2U2NE91dHB1dCA9IGVuY3J5cHRlZC50b1N0cmluZygpO1xuICBjb25zdCBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAgY2lwaGVydGV4dDogQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRPdXRwdXQpXG4gIH0pO1xuICBjb25zdCBoZXhPdXRwdXQgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuICBcbiAgLy8gRm9yIGJpbmFyeSwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBoZXggdG8gYmluYXJ5XG4gIGNvbnN0IGhleEJ5dGVzID0gaGV4T3V0cHV0Lm1hdGNoKC8uezJ9L2cpIS5tYXAoaGV4ID0+IHBhcnNlSW50KGhleCwgMTYpKTtcbiAgY29uc3QgYmluYXJ5T3V0cHV0ID0gYnl0ZXNUb0JpbmFyeShoZXhCeXRlcywgJycpO1xuICBcbiAgLy8gU2VsZWN0IHRoZSByZXF1ZXN0ZWQgZm9ybWF0IGZvciBwcmltYXJ5IG91dHB1dFxuICBsZXQgcHJpbWFyeU91dHB1dDogc3RyaW5nO1xuICBzd2l0Y2ggKG91dHB1dEZvcm1hdCkge1xuICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkhFWDpcbiAgICAgIHByaW1hcnlPdXRwdXQgPSBoZXhPdXRwdXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE91dHB1dEZvcm1hdC5CSU5BUlk6XG4gICAgICBwcmltYXJ5T3V0cHV0ID0gYmluYXJ5T3V0cHV0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gQkFTRTY0XG4gICAgICBwcmltYXJ5T3V0cHV0ID0gYmFzZTY0T3V0cHV0O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIHJldHVybiB7IFxuICAgIGNpcGhlcnRleHQ6IHByaW1hcnlPdXRwdXQsXG4gICAgaXY6IGl2ID8gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoaXYpIDogdW5kZWZpbmVkLFxuICAgIGZvcm1hdHM6IHtcbiAgICAgIGJhc2U2NDogYmFzZTY0T3V0cHV0LFxuICAgICAgaGV4OiBoZXhPdXRwdXQsXG4gICAgICBiaW5hcnk6IGJpbmFyeU91dHB1dFxuICAgIH1cbiAgfTtcbn07XG5cbi8vIFJlYWwgQUVTIGRlY3J5cHRpb24gdXNpbmcgQ3J5cHRvSlNcbmV4cG9ydCBjb25zdCByZWFsQWVzRGVjcnlwdCA9IChcbiAgY2lwaGVydGV4dDogc3RyaW5nLFxuICBrZXk6IHN0cmluZyxcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3LFxuICBpbnB1dEZvcm1hdDogT3V0cHV0Rm9ybWF0ID0gT3V0cHV0Rm9ybWF0LkJBU0U2NCxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCxcbiAgaXZTdHJpbmc/OiBzdHJpbmdcbik6IHsgcGxhaW50ZXh0OiBzdHJpbmcsIGVycm9yPzogc3RyaW5nIH0gPT4ge1xuICB0cnkge1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGtleSBpcyBzaG9ydGVyIHRoYW4gcmVxdWlyZWQgYnkga2V5TGVuZ3RoXG4gICAgY29uc3QgY2xlYW5LZXkgPSBrZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBsZXQga2V5SGV4ID0gY2xlYW5LZXkubGVuZ3RoICUgMiA9PT0gMSA/IGNsZWFuS2V5ICsgJzAnIDogY2xlYW5LZXk7XG4gICAgXG4gICAgLy8gRW5zdXJlIGtleSBpcyBvZiBjb3JyZWN0IGxlbmd0aCBmb3IgdGhlIHNlbGVjdGVkIGtleSBsZW5ndGhcbiAgICBjb25zdCByZXF1aXJlZEhleENoYXJzID0ga2V5TGVuZ3RoIC8gNDsgLy8gRWFjaCBoZXggY2hhciBpcyA0IGJpdHNcbiAgICBpZiAoa2V5SGV4Lmxlbmd0aCA8IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAgIC8vIFBhZCBrZXkgaWYgdG9vIHNob3J0XG4gICAgICBrZXlIZXggPSBrZXlIZXgucGFkRW5kKHJlcXVpcmVkSGV4Q2hhcnMsICcwJyk7XG4gICAgfSBlbHNlIGlmIChrZXlIZXgubGVuZ3RoID4gcmVxdWlyZWRIZXhDaGFycykge1xuICAgICAgLy8gVHJ1bmNhdGUga2V5IGlmIHRvbyBsb25nXG4gICAgICBrZXlIZXggPSBrZXlIZXguc3Vic3RyaW5nKDAsIHJlcXVpcmVkSGV4Q2hhcnMpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBrZXlXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGtleUhleCk7XG4gICAgXG4gICAgLy8gUGFyc2UgY2lwaGVydGV4dCBiYXNlZCBvbiBpbnB1dCBmb3JtYXRcbiAgICBsZXQgY2lwaGVydGV4dFdvcmRBcnJheTogYW55O1xuICAgIHN3aXRjaCAoaW5wdXRGb3JtYXQpIHtcbiAgICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkhFWDpcbiAgICAgICAgY2lwaGVydGV4dFdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoY2lwaGVydGV4dC5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE91dHB1dEZvcm1hdC5CSU5BUlk6XG4gICAgICAgIC8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyB0byBoZXggZmlyc3RcbiAgICAgICAgY29uc3QgaGV4RnJvbUJpbmFyeSA9IGNpcGhlcnRleHQucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaCgvLns4fS9nKT8ubWFwKGJpbiA9PiBwYXJzZUludChiaW4sIDIpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKSB8fCAnJztcbiAgICAgICAgY2lwaGVydGV4dFdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4RnJvbUJpbmFyeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gQkFTRTY0XG4gICAgICAgIGNpcGhlcnRleHRXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGNpcGhlcnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgbGV0IHBhZGRpbmdPcHRpb246IGFueTtcbiAgICBzd2l0Y2ggKHBhZGRpbmcpIHtcbiAgICAgIGNhc2UgUGFkZGluZ1R5cGUuQU5TSV9YOTIzOlxuICAgICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuQW5zaVg5MjMgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhZGRpbmdUeXBlLk5PTkU6XG4gICAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYWRkaW5nT3B0aW9uID0ge307IC8vIGRlZmF1bHQgaXMgUEtDUzdcbiAgICB9XG4gICAgXG4gICAgbGV0IG1vZGVPcHRpb246IGFueTtcbiAgICBsZXQgaXY6IGFueTtcbiAgICBcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICAgIGlmICghaXZTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogJ0NCQyByZWppbWkgdWNodW4gSVYga2VyYWsnIH07XG4gICAgICAgIH1cbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBtb2RlT3B0aW9uID0geyBcbiAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICAgIGlmICghaXZTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogJ0NUUiByZWppbWkgdWNodW4gSVYgKE5vbmNlKSBrZXJhaycgfTtcbiAgICAgICAgfVxuICAgICAgICBpdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaXZTdHJpbmcucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DVFIsXG4gICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgIGNvdW50ZXI6IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFswLCAwLCAwLCAwXSwgMTYpLFxuICAgICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBFQ0JcbiAgICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkVDQixcbiAgICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkZWNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChcbiAgICAgIHsgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSB9IGFzIGFueSxcbiAgICAgIGtleVdvcmRBcnJheSxcbiAgICAgIG1vZGVPcHRpb25cbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHBsYWludGV4dCA9IGRlY3J5cHRlZC50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG4gICAgXG4gICAgaWYgKCFwbGFpbnRleHQpIHtcbiAgICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiAnRGVzaGlmcmxhc2ggbXV2YWZmYXFpeWF0c2l6LiBLYWxpdCB5b2tpIHNoaWZybGFuZ2FuIG1hdG4gbm90b1xcJ2dcXCdyaS4nIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHBsYWludGV4dCB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0Rlc2hpZnJsYXNoZGEgeGF0b2xpayB5dXogYmVyZGknIH07XG4gIH1cbn07XG5cbi8vIFRlc3Qgc3BlY2lmaWMgY2FzZSBmb3IgXCJTYWxvbSwgQUVTIVwiIHdpdGgga2V5IFwiY2MgMGUgYzEgNzAgMjQgMjQgMDEgOGQgNGUgZmQgNWUgZjMgOGQgMTUgMmYgNjNcIlxuZXhwb3J0IGNvbnN0IHRlc3RTcGVjaWZpY0Nhc2UgPSAoKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcGxhaW50ZXh0ID0gXCJTYWxvbSwgQUVTIVwiO1xuICBjb25zdCBrZXkgPSBcImNjIDBlIGMxIDcwIDI0IDI0IDAxIDhkIDRlIGZkIDVlIGYzIDhkIDE1IDJmIDYzXCI7XG4gIFxuICAvLyBDcmVhdGUga2V5IGFuZCBpbnB1dCBhcyBieXRlIGFycmF5c1xuICBjb25zdCBrZXlCeXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkgKz0gMikge1xuICAgIGtleUJ5dGVzLnB1c2gocGFyc2VJbnQoa2V5LnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgfVxuICBcbiAgLy8gVXNlIG91ciBpbXBsZW1lbnRhdGlvblxuICBjb25zdCB7IGZpbmFsQ2lwaGVydGV4dCB9ID0gZ2V0QWVzU3RlcHMocGxhaW50ZXh0LCBrZXlCeXRlcywgQWVzTW9kZS5FQ0IsIFBhZGRpbmdUeXBlLlBLQ1M3KTtcbiAgXG4gIC8vIFVzZSBDcnlwdG9KUyBpbXBsZW1lbnRhdGlvblxuICBjb25zdCBjcnlwdG9SZXN1bHQgPSByZWFsQWVzRW5jcnlwdChwbGFpbnRleHQsIGtleSwgQWVzTW9kZS5FQ0IsIFBhZGRpbmdUeXBlLlBLQ1M3LCBPdXRwdXRGb3JtYXQuSEVYKTtcbiAgXG4gIHJldHVybiBgXG4gICAgQml6bmluZyBpbXBsZW1lbnRhdHNpeWFtaXogKEhFWCk6ICR7ZmluYWxDaXBoZXJ0ZXh0LmhleH1cbiAgICBDcnlwdG9KUyBpbXBsZW1lbnRhdHNpeWFzaSAoSEVYKTogJHtjcnlwdG9SZXN1bHQuZm9ybWF0cy5oZXh9XG4gICAgS3V0aWxheW90Z2FuIG5hdGlqYTogMzA0ODRCOEY4QzZCQjA5Q0EzRjk0QzZGODRGMDMwNUVcbiAgYDtcbn07XG4iXSwibmFtZXMiOlsiQ3J5cHRvSlMiLCJBZXNNb2RlIiwiUGFkZGluZ1R5cGUiLCJPdXRwdXRGb3JtYXQiLCJLZXlMZW5ndGgiLCJnZXROdW1Sb3VuZHMiLCJrZXlMZW5ndGgiLCJnZXRLZXlCeXRlTGVuZ3RoIiwiU0JPWCIsIlJDT04iLCJHQUxPSVNfTVVMXzIiLCJHQUxPSVNfTVVMXzMiLCJ0ZXh0VG9TdGF0ZSIsInRleHQiLCJ3b3JkQXJyYXkiLCJlbmMiLCJVdGY4IiwicGFyc2UiLCJieXRlcyIsInNpZ0J5dGVzIiwiaSIsIndvcmRzIiwibGVuZ3RoIiwid29yZCIsImJ5dGVzSW5UaGlzV29yZCIsIk1hdGgiLCJtaW4iLCJwdXNoIiwiYmxvY2siLCJzbGljZSIsImtleVRvQnl0ZXMiLCJrZXkiLCJyZXF1aXJlZEJ5dGVzIiwicmVxdWlyZWRIZXhMZW5ndGgiLCJjbGVhbktleSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJwYXJzZUludCIsInN1YnN0ciIsImdlbmVyYXRlUmFuZG9tS2V5Iiwia2V5Qnl0ZXMiLCJmbG9vciIsInJhbmRvbSIsImJ5dGVzVG9IZXgiLCJqb2luQ2hhciIsIm1hcCIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsImJ5dGVzVG9CaW5hcnkiLCJzdWJCeXRlcyIsInN0YXRlIiwic2hpZnRSb3dzIiwicmVzdWx0IiwiaWR4Iiwicm93IiwiY29sIiwicm93VmFsdWVzIiwic2hpZnRlZCIsImNvbmNhdCIsIm1peENvbHVtbnMiLCJzMCIsInMxIiwiczIiLCJzMyIsImFkZFJvdW5kS2V5Iiwicm91bmRLZXkiLCJrZXlFeHBhbnNpb24iLCJub3JtYWxpemVkS2V5Iiwia2V5V29yZHMiLCJudW1Sb3VuZHMiLCJyb3VuZEtleXMiLCJyb3VuZCIsInByZXZLZXkiLCJuZXdLZXkiLCJsYXN0SW5kZXgiLCJsYXN0V29yZCIsInJvdFdvcmQiLCJzdWJXb3JkIiwib2Zmc2V0IiwidGVtcFdvcmQiLCJzdWJUZW1wV29yZCIsImFlc1JvdW5kIiwiaXNMYXN0Um91bmQiLCJuZXdTdGF0ZSIsImFlc0VuY3J5cHQiLCJwbGFpbnRleHQiLCJjdXJyZW50U3RhdGUiLCJ0ZXh0VG9CbG9ja3MiLCJwYWRkaW5nIiwicGFkZGVkQnl0ZXMiLCJhcHBseVBLQ1M3UGFkZGluZyIsImFwcGx5QW5zaVg5MjNQYWRkaW5nIiwiYmxvY2tzIiwiZGF0YSIsInBhZGRlZCIsInBhZGRpbmdMZW5ndGgiLCJyZW1vdmVBbnNpWDkyM1BhZGRpbmciLCJnZW5lcmF0ZUlWIiwiaXYiLCJnZXRBZXNTdGVwc0ZvckJsb2NrIiwibW9kZSIsImJsb2NrSW5kZXgiLCJwcmV2aW91c0NpcGhlcnRleHRCbG9jayIsInN0ZXBzIiwicGxhaW50ZXh0Qnl0ZXMiLCJkZXNjcmlwdGlvbiIsImV4cGxhbmF0aW9uIiwiaW5pdGlhbFN0YXRlIiwiYWN0aXZlSW5kaWNlcyIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJwcmV2aW91c1N0YXRlIiwiZmluYWxTdGF0ZSIsImNvdW50ZXJCbG9jayIsImNvdW50ZXJWYWx1ZSIsInN1bSIsImFmdGVySW5pdGlhbFJvdW5kIiwiYWZ0ZXJTdWJCeXRlcyIsImFmdGVyU2hpZnRSb3dzIiwicHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5IiwiYWZ0ZXJNaXhDb2x1bW5zIiwiZ2V0QWVzU3RlcHMiLCJwcm92aWRlZEl2IiwidW5kZWZpbmVkIiwiYWxsQmxvY2tzIiwiaXZEZXNjcmlwdGlvbiIsIml2RXhwbGFuYXRpb24iLCJjb3VudGVyIiwiY29tYmluZWRGaW5hbFN0YXRlcyIsImJsb2NrUmVzdWx0IiwiZmluYWxTdGF0ZVRvVXNlIiwiZmluYWxXb3JkQXJyYXkiLCJsaWIiLCJXb3JkQXJyYXkiLCJjcmVhdGUiLCJVaW50OEFycmF5IiwiZmluYWxDaXBoZXJ0ZXh0QmFzZTY0IiwiQmFzZTY0Iiwic3RyaW5naWZ5IiwiZmluYWxDaXBoZXJ0ZXh0SGV4IiwiSGV4IiwiZmluYWxDaXBoZXJ0ZXh0QmluYXJ5IiwiZmluYWxDaXBoZXJ0ZXh0IiwiYmFzZTY0IiwiaGV4IiwiYmluYXJ5IiwiZ2V0S2V5RXhwYW5zaW9uU3RlcHMiLCJjdXJyZW50S2V5Iiwic2JveFdvcmQiLCJyY29uVmFsdWUiLCJ0cmFuc2Zvcm1lZFdvcmQiLCJmaXJzdFdvcmRQcmV2IiwieG9yUmVzdWx0IiwiaW5kZXgiLCJiIiwiaGlnaGxpZ2h0ZWRDZWxscyIsImdldEtleVNjaGVkdWxlRGV0YWlsZWRTdGVwcyIsInN0ZXBzUGVyUm91bmQiLCJzdGVwRGV0YWlscyIsInN0ZXAiLCJpbnB1dCIsIm91dHB1dCIsInJjb25Xb3JkIiwicmNvbiIsImlucHV0cyIsIndvcmRJbmRleCIsInJlYWxBZXNFbmNyeXB0Iiwib3V0cHV0Rm9ybWF0IiwiaXZTdHJpbmciLCJrZXlIZXgiLCJyZXF1aXJlZEhleENoYXJzIiwicGFkRW5kIiwic3Vic3RyaW5nIiwia2V5V29yZEFycmF5IiwicGFkZGluZ09wdGlvbiIsInBhZCIsIkFuc2lYOTIzIiwiTm9QYWRkaW5nIiwibW9kZU9wdGlvbiIsIkNCQyIsIkNUUiIsIkVDQiIsImVuY3J5cHRlZCIsIkFFUyIsImVuY3J5cHQiLCJiYXNlNjRPdXRwdXQiLCJjaXBoZXJQYXJhbXMiLCJDaXBoZXJQYXJhbXMiLCJjaXBoZXJ0ZXh0IiwiaGV4T3V0cHV0IiwiZm9ybWF0IiwiaGV4Qnl0ZXMiLCJtYXRjaCIsImJpbmFyeU91dHB1dCIsInByaW1hcnlPdXRwdXQiLCJmb3JtYXRzIiwicmVhbEFlc0RlY3J5cHQiLCJpbnB1dEZvcm1hdCIsImNpcGhlcnRleHRXb3JkQXJyYXkiLCJoZXhGcm9tQmluYXJ5IiwiYmluIiwiZXJyb3IiLCJkZWNyeXB0ZWQiLCJkZWNyeXB0IiwibWVzc2FnZSIsInRlc3RTcGVjaWZpY0Nhc2UiLCJjcnlwdG9SZXN1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/aes.ts\n"));

/***/ })

});