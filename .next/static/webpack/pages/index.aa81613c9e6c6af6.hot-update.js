"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/aes.ts":
/*!**************************!*\
  !*** ./src/utils/aes.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AesMode: () => (/* binding */ AesMode),\n/* harmony export */   GALOIS_MUL_2: () => (/* binding */ GALOIS_MUL_2),\n/* harmony export */   GALOIS_MUL_3: () => (/* binding */ GALOIS_MUL_3),\n/* harmony export */   KeyLength: () => (/* binding */ KeyLength),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   PaddingType: () => (/* binding */ PaddingType),\n/* harmony export */   RCON: () => (/* binding */ RCON),\n/* harmony export */   SBOX: () => (/* binding */ SBOX),\n/* harmony export */   addRoundKey: () => (/* binding */ addRoundKey),\n/* harmony export */   aesEncrypt: () => (/* binding */ aesEncrypt),\n/* harmony export */   aesRound: () => (/* binding */ aesRound),\n/* harmony export */   applyAnsiX923Padding: () => (/* binding */ applyAnsiX923Padding),\n/* harmony export */   applyPKCS7Padding: () => (/* binding */ applyPKCS7Padding),\n/* harmony export */   bytesToBinary: () => (/* binding */ bytesToBinary),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   generateIV: () => (/* binding */ generateIV),\n/* harmony export */   generateRandomKey: () => (/* binding */ generateRandomKey),\n/* harmony export */   getAesSteps: () => (/* binding */ getAesSteps),\n/* harmony export */   getAesStepsForBlock: () => (/* binding */ getAesStepsForBlock),\n/* harmony export */   getKeyExpansionSteps: () => (/* binding */ getKeyExpansionSteps),\n/* harmony export */   getKeyScheduleDetailedSteps: () => (/* binding */ getKeyScheduleDetailedSteps),\n/* harmony export */   keyExpansion: () => (/* binding */ keyExpansion),\n/* harmony export */   keyToBytes: () => (/* binding */ keyToBytes),\n/* harmony export */   mixColumns: () => (/* binding */ mixColumns),\n/* harmony export */   realAesDecrypt: () => (/* binding */ realAesDecrypt),\n/* harmony export */   realAesEncrypt: () => (/* binding */ realAesEncrypt),\n/* harmony export */   removeAnsiX923Padding: () => (/* binding */ removeAnsiX923Padding),\n/* harmony export */   shiftRows: () => (/* binding */ shiftRows),\n/* harmony export */   subBytes: () => (/* binding */ subBytes),\n/* harmony export */   testSpecificCase: () => (/* binding */ testSpecificCase),\n/* harmony export */   textToBlocks: () => (/* binding */ textToBlocks),\n/* harmony export */   textToState: () => (/* binding */ textToState)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(pages-dir-browser)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// AES mode enum\nvar AesMode = /*#__PURE__*/ function(AesMode) {\n    AesMode[\"ECB\"] = \"ECB\";\n    AesMode[\"CBC\"] = \"CBC\";\n    AesMode[\"CTR\"] = \"CTR\";\n    return AesMode;\n}({});\n// Padding enum\nvar PaddingType = /*#__PURE__*/ function(PaddingType) {\n    PaddingType[\"PKCS7\"] = \"PKCS7\";\n    PaddingType[\"ANSI_X923\"] = \"ANSI X.923\";\n    PaddingType[\"NONE\"] = \"None\";\n    return PaddingType;\n}({});\n// Output format enum\nvar OutputFormat = /*#__PURE__*/ function(OutputFormat) {\n    OutputFormat[\"BASE64\"] = \"Base64\";\n    OutputFormat[\"HEX\"] = \"Hex\";\n    OutputFormat[\"BINARY\"] = \"Binary\";\n    return OutputFormat;\n}({});\n// Key length enum\nvar KeyLength = /*#__PURE__*/ function(KeyLength) {\n    KeyLength[KeyLength[\"AES_128\"] = 128] = \"AES_128\";\n    KeyLength[KeyLength[\"AES_192\"] = 192] = \"AES_192\";\n    KeyLength[KeyLength[\"AES_256\"] = 256] = \"AES_256\";\n    return KeyLength;\n}({});\n// AES S-Box (Standard Rijndael S-box)\nconst SBOX = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\n// AES Rcon (Round Constants)\nconst RCON = [\n    0x00,\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a\n];\n// Used in MixColumns\nconst GALOIS_MUL_2 = [\n    0x00,\n    0x02,\n    0x04,\n    0x06,\n    0x08,\n    0x0a,\n    0x0c,\n    0x0e,\n    0x10,\n    0x12,\n    0x14,\n    0x16,\n    0x18,\n    0x1a,\n    0x1c,\n    0x1e,\n    0x20,\n    0x22,\n    0x24,\n    0x26,\n    0x28,\n    0x2a,\n    0x2c,\n    0x2e,\n    0x30,\n    0x32,\n    0x34,\n    0x36,\n    0x38,\n    0x3a,\n    0x3c,\n    0x3e,\n    0x40,\n    0x42,\n    0x44,\n    0x46,\n    0x48,\n    0x4a,\n    0x4c,\n    0x4e,\n    0x50,\n    0x52,\n    0x54,\n    0x56,\n    0x58,\n    0x5a,\n    0x5c,\n    0x5e,\n    0x60,\n    0x62,\n    0x64,\n    0x66,\n    0x68,\n    0x6a,\n    0x6c,\n    0x6e,\n    0x70,\n    0x72,\n    0x74,\n    0x76,\n    0x78,\n    0x7a,\n    0x7c,\n    0x7e,\n    0x80,\n    0x82,\n    0x84,\n    0x86,\n    0x88,\n    0x8a,\n    0x8c,\n    0x8e,\n    0x90,\n    0x92,\n    0x94,\n    0x96,\n    0x98,\n    0x9a,\n    0x9c,\n    0x9e,\n    0xa0,\n    0xa2,\n    0xa4,\n    0xa6,\n    0xa8,\n    0xaa,\n    0xac,\n    0xae,\n    0xb0,\n    0xb2,\n    0xb4,\n    0xb6,\n    0xb8,\n    0xba,\n    0xbc,\n    0xbe,\n    0xc0,\n    0xc2,\n    0xc4,\n    0xc6,\n    0xc8,\n    0xca,\n    0xcc,\n    0xce,\n    0xd0,\n    0xd2,\n    0xd4,\n    0xd6,\n    0xd8,\n    0xda,\n    0xdc,\n    0xde,\n    0xe0,\n    0xe2,\n    0xe4,\n    0xe6,\n    0xe8,\n    0xea,\n    0xec,\n    0xee,\n    0xf0,\n    0xf2,\n    0xf4,\n    0xf6,\n    0xf8,\n    0xfa,\n    0xfc,\n    0xfe,\n    0x1b,\n    0x19,\n    0x1f,\n    0x1d,\n    0x13,\n    0x11,\n    0x17,\n    0x15,\n    0x0b,\n    0x09,\n    0x0f,\n    0x0d,\n    0x03,\n    0x01,\n    0x07,\n    0x05,\n    0x3b,\n    0x39,\n    0x3f,\n    0x3d,\n    0x33,\n    0x31,\n    0x37,\n    0x35,\n    0x2b,\n    0x29,\n    0x2f,\n    0x2d,\n    0x23,\n    0x21,\n    0x27,\n    0x25,\n    0x5b,\n    0x59,\n    0x5f,\n    0x5d,\n    0x53,\n    0x51,\n    0x57,\n    0x55,\n    0x4b,\n    0x49,\n    0x4f,\n    0x4d,\n    0x43,\n    0x41,\n    0x47,\n    0x45,\n    0x7b,\n    0x79,\n    0x7f,\n    0x7d,\n    0x73,\n    0x71,\n    0x77,\n    0x75,\n    0x6b,\n    0x69,\n    0x6f,\n    0x6d,\n    0x63,\n    0x61,\n    0x67,\n    0x65,\n    0x9b,\n    0x99,\n    0x9f,\n    0x9d,\n    0x93,\n    0x91,\n    0x97,\n    0x95,\n    0x8b,\n    0x89,\n    0x8f,\n    0x8d,\n    0x83,\n    0x81,\n    0x87,\n    0x85,\n    0xbb,\n    0xb9,\n    0xbf,\n    0xbd,\n    0xb3,\n    0xb1,\n    0xb7,\n    0xb5,\n    0xab,\n    0xa9,\n    0xaf,\n    0xad,\n    0xa3,\n    0xa1,\n    0xa7,\n    0xa5,\n    0xdb,\n    0xd9,\n    0xdf,\n    0xdd,\n    0xd3,\n    0xd1,\n    0xd7,\n    0xd5,\n    0xcb,\n    0xc9,\n    0xcf,\n    0xcd,\n    0xc3,\n    0xc1,\n    0xc7,\n    0xc5,\n    0xfb,\n    0xf9,\n    0xff,\n    0xfd,\n    0xf3,\n    0xf1,\n    0xf7,\n    0xf5,\n    0xeb,\n    0xe9,\n    0xef,\n    0xed,\n    0xe3,\n    0xe1,\n    0xe7,\n    0xe5\n];\nconst GALOIS_MUL_3 = [\n    0x00,\n    0x03,\n    0x06,\n    0x05,\n    0x0c,\n    0x0f,\n    0x0a,\n    0x09,\n    0x18,\n    0x1b,\n    0x1e,\n    0x1d,\n    0x14,\n    0x17,\n    0x12,\n    0x11,\n    0x30,\n    0x33,\n    0x36,\n    0x35,\n    0x3c,\n    0x3f,\n    0x3a,\n    0x39,\n    0x28,\n    0x2b,\n    0x2e,\n    0x2d,\n    0x24,\n    0x27,\n    0x22,\n    0x21,\n    0x60,\n    0x63,\n    0x66,\n    0x65,\n    0x6c,\n    0x6f,\n    0x6a,\n    0x69,\n    0x78,\n    0x7b,\n    0x7e,\n    0x7d,\n    0x74,\n    0x77,\n    0x72,\n    0x71,\n    0x50,\n    0x53,\n    0x56,\n    0x55,\n    0x5c,\n    0x5f,\n    0x5a,\n    0x59,\n    0x48,\n    0x4b,\n    0x4e,\n    0x4d,\n    0x44,\n    0x47,\n    0x42,\n    0x41,\n    0xc0,\n    0xc3,\n    0xc6,\n    0xc5,\n    0xcc,\n    0xcf,\n    0xca,\n    0xc9,\n    0xd8,\n    0xdb,\n    0xde,\n    0xdd,\n    0xd4,\n    0xd7,\n    0xd2,\n    0xd1,\n    0xf0,\n    0xf3,\n    0xf6,\n    0xf5,\n    0xfc,\n    0xff,\n    0xfa,\n    0xf9,\n    0xe8,\n    0xeb,\n    0xee,\n    0xed,\n    0xe4,\n    0xe7,\n    0xe2,\n    0xe1,\n    0xa0,\n    0xa3,\n    0xa6,\n    0xa5,\n    0xac,\n    0xaf,\n    0xaa,\n    0xa9,\n    0xb8,\n    0xbb,\n    0xbe,\n    0xbd,\n    0xb4,\n    0xb7,\n    0xb2,\n    0xb1,\n    0x90,\n    0x93,\n    0x96,\n    0x95,\n    0x9c,\n    0x9f,\n    0x9a,\n    0x99,\n    0x88,\n    0x8b,\n    0x8e,\n    0x8d,\n    0x84,\n    0x87,\n    0x82,\n    0x81,\n    0x9b,\n    0x98,\n    0x9d,\n    0x9e,\n    0x97,\n    0x94,\n    0x91,\n    0x92,\n    0x83,\n    0x80,\n    0x85,\n    0x86,\n    0x8f,\n    0x8c,\n    0x89,\n    0x8a,\n    0xab,\n    0xa8,\n    0xad,\n    0xae,\n    0xa7,\n    0xa4,\n    0xa1,\n    0xa2,\n    0xb3,\n    0xb0,\n    0xb5,\n    0xb6,\n    0xbf,\n    0xbc,\n    0xb9,\n    0xba,\n    0xfb,\n    0xf8,\n    0xfd,\n    0xfe,\n    0xf7,\n    0xf4,\n    0xf1,\n    0xf2,\n    0xe3,\n    0xe0,\n    0xe5,\n    0xe6,\n    0xef,\n    0xec,\n    0xe9,\n    0xea,\n    0xcb,\n    0xc8,\n    0xcd,\n    0xce,\n    0xc7,\n    0xc4,\n    0xc1,\n    0xc2,\n    0xd3,\n    0xd0,\n    0xd5,\n    0xd6,\n    0xdf,\n    0xdc,\n    0xd9,\n    0xda,\n    0x5b,\n    0x58,\n    0x5d,\n    0x5e,\n    0x57,\n    0x54,\n    0x51,\n    0x52,\n    0x43,\n    0x40,\n    0x45,\n    0x46,\n    0x4f,\n    0x4c,\n    0x49,\n    0x4a,\n    0x6b,\n    0x68,\n    0x6d,\n    0x6e,\n    0x67,\n    0x64,\n    0x61,\n    0x62,\n    0x73,\n    0x70,\n    0x75,\n    0x76,\n    0x7f,\n    0x7c,\n    0x79,\n    0x7a,\n    0x3b,\n    0x38,\n    0x3d,\n    0x3e,\n    0x37,\n    0x34,\n    0x31,\n    0x32,\n    0x23,\n    0x20,\n    0x25,\n    0x26,\n    0x2f,\n    0x2c,\n    0x29,\n    0x2a,\n    0x0b,\n    0x08,\n    0x0d,\n    0x0e,\n    0x07,\n    0x04,\n    0x01,\n    0x02,\n    0x13,\n    0x10,\n    0x15,\n    0x16,\n    0x1f,\n    0x1c,\n    0x19,\n    0x1a\n];\n// Convert text to a state matrix - returns array of bytes\nconst textToState = (text)=>{\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Pad to 16 bytes if needed\n    while(bytes.length < 16){\n        bytes.push(0);\n    }\n    const block = bytes.slice(0, 16);\n    // AES state is column-major: state[r + 4*c] = input[4*c + r]\n    return block;\n};\n// Convert a hex key to array of bytes\nconst keyToBytes = (key)=>{\n    // Remove spaces and convert to lowercase\n    const cleanKey = key.replace(/\\s/g, '').toLowerCase();\n    // If it's a hex string, convert it\n    if (/^[0-9a-f]+$/.test(cleanKey)) {\n        const bytes = [];\n        for(let i = 0; i < Math.min(cleanKey.length, 32); i += 2){\n            bytes.push(parseInt(cleanKey.substr(i, 2), 16));\n        }\n        // Pad to 16 bytes if needed\n        while(bytes.length < 16){\n            bytes.push(0);\n        }\n        return bytes.slice(0, 16);\n    }\n    // Otherwise, treat as UTF-8 text\n    return textToState(key);\n};\n// Generate a random key as byte array based on key length\nconst generateRandomKey = function() {\n    let keyLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;\n    const keyBytes = keyLength / 8;\n    const bytes = [];\n    for(let i = 0; i < keyBytes; i++){\n        bytes.push(Math.floor(Math.random() * 256));\n    }\n    return bytes;\n};\n// Format bytes as hex\nconst bytesToHex = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(16).padStart(2, '0')).join(joinChar);\n};\n// Format bytes as binary\nconst bytesToBinary = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(2).padStart(8, '0')).join(joinChar);\n};\n// SubBytes operation - substitute each byte with its S-box value\nconst subBytes = (state)=>{\n    return state.map((byte)=>SBOX[byte]);\n};\n// ShiftRows operation - rotate rows of the state matrix\nconst shiftRows = (state)=>{\n    const result = [\n        ...state\n    ];\n    // Column-major state index helper: idx(row, col) = row + 4*col\n    const idx = (row, col)=>row + 4 * col;\n    for(let row = 1; row < 4; row++){\n        const rowValues = [\n            state[idx(row, 0)],\n            state[idx(row, 1)],\n            state[idx(row, 2)],\n            state[idx(row, 3)]\n        ];\n        const shifted = rowValues.slice(row).concat(rowValues.slice(0, row));\n        for(let col = 0; col < 4; col++){\n            result[idx(row, col)] = shifted[col];\n        }\n    }\n    return result;\n};\n// MixColumns operation - mix data within columns\nconst mixColumns = (state)=>{\n    const result = [\n        ...state\n    ];\n    const idx = (row, col)=>row + 4 * col;\n    for(let i = 0; i < 4; i++){\n        const s0 = state[idx(0, i)];\n        const s1 = state[idx(1, i)];\n        const s2 = state[idx(2, i)];\n        const s3 = state[idx(3, i)];\n        result[idx(0, i)] = GALOIS_MUL_2[s0] ^ GALOIS_MUL_3[s1] ^ s2 ^ s3;\n        result[idx(1, i)] = s0 ^ GALOIS_MUL_2[s1] ^ GALOIS_MUL_3[s2] ^ s3;\n        result[idx(2, i)] = s0 ^ s1 ^ GALOIS_MUL_2[s2] ^ GALOIS_MUL_3[s3];\n        result[idx(3, i)] = GALOIS_MUL_3[s0] ^ s1 ^ s2 ^ GALOIS_MUL_2[s3];\n    }\n    return result;\n};\n// AddRoundKey operation - XOR state with round key\nconst addRoundKey = (state, roundKey)=>{\n    return state.map((byte, i)=>byte ^ roundKey[i]);\n};\n// Key expansion - generate round keys\nconst keyExpansion = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    const roundKeys = [\n        key.slice()\n    ]; // First round key is the original key\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const newKey = prevKey.slice();\n        // Rotate the last word and apply S-box\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const subWord = rotWord.map((byte)=>SBOX[byte]);\n        // Apply Rcon to the first byte\n        subWord[0] ^= RCON[round];\n        // Generate the first word of the new key\n        newKey[0] = prevKey[0] ^ subWord[0];\n        newKey[1] = prevKey[1] ^ subWord[1];\n        newKey[2] = prevKey[2] ^ subWord[2];\n        newKey[3] = prevKey[3] ^ subWord[3];\n        // Generate the rest of the words\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            // Special handling for AES-256 where every 4th word needs S-box transformation\n            if (keyLength === 256 && i === 4) {\n                const tempWord = [\n                    newKey[offset - 4],\n                    newKey[offset - 3],\n                    newKey[offset - 2],\n                    newKey[offset - 1]\n                ];\n                const subTempWord = tempWord.map((byte)=>SBOX[byte]);\n                newKey[offset] = prevKey[offset] ^ subTempWord[0];\n                newKey[offset + 1] = prevKey[offset + 1] ^ subTempWord[1];\n                newKey[offset + 2] = prevKey[offset + 2] ^ subTempWord[2];\n                newKey[offset + 3] = prevKey[offset + 3] ^ subTempWord[3];\n            } else {\n                newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n                newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n                newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n                newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            }\n        }\n        roundKeys.push(newKey);\n    }\n    return roundKeys;\n};\n// Perform one round of AES\nconst aesRound = (state, roundKey, isLastRound)=>{\n    let newState = subBytes(state);\n    newState = shiftRows(newState);\n    if (!isLastRound) {\n        newState = mixColumns(newState);\n    }\n    newState = addRoundKey(newState, roundKey);\n    return newState;\n};\n// Complete AES encryption\nconst aesEncrypt = (plaintext, key)=>{\n    // Initial state\n    const state = textToState(plaintext);\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial round - just AddRoundKey\n    let currentState = addRoundKey(state, roundKeys[0]);\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        currentState = aesRound(currentState, roundKeys[round], round === 10);\n    }\n    return currentState;\n};\n// Convert full text to array of 16-byte blocks\nconst textToBlocks = function(text) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"PKCS7\";\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    // Convert CryptoJS WordArray to byte array, respecting sigBytes\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Apply padding\n    let paddedBytes;\n    if (padding === \"PKCS7\") {\n        paddedBytes = applyPKCS7Padding(bytes);\n    } else if (padding === \"ANSI X.923\") {\n        paddedBytes = applyAnsiX923Padding(bytes);\n    } else {\n        paddedBytes = [\n            ...bytes\n        ];\n        // For NONE padding, must be multiple of 16\n        while(paddedBytes.length % 16 !== 0){\n            paddedBytes.push(0);\n        }\n    }\n    // Split into 16-byte blocks\n    const blocks = [];\n    for(let i = 0; i < paddedBytes.length; i += 16){\n        blocks.push(paddedBytes.slice(i, i + 16));\n    }\n    return blocks;\n};\n// Apply PKCS7 padding\nconst applyPKCS7Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    for(let i = 0; i < paddingLength; i++){\n        padded.push(paddingLength);\n    }\n    return padded;\n};\n// Apply ANSI X.923 padding\nconst applyAnsiX923Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    // Add padding bytes (0x00) except the last byte\n    for(let i = 0; i < paddingLength - 1; i++){\n        padded.push(0x00);\n    }\n    // Add the padding length as the last byte\n    padded.push(paddingLength);\n    return padded;\n};\n// Remove ANSI X.923 padding\nconst removeAnsiX923Padding = (data)=>{\n    const paddingLength = data[data.length - 1];\n    return data.slice(0, data.length - paddingLength);\n};\n// Get IV for CBC mode\nconst generateIV = ()=>{\n    const iv = [];\n    for(let i = 0; i < 16; i++){\n        iv.push(Math.floor(Math.random() * 256));\n    }\n    return iv;\n};\n// Get AES steps for a single block (16 bytes)\nconst getAesStepsForBlock = function(block, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", blockIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, previousCiphertextBlock = arguments.length > 4 ? arguments[4] : void 0, iv = arguments.length > 5 ? arguments[5] : void 0;\n    const steps = [];\n    // Ensure block is exactly 16 bytes\n    const plaintextBytes = [\n        ...block\n    ];\n    while(plaintextBytes.length < 16){\n        plaintextBytes.push(0);\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Asl ochiq matn\"),\n        state: plaintextBytes,\n        explanation: \"Blok \".concat(blockIndex + 1, \" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.\")\n    });\n    const initialState = plaintextBytes;\n    const roundKeys = keyExpansion(key);\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (blockIndex === 0 && iv) {\n                currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — IV bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: iv,\n                    explanation: \"CBC: birinchi blok IV bilan XOR qilinadi.\"\n                });\n            } else if (previousCiphertextBlock) {\n                currentState = initialState.map((byte, i)=>byte ^ previousCiphertextBlock[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — Oldingi ciphertext bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: previousCiphertextBlock,\n                    explanation: \"CBC: keyingi bloklar oldingi ciphertext bloki bilan XOR qilinadi.\"\n                });\n            } else {\n                currentState = initialState;\n            }\n            break;\n        case \"CTR\":\n            if (!iv) {\n                return {\n                    steps: [],\n                    finalState: plaintextBytes\n                };\n            }\n            const counterBlock = [\n                ...iv\n            ];\n            let counterValue = blockIndex;\n            for(let i = 15; i >= 0 && counterValue > 0; i--){\n                const sum = counterBlock[i] + (counterValue & 0xff);\n                counterBlock[i] = sum & 0xff;\n                counterValue = (counterValue >> 8) + (sum >> 8);\n            }\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter\"),\n                state: counterBlock,\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter.\")\n            });\n            currentState = counterBlock;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Boshlang'ich\"),\n                state: currentState,\n                explanation: \"ECB: blok \".concat(blockIndex + 1, \" mustaqil shifrlanadi.\")\n            });\n            break;\n    }\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — 0-bosqich — AddRoundKey\"),\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: \"Blok \".concat(blockIndex + 1, \": boshlang'ich AddRoundKey.\"),\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    for(let round = 1; round <= 10; round++){\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: \"Blok \".concat(blockIndex + 1, \": SubBytes.\"),\n            previousState: currentState\n        });\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: \"Blok \".concat(blockIndex + 1, \": ShiftRows.\"),\n            previousState: afterSubBytes\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"Blok \".concat(blockIndex + 1, \": MixColumns.\"),\n                previousState: afterShiftRows\n            });\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: \"Blok \".concat(blockIndex + 1, \": AddRoundKey.\"),\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter XOR\"),\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter XOR.\"),\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Yakuniy\"),\n        state: finalState,\n        explanation: \"Blok \".concat(blockIndex + 1, \" uchun yakuniy shifrlangan natija.\")\n    });\n    return {\n        steps,\n        finalState\n    };\n};\nconst getAesSteps = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", providedIv = arguments.length > 4 ? arguments[4] : void 0;\n    const steps = [];\n    let iv = providedIv ? [\n        ...providedIv\n    ] : undefined;\n    // Convert full text to blocks\n    const blocks = textToBlocks(plaintext, padding);\n    const allBlocks = [];\n    // Convert plaintext to bytes (for first block visualization)\n    let plaintextBytes = blocks[0] || textToState(plaintext);\n    steps.push({\n        description: 'Asl ochiq matn',\n        state: plaintextBytes,\n        explanation: 'Ochiq matn \"'.concat(plaintext, '\" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.')\n    });\n    // Apply padding if needed\n    if (padding === \"ANSI X.923\") {\n        plaintextBytes = applyAnsiX923Padding(plaintextBytes);\n        steps.push({\n            description: 'ANSI X.923 to‘ldirishdan keyin',\n            state: plaintextBytes,\n            explanation: 'ANSI X.923 to‘ldirish nollar bilan to‘ldiradi va oxirgi byte ga to‘ldirish uzunligini qo‘yadi.'\n        });\n    }\n    // Generate IV for CBC/CTR mode only if not provided\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n        if (blocks.length === 1) {\n            // Only show IV step if single block (for backward compatibility)\n            const ivDescription = mode === \"CBC\" ? 'Boshlang\\'ich vektor (Initialization Vector, IV)' : 'Counter (Nonce)';\n            const ivExplanation = \"\".concat(mode === \"CBC\" ? 'CBC' : 'CTR', \" rejimi uchun 16-bayt tasodifiy \").concat(mode === \"CBC\" ? 'IV' : 'Nonce', \" yaratiladi.\");\n            steps.push({\n                description: ivDescription,\n                state: iv,\n                explanation: ivExplanation\n            });\n        }\n    }\n    // Start encryption process (for first block visualization)\n    const initialState = plaintextBytes;\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial setup based on mode\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (!iv) iv = generateIV(); // Failsafe\n            // XOR plaintext with IV\n            currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n            steps.push({\n                description: 'Boshlang\\'ich holatni IV bilan XOR qilish',\n                state: currentState,\n                activeIndices: Array.from(Array(16).keys()),\n                previousState: initialState,\n                roundKey: iv,\n                explanation: \"CBC rejimida shifrlash boshlanishidan oldin ochiq matn IV bilan XOR qilinadi. Bu jarayon CBC rejimining asosiy xususiyatidir - har bir ochiq matn bloki avvalgi shifrlangan matn bloki (yoki birinchi blok uchun IV) bilan XOR qilinadi, keyin shifrlanadi. Bu bir xil ochiq matn bloklarini turli shifrlangan matn bloklarga aylantiradi va shifrlangan matndagi naqshlarni yashirishga yordam beradi.\"\n            });\n            break;\n        case \"CTR\":\n            // In CTR mode, we encrypt a counter value instead of the plaintext\n            const counter = iv || generateIV();\n            if (!iv) iv = counter;\n            steps.push({\n                description: 'Counter qiymati',\n                state: counter,\n                explanation: 'CTR rejimida ochiq matn o‘rniga counter qiymati shifrlanadi.'\n            });\n            currentState = counter;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: 'Boshlang‘ich holat (ochiq matn)',\n                state: currentState,\n                explanation: 'ECB rejimida ochiq matn bloklari mustaqil ravishda shifrlanadi.'\n            });\n            break;\n    }\n    // Initial round - just AddRoundKey (Round 0)\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: '0-bosqich — Boshlang\\'ich AddRoundKey',\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        // SubBytes\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: \"Har bir bayt S-box jadvalidagi mos qiymat bilan almashtiriladi. Bu AES algoritmidagi yagona no-chiziqli amal hisoblanadi.\",\n            previousState: currentState // Add previous state for S-box lookup\n        });\n        // ShiftRows\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: \"Holat matritsasining qatorlari chap tomonga quyidagicha siljitiladi: 0-qator – 0 ta, 1-qator – 1 ta, 2-qator – 2 ta va 3-qator – 3 ta baytga.\",\n            previousState: afterSubBytes // Add previous state for comparison\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            // MixColumns (not in final round)\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"\".concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"Har bir ustun Galois maydoni ustida chiziqli o'zgartirish orqali o'zgartiriladi.\\n                      Bu jarayon shifrda diffuziya (ya'ni ma'lumotlarning keng tarqalishi) ni ta'minlaydi.\",\n                previousState: afterShiftRows // Add previous state for MixColumns comparison\n            });\n            // AddRoundKey\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            // Final round has no MixColumns\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: \"Holat  \".concat(round, \"-bosqichdagi Round Kalit bilan XOR amaliyoti orqali birlashtiriladi.\"),\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    // Final output based on mode\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            // Output is the current state (already completed encryption)\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            // XOR the encrypted counter with plaintext\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: 'Ochiq matn shifrlangan hisoblagich bilan XOR amaliyotida birlashtiriladi.',\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: 'CTR rejimida, yakuniy bosqichda shifrlangan hisoblagich ochiq matn bilan XOR amaliyoti orqali birlashtiriladi va natijada shifrlangan matn hosil bo‘ladi.',\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: 'Yakuniy shifrlangan matn',\n        state: finalState,\n        explanation: \"\".concat(mode, \" rejimida AES-128 yordamida olingan yakuniy shifrlangan natija.\")\n    });\n    // Process all blocks for multi-block support\n    let previousCiphertextBlock;\n    const combinedFinalStates = [];\n    // Generate IV if needed\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n    }\n    for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){\n        const blockResult = getAesStepsForBlock(blocks[blockIndex], key, mode, blockIndex, previousCiphertextBlock, iv);\n        allBlocks.push({\n            blockIndex,\n            steps: blockResult.steps,\n            finalState: blockResult.finalState\n        });\n        combinedFinalStates.push(...blockResult.finalState);\n        // For CBC mode, use current ciphertext as previous for next block\n        if (mode === \"CBC\") {\n            previousCiphertextBlock = blockResult.finalState;\n        }\n    }\n    // Use combined final states if we have multiple blocks, otherwise use single block result\n    const finalStateToUse = blocks.length > 1 ? combinedFinalStates : finalState;\n    // Convert the final state to the requested output format\n    const finalWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create(new Uint8Array(finalStateToUse));\n    const finalCiphertextBase64 = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.stringify(finalWordArray);\n    const finalCiphertextHex = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(finalWordArray);\n    const finalCiphertextBinary = bytesToBinary(finalStateToUse, '');\n    return {\n        steps,\n        finalCiphertext: {\n            base64: finalCiphertextBase64,\n            hex: finalCiphertextHex,\n            binary: finalCiphertextBinary\n        },\n        iv,\n        allBlocks: allBlocks.length > 1 ? allBlocks : undefined\n    };\n};\n// Get key expansion steps with detailed explanations\nconst getKeyExpansionSteps = (key)=>{\n    const roundKeys = keyExpansion(key);\n    const steps = [];\n    steps.push({\n        description: 'Boshlang‘ich kalit',\n        key: roundKeys[0],\n        explanation: 'Bu foydalanuvchi tomonidan berilgan asl 128-bitli kalitdir.'\n    });\n    for(let round = 1; round <= 10; round++){\n        const prevKey = roundKeys[round - 1];\n        const currentKey = roundKeys[round];\n        // Calculate the transformations for a more detailed explanation\n        const lastWord = [\n            prevKey[12],\n            prevKey[13],\n            prevKey[14],\n            prevKey[15]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        const rconValue = RCON[round];\n        const transformedWord = [\n            ...sboxWord\n        ];\n        transformedWord[0] ^= rconValue;\n        // Calculate the first word of the previous key and its XOR with the transformed word\n        const firstWordPrev = [\n            prevKey[0],\n            prevKey[1],\n            prevKey[2],\n            prevKey[3]\n        ];\n        const xorResult = firstWordPrev.map((byte, index)=>byte ^ transformedWord[index]);\n        // Show the key with highlighted cells for the new word\n        steps.push({\n            description: \"Round kaliti \".concat(round),\n            key: currentKey,\n            explanation: \"\\n        \".concat(round, \"-round uchun kalitni kengaytirish jarayoni:\\n        1. Oldingi kalitning oxirgi word qismini oling: [\").concat(lastWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        2. Wordni aylantiring: [\").concat(rotWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        3. Aylantirilgan word ga S-box ni qo‘llang: [\").concat(sboxWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        4. Birinchi baytga RCON (Round Constant \").concat(rconValue.toString(16), \") ni qo‘llang:\\n          Natija: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        5. Oldingi kalitning birinchi word i: [\").concat(firstWordPrev.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] ni o‘zgartirilgan word bilan XOR qiling: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"], natijada: [\").concat(xorResult.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] hosil bo‘ladi. So‘ngra qolgan word lar shu tarzda hosil qilinadi.\\n      \"),\n            highlightedCells: [\n                0,\n                1,\n                2,\n                3\n            ] // Highlight the first word that's directly transformed\n        });\n    }\n    return steps;\n};\n// Return intermediate steps for each word expansion for visualization\nfunction getKeyScheduleDetailedSteps(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    // Flatten byte array -> words\n    let prevKey = key.slice();\n    let roundKeys = [\n        prevKey.slice()\n    ];\n    // For result visualization: each step for each round\n    let stepsPerRound = [];\n    for(let round = 1; round <= numRounds; round++){\n        let stepDetails = [];\n        let newKey = prevKey.slice();\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        // Step 1: RotWord\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        stepDetails.push({\n            step: 'RotWord',\n            input: lastWord.slice(),\n            output: rotWord.slice()\n        });\n        // Step 2: SubBytes (S-box)\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        stepDetails.push({\n            step: 'SubBytes',\n            input: rotWord.slice(),\n            output: sboxWord.slice()\n        });\n        // Step 3: Rcon to first byte\n        const rconValue = RCON[round];\n        const rconWord = sboxWord.slice();\n        rconWord[0] ^= rconValue;\n        stepDetails.push({\n            step: 'Apply Rcon',\n            input: sboxWord.slice(),\n            rcon: rconValue,\n            output: rconWord.slice()\n        });\n        // Step 4: XOR with previous (first word)\n        const xorResult = [\n            prevKey[0] ^ rconWord[0],\n            prevKey[1] ^ rconWord[1],\n            prevKey[2] ^ rconWord[2],\n            prevKey[3] ^ rconWord[3]\n        ];\n        stepDetails.push({\n            step: 'XOR with previous',\n            inputs: [\n                prevKey.slice(0, 4),\n                rconWord.slice()\n            ],\n            output: xorResult.slice()\n        });\n        // Save and update newKey\n        newKey[0] = xorResult[0];\n        newKey[1] = xorResult[1];\n        newKey[2] = xorResult[2];\n        newKey[3] = xorResult[3];\n        // Other words (only simple xor)\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n            newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n            newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n            newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            stepDetails.push({\n                step: 'XOR chain',\n                inputs: [\n                    newKey.slice(offset - 4, offset),\n                    prevKey.slice(offset, offset + 4)\n                ],\n                output: newKey.slice(offset, offset + 4),\n                wordIndex: i\n            });\n        }\n        stepsPerRound.push({\n            round,\n            stepDetails,\n            roundKey: newKey.slice()\n        });\n        prevKey = newKey.slice();\n        roundKeys.push(prevKey);\n    }\n    return stepsPerRound;\n}\n// Real AES encryption using CryptoJS for verification\nconst realAesEncrypt = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", outputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    // Handle case where key is shorter than required by keyLength\n    const cleanKey = key.replace(/\\s/g, '');\n    let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n    // Ensure key is of correct length for the selected key length\n    const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n    if (keyHex.length < requiredHexChars) {\n        // Pad key if too short\n        keyHex = keyHex.padEnd(requiredHexChars, '0');\n    } else if (keyHex.length > requiredHexChars) {\n        // Truncate key if too long\n        keyHex = keyHex.substring(0, requiredHexChars);\n    }\n    const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n    let paddingOption;\n    switch(padding){\n        case \"ANSI X.923\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n            };\n            break;\n        case \"None\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n            };\n            break;\n        default:\n            paddingOption = {}; // default is PKCS7\n    }\n    let modeOption;\n    let iv;\n    switch(mode){\n        case \"CBC\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                iv: iv,\n                ...paddingOption\n            };\n            break;\n        case \"CTR\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                iv: iv,\n                counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                    0,\n                    0,\n                    0,\n                    0\n                ], 16),\n                ...paddingOption\n            };\n            break;\n        default:\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                ...paddingOption\n            };\n            break;\n    }\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(plaintext, keyWordArray, modeOption);\n    // Get all output formats\n    const base64Output = encrypted.toString();\n    const cipherParams = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.CipherParams.create({\n        ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(base64Output)\n    });\n    const hexOutput = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().format.Hex.stringify(cipherParams);\n    // For binary, we need to convert the hex to binary\n    const hexBytes = hexOutput.match(/.{2}/g).map((hex)=>parseInt(hex, 16));\n    const binaryOutput = bytesToBinary(hexBytes, '');\n    // Select the requested format for primary output\n    let primaryOutput;\n    switch(outputFormat){\n        case \"Hex\":\n            primaryOutput = hexOutput;\n            break;\n        case \"Binary\":\n            primaryOutput = binaryOutput;\n            break;\n        default:\n            primaryOutput = base64Output;\n            break;\n    }\n    return {\n        ciphertext: primaryOutput,\n        iv: iv ? crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(iv) : undefined,\n        formats: {\n            base64: base64Output,\n            hex: hexOutput,\n            binary: binaryOutput\n        }\n    };\n};\n// Real AES decryption using CryptoJS\nconst realAesDecrypt = function(ciphertext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", inputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    try {\n        // Handle case where key is shorter than required by keyLength\n        const cleanKey = key.replace(/\\s/g, '');\n        let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n        // Ensure key is of correct length for the selected key length\n        const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n        if (keyHex.length < requiredHexChars) {\n            // Pad key if too short\n            keyHex = keyHex.padEnd(requiredHexChars, '0');\n        } else if (keyHex.length > requiredHexChars) {\n            // Truncate key if too long\n            keyHex = keyHex.substring(0, requiredHexChars);\n        }\n        const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n        // Parse ciphertext based on input format\n        let ciphertextWordArray;\n        switch(inputFormat){\n            case \"Hex\":\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ciphertext.replace(/\\s/g, ''));\n                break;\n            case \"Binary\":\n                var _ciphertext_replace_match;\n                // Convert binary string to hex first\n                const hexFromBinary = ((_ciphertext_replace_match = ciphertext.replace(/\\s/g, '').match(/.{8}/g)) === null || _ciphertext_replace_match === void 0 ? void 0 : _ciphertext_replace_match.map((bin)=>parseInt(bin, 2).toString(16).padStart(2, '0')).join('')) || '';\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(hexFromBinary);\n                break;\n            default:\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(ciphertext);\n                break;\n        }\n        let paddingOption;\n        switch(padding){\n            case \"ANSI X.923\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n                };\n                break;\n            case \"None\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n                };\n                break;\n            default:\n                paddingOption = {}; // default is PKCS7\n        }\n        let modeOption;\n        let iv;\n        switch(mode){\n            case \"CBC\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CBC rejimi uchun IV kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                    iv: iv,\n                    ...paddingOption\n                };\n                break;\n            case \"CTR\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CTR rejimi uchun IV (Nonce) kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                    iv: iv,\n                    counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                        0,\n                        0,\n                        0,\n                        0\n                    ], 16),\n                    ...paddingOption\n                };\n                break;\n            default:\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                    ...paddingOption\n                };\n                break;\n        }\n        const decrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt({\n            ciphertext: ciphertextWordArray\n        }, keyWordArray, modeOption);\n        const plaintext = decrypted.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n        if (!plaintext) {\n            return {\n                plaintext: '',\n                error: 'Deshifrlash muvaffaqiyatsiz. Kalit yoki shifrlangan matn noto\\'g\\'ri.'\n            };\n        }\n        return {\n            plaintext\n        };\n    } catch (error) {\n        return {\n            plaintext: '',\n            error: error.message || 'Deshifrlashda xatolik yuz berdi'\n        };\n    }\n};\n// Test specific case for \"Salom, AES!\" with key \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\"\nconst testSpecificCase = ()=>{\n    const plaintext = \"Salom, AES!\";\n    const key = \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\";\n    // Create key and input as byte arrays\n    const keyBytes = [];\n    for(let i = 0; i < key.length; i += 2){\n        keyBytes.push(parseInt(key.substr(i, 2), 16));\n    }\n    // Use our implementation\n    const { finalCiphertext } = getAesSteps(plaintext, keyBytes, \"ECB\", \"PKCS7\");\n    // Use CryptoJS implementation\n    const cryptoResult = realAesEncrypt(plaintext, key, \"ECB\", \"PKCS7\", \"Hex\");\n    return \"\\n    Bizning implementatsiyamiz (HEX): \".concat(finalCiphertext.hex, \"\\n    CryptoJS implementatsiyasi (HEX): \").concat(cryptoResult.formats.hex, \"\\n    Kutilayotgan natija: 30484B8F8C6BB09CA3F94C6F84F0305E\\n  \");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9hZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUVqQyxnQkFBZ0I7QUFDVCxxQ0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELGVBQWU7QUFDUix5Q0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELHFCQUFxQjtBQUNkLDBDQUFLQzs7OztXQUFBQTtNQUlYO0FBRUQsa0JBQWtCO0FBQ1gsdUNBQUtDOzs7O1dBQUFBO01BSVg7QUFFRCxzQ0FBc0M7QUFDL0IsTUFBTUMsT0FBTztJQUNsQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRixDQUFDO0FBRUYsNkJBQTZCO0FBQ3RCLE1BQU1DLE9BQU87SUFDbEI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLHFCQUFxQjtBQUNkLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVLLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxjQUFjLENBQUNDO0lBQzFCLE1BQU1DLFlBQVlYLG9EQUFZLENBQUNhLElBQUksQ0FBQ0MsS0FBSyxDQUFDSjtJQUMxQyxNQUFNSyxRQUFrQixFQUFFO0lBQzFCLE1B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QUFFO0FBRUYsa0dBQWtHO0FBQzNGLE1BQU1DLG1CQUFtQjtJQUM5QixNQUFNekgsWUFBWTtJQUNsQixNQUFNdkQsTUFBTTtJQUVaLHNDQUFzQztJQUN0QyxNQUFNUyxXQUFXLEVBQUU7SUFDbkIsSUFBSyxJQUFJcEIsSUFBSSxHQUFHQSxJQUFJVyxJQUFJVCxNQUFNLEVBQUVGLEtBQUssRUFBRztRQUN0Q29CLFNBQVNiLElBQUksQ0FBQ1MsU0FBU0wsSUFBSU0sTUFBTSxDQUFDakIsR0FBRyxJQUFJO0lBQzNDO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU0sRUFBRTRILGVBQWUsRUFBRSxHQUFHckIsWUFBWXJDLFdBQVc5QztJQUVuRCw4QkFBOEI7SUFDOUIsTUFBTXdLLGVBQWV4QyxlQUFlbEYsV0FBV3ZEO0lBRS9DLE9BQU8sMkNBRStCaUwsT0FEQWhFLGdCQUFnQkUsR0FBRyxFQUFDLDRDQUNLLE9BQXpCOEQsYUFBYVgsT0FBTyxDQUFDbkQsR0FBRyxFQUFDO0FBR2pFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdmljdHVzXFxEZXNrdG9wXFxhZXNcXGFlc1xcc3JjXFx1dGlsc1xcYWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDcnlwdG9KUyBmcm9tICdjcnlwdG8tanMnO1xuXG4vLyBBRVMgbW9kZSBlbnVtXG5leHBvcnQgZW51bSBBZXNNb2RlIHtcbiAgRUNCID0gJ0VDQicsXG4gIENCQyA9ICdDQkMnLFxuICBDVFIgPSAnQ1RSJ1xufVxuXG4vLyBQYWRkaW5nIGVudW1cbmV4cG9ydCBlbnVtIFBhZGRpbmdUeXBlIHtcbiAgUEtDUzcgPSAnUEtDUzcnLFxuICBBTlNJX1g5MjMgPSAnQU5TSSBYLjkyMycsXG4gIE5PTkUgPSAnTm9uZSdcbn1cblxuLy8gT3V0cHV0IGZvcm1hdCBlbnVtXG5leHBvcnQgZW51bSBPdXRwdXRGb3JtYXQge1xuICBCQVNFNjQgPSAnQmFzZTY0JyxcbiAgSEVYID0gJ0hleCcsXG4gIEJJTkFSWSA9ICdCaW5hcnknXG59XG5cbi8vIEtleSBsZW5ndGggZW51bVxuZXhwb3J0IGVudW0gS2V5TGVuZ3RoIHtcbiAgQUVTXzEyOCA9IDEyOCxcbiAgQUVTXzE5MiA9IDE5MixcbiAgQUVTXzI1NiA9IDI1NlxufVxuXG4vLyBBRVMgUy1Cb3ggKFN0YW5kYXJkIFJpam5kYWVsIFMtYm94KVxuZXhwb3J0IGNvbnN0IFNCT1ggPSBbXG4gIDB4NjMsIDB4N2MsIDB4NzcsIDB4N2IsIDB4ZjIsIDB4NmIsIDB4NmYsIDB4YzUsIDB4MzAsIDB4MDEsIDB4NjcsIDB4MmIsIDB4ZmUsIDB4ZDcsIDB4YWIsIDB4NzYsXG4gIDB4Y2EsIDB4ODIsIDB4YzksIDB4N2QsIDB4ZmEsIDB4NTksIDB4NDcsIDB4ZjAsIDB4YWQsIDB4ZDQsIDB4YTIsIDB4YWYsIDB4OWMsIDB4YTQsIDB4NzIsIDB4YzAsXG4gIDB4YjcsIDB4ZmQsIDB4OTMsIDB4MjYsIDB4MzYsIDB4M2YsIDB4ZjcsIDB4Y2MsIDB4MzQsIDB4YTUsIDB4ZTUsIDB4ZjEsIDB4NzEsIDB4ZDgsIDB4MzEsIDB4MTUsXG4gIDB4MDQsIDB4YzcsIDB4MjMsIDB4YzMsIDB4MTgsIDB4OTYsIDB4MDUsIDB4OWEsIDB4MDcsIDB4MTIsIDB4ODAsIDB4ZTIsIDB4ZWIsIDB4MjcsIDB4YjIsIDB4NzUsXG4gIDB4MDksIDB4ODMsIDB4MmMsIDB4MWEsIDB4MWIsIDB4NmUsIDB4NWEsIDB4YTAsIDB4NTIsIDB4M2IsIDB4ZDYsIDB4YjMsIDB4MjksIDB4ZTMsIDB4MmYsIDB4ODQsXG4gIDB4NTMsIDB4ZDEsIDB4MDAsIDB4ZWQsIDB4MjAsIDB4ZmMsIDB4YjEsIDB4NWIsIDB4NmEsIDB4Y2IsIDB4YmUsIDB4MzksIDB4NGEsIDB4NGMsIDB4NTgsIDB4Y2YsXG4gIDB4ZDAsIDB4ZWYsIDB4YWEsIDB4ZmIsIDB4NDMsIDB4NGQsIDB4MzMsIDB4ODUsIDB4NDUsIDB4ZjksIDB4MDIsIDB4N2YsIDB4NTAsIDB4M2MsIDB4OWYsIDB4YTgsXG4gIDB4NTEsIDB4YTMsIDB4NDAsIDB4OGYsIDB4OTIsIDB4OWQsIDB4MzgsIDB4ZjUsIDB4YmMsIDB4YjYsIDB4ZGEsIDB4MjEsIDB4MTAsIDB4ZmYsIDB4ZjMsIDB4ZDIsXG4gIDB4Y2QsIDB4MGMsIDB4MTMsIDB4ZWMsIDB4NWYsIDB4OTcsIDB4NDQsIDB4MTcsIDB4YzQsIDB4YTcsIDB4N2UsIDB4M2QsIDB4NjQsIDB4NWQsIDB4MTksIDB4NzMsXG4gIDB4NjAsIDB4ODEsIDB4NGYsIDB4ZGMsIDB4MjIsIDB4MmEsIDB4OTAsIDB4ODgsIDB4NDYsIDB4ZWUsIDB4YjgsIDB4MTQsIDB4ZGUsIDB4NWUsIDB4MGIsIDB4ZGIsXG4gIDB4ZTAsIDB4MzIsIDB4M2EsIDB4MGEsIDB4NDksIDB4MDYsIDB4MjQsIDB4NWMsIDB4YzIsIDB4ZDMsIDB4YWMsIDB4NjIsIDB4OTEsIDB4OTUsIDB4ZTQsIDB4NzksXG4gIDB4ZTcsIDB4YzgsIDB4MzcsIDB4NmQsIDB4OGQsIDB4ZDUsIDB4NGUsIDB4YTksIDB4NmMsIDB4NTYsIDB4ZjQsIDB4ZWEsIDB4NjUsIDB4N2EsIDB4YWUsIDB4MDgsXG4gIDB4YmEsIDB4NzgsIDB4MjUsIDB4MmUsIDB4MWMsIDB4YTYsIDB4YjQsIDB4YzYsIDB4ZTgsIDB4ZGQsIDB4NzQsIDB4MWYsIDB4NGIsIDB4YmQsIDB4OGIsIDB4OGEsXG4gIDB4NzAsIDB4M2UsIDB4YjUsIDB4NjYsIDB4NDgsIDB4MDMsIDB4ZjYsIDB4MGUsIDB4NjEsIDB4MzUsIDB4NTcsIDB4YjksIDB4ODYsIDB4YzEsIDB4MWQsIDB4OWUsXG4gIDB4ZTEsIDB4ZjgsIDB4OTgsIDB4MTEsIDB4NjksIDB4ZDksIDB4OGUsIDB4OTQsIDB4OWIsIDB4MWUsIDB4ODcsIDB4ZTksIDB4Y2UsIDB4NTUsIDB4MjgsIDB4ZGYsXG4gIDB4OGMsIDB4YTEsIDB4ODksIDB4MGQsIDB4YmYsIDB4ZTYsIDB4NDIsIDB4NjgsIDB4NDEsIDB4OTksIDB4MmQsIDB4MGYsIDB4YjAsIDB4NTQsIDB4YmIsIDB4MTYsXG5dO1xuXG4vLyBBRVMgUmNvbiAoUm91bmQgQ29uc3RhbnRzKVxuZXhwb3J0IGNvbnN0IFJDT04gPSBbXG4gIDB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsXG5dO1xuXG4vLyBVc2VkIGluIE1peENvbHVtbnNcbmV4cG9ydCBjb25zdCBHQUxPSVNfTVVMXzIgPSBbXG4gIDB4MDAsIDB4MDIsIDB4MDQsIDB4MDYsIDB4MDgsIDB4MGEsIDB4MGMsIDB4MGUsIDB4MTAsIDB4MTIsIDB4MTQsIDB4MTYsIDB4MTgsIDB4MWEsIDB4MWMsIDB4MWUsXG4gIDB4MjAsIDB4MjIsIDB4MjQsIDB4MjYsIDB4MjgsIDB4MmEsIDB4MmMsIDB4MmUsIDB4MzAsIDB4MzIsIDB4MzQsIDB4MzYsIDB4MzgsIDB4M2EsIDB4M2MsIDB4M2UsXG4gIDB4NDAsIDB4NDIsIDB4NDQsIDB4NDYsIDB4NDgsIDB4NGEsIDB4NGMsIDB4NGUsIDB4NTAsIDB4NTIsIDB4NTQsIDB4NTYsIDB4NTgsIDB4NWEsIDB4NWMsIDB4NWUsXG4gIDB4NjAsIDB4NjIsIDB4NjQsIDB4NjYsIDB4NjgsIDB4NmEsIDB4NmMsIDB4NmUsIDB4NzAsIDB4NzIsIDB4NzQsIDB4NzYsIDB4NzgsIDB4N2EsIDB4N2MsIDB4N2UsXG4gIDB4ODAsIDB4ODIsIDB4ODQsIDB4ODYsIDB4ODgsIDB4OGEsIDB4OGMsIDB4OGUsIDB4OTAsIDB4OTIsIDB4OTQsIDB4OTYsIDB4OTgsIDB4OWEsIDB4OWMsIDB4OWUsXG4gIDB4YTAsIDB4YTIsIDB4YTQsIDB4YTYsIDB4YTgsIDB4YWEsIDB4YWMsIDB4YWUsIDB4YjAsIDB4YjIsIDB4YjQsIDB4YjYsIDB4YjgsIDB4YmEsIDB4YmMsIDB4YmUsXG4gIDB4YzAsIDB4YzIsIDB4YzQsIDB4YzYsIDB4YzgsIDB4Y2EsIDB4Y2MsIDB4Y2UsIDB4ZDAsIDB4ZDIsIDB4ZDQsIDB4ZDYsIDB4ZDgsIDB4ZGEsIDB4ZGMsIDB4ZGUsXG4gIDB4ZTAsIDB4ZTIsIDB4ZTQsIDB4ZTYsIDB4ZTgsIDB4ZWEsIDB4ZWMsIDB4ZWUsIDB4ZjAsIDB4ZjIsIDB4ZjQsIDB4ZjYsIDB4ZjgsIDB4ZmEsIDB4ZmMsIDB4ZmUsXG4gIDB4MWIsIDB4MTksIDB4MWYsIDB4MWQsIDB4MTMsIDB4MTEsIDB4MTcsIDB4MTUsIDB4MGIsIDB4MDksIDB4MGYsIDB4MGQsIDB4MDMsIDB4MDEsIDB4MDcsIDB4MDUsXG4gIDB4M2IsIDB4MzksIDB4M2YsIDB4M2QsIDB4MzMsIDB4MzEsIDB4MzcsIDB4MzUsIDB4MmIsIDB4MjksIDB4MmYsIDB4MmQsIDB4MjMsIDB4MjEsIDB4MjcsIDB4MjUsXG4gIDB4NWIsIDB4NTksIDB4NWYsIDB4NWQsIDB4NTMsIDB4NTEsIDB4NTcsIDB4NTUsIDB4NGIsIDB4NDksIDB4NGYsIDB4NGQsIDB4NDMsIDB4NDEsIDB4NDcsIDB4NDUsXG4gIDB4N2IsIDB4NzksIDB4N2YsIDB4N2QsIDB4NzMsIDB4NzEsIDB4NzcsIDB4NzUsIDB4NmIsIDB4NjksIDB4NmYsIDB4NmQsIDB4NjMsIDB4NjEsIDB4NjcsIDB4NjUsXG4gIDB4OWIsIDB4OTksIDB4OWYsIDB4OWQsIDB4OTMsIDB4OTEsIDB4OTcsIDB4OTUsIDB4OGIsIDB4ODksIDB4OGYsIDB4OGQsIDB4ODMsIDB4ODEsIDB4ODcsIDB4ODUsXG4gIDB4YmIsIDB4YjksIDB4YmYsIDB4YmQsIDB4YjMsIDB4YjEsIDB4YjcsIDB4YjUsIDB4YWIsIDB4YTksIDB4YWYsIDB4YWQsIDB4YTMsIDB4YTEsIDB4YTcsIDB4YTUsXG4gIDB4ZGIsIDB4ZDksIDB4ZGYsIDB4ZGQsIDB4ZDMsIDB4ZDEsIDB4ZDcsIDB4ZDUsIDB4Y2IsIDB4YzksIDB4Y2YsIDB4Y2QsIDB4YzMsIDB4YzEsIDB4YzcsIDB4YzUsXG4gIDB4ZmIsIDB4ZjksIDB4ZmYsIDB4ZmQsIDB4ZjMsIDB4ZjEsIDB4ZjcsIDB4ZjUsIDB4ZWIsIDB4ZTksIDB4ZWYsIDB4ZWQsIDB4ZTMsIDB4ZTEsIDB4ZTcsIDB4ZTUsXG5dO1xuXG5leHBvcnQgY29uc3QgR0FMT0lTX01VTF8zID0gW1xuICAweDAwLCAweDAzLCAweDA2LCAweDA1LCAweDBjLCAweDBmLCAweDBhLCAweDA5LCAweDE4LCAweDFiLCAweDFlLCAweDFkLCAweDE0LCAweDE3LCAweDEyLCAweDExLFxuICAweDMwLCAweDMzLCAweDM2LCAweDM1LCAweDNjLCAweDNmLCAweDNhLCAweDM5LCAweDI4LCAweDJiLCAweDJlLCAweDJkLCAweDI0LCAweDI3LCAweDIyLCAweDIxLFxuICAweDYwLCAweDYzLCAweDY2LCAweDY1LCAweDZjLCAweDZmLCAweDZhLCAweDY5LCAweDc4LCAweDdiLCAweDdlLCAweDdkLCAweDc0LCAweDc3LCAweDcyLCAweDcxLFxuICAweDUwLCAweDUzLCAweDU2LCAweDU1LCAweDVjLCAweDVmLCAweDVhLCAweDU5LCAweDQ4LCAweDRiLCAweDRlLCAweDRkLCAweDQ0LCAweDQ3LCAweDQyLCAweDQxLFxuICAweGMwLCAweGMzLCAweGM2LCAweGM1LCAweGNjLCAweGNmLCAweGNhLCAweGM5LCAweGQ4LCAweGRiLCAweGRlLCAweGRkLCAweGQ0LCAweGQ3LCAweGQyLCAweGQxLFxuICAweGYwLCAweGYzLCAweGY2LCAweGY1LCAweGZjLCAweGZmLCAweGZhLCAweGY5LCAweGU4LCAweGViLCAweGVlLCAweGVkLCAweGU0LCAweGU3LCAweGUyLCAweGUxLFxuICAweGEwLCAweGEzLCAweGE2LCAweGE1LCAweGFjLCAweGFmLCAweGFhLCAweGE5LCAweGI4LCAweGJiLCAweGJlLCAweGJkLCAweGI0LCAweGI3LCAweGIyLCAweGIxLFxuICAweDkwLCAweDkzLCAweDk2LCAweDk1LCAweDljLCAweDlmLCAweDlhLCAweDk5LCAweDg4LCAweDhiLCAweDhlLCAweDhkLCAweDg0LCAweDg3LCAweDgyLCAweDgxLFxuICAweDliLCAweDk4LCAweDlkLCAweDllLCAweDk3LCAweDk0LCAweDkxLCAweDkyLCAweDgzLCAweDgwLCAweDg1LCAweDg2LCAweDhmLCAweDhjLCAweDg5LCAweDhhLFxuICAweGFiLCAweGE4LCAweGFkLCAweGFlLCAweGE3LCAweGE0LCAweGExLCAweGEyLCAweGIzLCAweGIwLCAweGI1LCAweGI2LCAweGJmLCAweGJjLCAweGI5LCAweGJhLFxuICAweGZiLCAweGY4LCAweGZkLCAweGZlLCAweGY3LCAweGY0LCAweGYxLCAweGYyLCAweGUzLCAweGUwLCAweGU1LCAweGU2LCAweGVmLCAweGVjLCAweGU5LCAweGVhLFxuICAweGNiLCAweGM4LCAweGNkLCAweGNlLCAweGM3LCAweGM0LCAweGMxLCAweGMyLCAweGQzLCAweGQwLCAweGQ1LCAweGQ2LCAweGRmLCAweGRjLCAweGQ5LCAweGRhLFxuICAweDViLCAweDU4LCAweDVkLCAweDVlLCAweDU3LCAweDU0LCAweDUxLCAweDUyLCAweDQzLCAweDQwLCAweDQ1LCAweDQ2LCAweDRmLCAweDRjLCAweDQ5LCAweDRhLFxuICAweDZiLCAweDY4LCAweDZkLCAweDZlLCAweDY3LCAweDY0LCAweDYxLCAweDYyLCAweDczLCAweDcwLCAweDc1LCAweDc2LCAweDdmLCAweDdjLCAweDc5LCAweDdhLFxuICAweDNiLCAweDM4LCAweDNkLCAweDNlLCAweDM3LCAweDM0LCAweDMxLCAweDMyLCAweDIzLCAweDIwLCAweDI1LCAweDI2LCAweDJmLCAweDJjLCAweDI5LCAweDJhLFxuICAweDBiLCAweDA4LCAweDBkLCAweDBlLCAweDA3LCAweDA0LCAweDAxLCAweDAyLCAweDEzLCAweDEwLCAweDE1LCAweDE2LCAweDFmLCAweDFjLCAweDE5LCAweDFhLFxuXTtcblxuLy8gQ29udmVydCB0ZXh0IHRvIGEgc3RhdGUgbWF0cml4IC0gcmV0dXJucyBhcnJheSBvZiBieXRlc1xuZXhwb3J0IGNvbnN0IHRleHRUb1N0YXRlID0gKHRleHQ6IHN0cmluZyk6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodGV4dCk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICBcbiAgLy8gUGFkIHRvIDE2IGJ5dGVzIGlmIG5lZWRlZFxuICB3aGlsZSAoYnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG4gIFxuICBjb25zdCBibG9jayA9IGJ5dGVzLnNsaWNlKDAsIDE2KTtcbiAgLy8gQUVTIHN0YXRlIGlzIGNvbHVtbi1tYWpvcjogc3RhdGVbciArIDQqY10gPSBpbnB1dFs0KmMgKyByXVxuICByZXR1cm4gYmxvY2s7XG59O1xuXG4vLyBDb252ZXJ0IGEgaGV4IGtleSB0byBhcnJheSBvZiBieXRlc1xuZXhwb3J0IGNvbnN0IGtleVRvQnl0ZXMgPSAoa2V5OiBzdHJpbmcpOiBudW1iZXJbXSA9PiB7XG4gIC8vIFJlbW92ZSBzcGFjZXMgYW5kIGNvbnZlcnQgdG8gbG93ZXJjYXNlXG4gIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIElmIGl0J3MgYSBoZXggc3RyaW5nLCBjb252ZXJ0IGl0XG4gIGlmICgvXlswLTlhLWZdKyQvLnRlc3QoY2xlYW5LZXkpKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGNsZWFuS2V5Lmxlbmd0aCwgMzIpOyBpICs9IDIpIHtcbiAgICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoY2xlYW5LZXkuc3Vic3RyKGksIDIpLCAxNikpO1xuICAgIH1cbiAgICAvLyBQYWQgdG8gMTYgYnl0ZXMgaWYgbmVlZGVkXG4gICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCA8IDE2KSB7XG4gICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgMTYpO1xuICB9IFxuICBcbiAgLy8gT3RoZXJ3aXNlLCB0cmVhdCBhcyBVVEYtOCB0ZXh0XG4gIHJldHVybiB0ZXh0VG9TdGF0ZShrZXkpO1xufTtcblxuLy8gR2VuZXJhdGUgYSByYW5kb20ga2V5IGFzIGJ5dGUgYXJyYXkgYmFzZWQgb24ga2V5IGxlbmd0aFxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUmFuZG9tS2V5ID0gKGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGtleUJ5dGVzID0ga2V5TGVuZ3RoIC8gODtcbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlCeXRlczsgaSsrKSB7XG4gICAgYnl0ZXMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vLyBGb3JtYXQgYnl0ZXMgYXMgaGV4XG5leHBvcnQgY29uc3QgYnl0ZXNUb0hleCA9IChieXRlczogbnVtYmVyW10sIGpvaW5DaGFyOiBzdHJpbmcgPSAnICcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYnl0ZXMubWFwKGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbihqb2luQ2hhcik7XG59O1xuXG4vLyBGb3JtYXQgYnl0ZXMgYXMgYmluYXJ5XG5leHBvcnQgY29uc3QgYnl0ZXNUb0JpbmFyeSA9IChieXRlczogbnVtYmVyW10sIGpvaW5DaGFyOiBzdHJpbmcgPSAnICcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYnl0ZXMubWFwKGJ5dGUgPT4gYnl0ZS50b1N0cmluZygyKS5wYWRTdGFydCg4LCAnMCcpKS5qb2luKGpvaW5DaGFyKTtcbn07XG5cbi8vIFN1YkJ5dGVzIG9wZXJhdGlvbiAtIHN1YnN0aXR1dGUgZWFjaCBieXRlIHdpdGggaXRzIFMtYm94IHZhbHVlXG5leHBvcnQgY29uc3Qgc3ViQnl0ZXMgPSAoc3RhdGU6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICByZXR1cm4gc3RhdGUubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG59O1xuXG4vLyBTaGlmdFJvd3Mgb3BlcmF0aW9uIC0gcm90YXRlIHJvd3Mgb2YgdGhlIHN0YXRlIG1hdHJpeFxuZXhwb3J0IGNvbnN0IHNoaWZ0Um93cyA9IChzdGF0ZTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFsuLi5zdGF0ZV07XG4gIFxuICAvLyBDb2x1bW4tbWFqb3Igc3RhdGUgaW5kZXggaGVscGVyOiBpZHgocm93LCBjb2wpID0gcm93ICsgNCpjb2xcbiAgY29uc3QgaWR4ID0gKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4gcm93ICsgNCAqIGNvbDtcblxuICBmb3IgKGxldCByb3cgPSAxOyByb3cgPCA0OyByb3crKykge1xuICAgIGNvbnN0IHJvd1ZhbHVlcyA9IFtzdGF0ZVtpZHgocm93LCAwKV0sIHN0YXRlW2lkeChyb3csIDEpXSwgc3RhdGVbaWR4KHJvdywgMildLCBzdGF0ZVtpZHgocm93LCAzKV1dO1xuICAgIGNvbnN0IHNoaWZ0ZWQgPSByb3dWYWx1ZXMuc2xpY2Uocm93KS5jb25jYXQocm93VmFsdWVzLnNsaWNlKDAsIHJvdykpO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDQ7IGNvbCsrKSB7XG4gICAgICByZXN1bHRbaWR4KHJvdywgY29sKV0gPSBzaGlmdGVkW2NvbF07XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gTWl4Q29sdW1ucyBvcGVyYXRpb24gLSBtaXggZGF0YSB3aXRoaW4gY29sdW1uc1xuZXhwb3J0IGNvbnN0IG1peENvbHVtbnMgPSAoc3RhdGU6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXN1bHQgPSBbLi4uc3RhdGVdO1xuICBjb25zdCBpZHggPSAocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKSA9PiByb3cgKyA0ICogY29sO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IHMwID0gc3RhdGVbaWR4KDAsIGkpXTtcbiAgICBjb25zdCBzMSA9IHN0YXRlW2lkeCgxLCBpKV07XG4gICAgY29uc3QgczIgPSBzdGF0ZVtpZHgoMiwgaSldO1xuICAgIGNvbnN0IHMzID0gc3RhdGVbaWR4KDMsIGkpXTtcbiAgICBcbiAgICByZXN1bHRbaWR4KDAsIGkpXSA9IEdBTE9JU19NVUxfMltzMF0gXiBHQUxPSVNfTVVMXzNbczFdIF4gczIgXiBzMztcbiAgICByZXN1bHRbaWR4KDEsIGkpXSA9IHMwIF4gR0FMT0lTX01VTF8yW3MxXSBeIEdBTE9JU19NVUxfM1tzMl0gXiBzMztcbiAgICByZXN1bHRbaWR4KDIsIGkpXSA9IHMwIF4gczEgXiBHQUxPSVNfTVVMXzJbczJdIF4gR0FMT0lTX01VTF8zW3MzXTtcbiAgICByZXN1bHRbaWR4KDMsIGkpXSA9IEdBTE9JU19NVUxfM1tzMF0gXiBzMSBeIHMyIF4gR0FMT0lTX01VTF8yW3MzXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQWRkUm91bmRLZXkgb3BlcmF0aW9uIC0gWE9SIHN0YXRlIHdpdGggcm91bmQga2V5XG5leHBvcnQgY29uc3QgYWRkUm91bmRLZXkgPSAoc3RhdGU6IG51bWJlcltdLCByb3VuZEtleTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIHJldHVybiBzdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiByb3VuZEtleVtpXSk7XG59O1xuXG4vLyBLZXkgZXhwYW5zaW9uIC0gZ2VuZXJhdGUgcm91bmQga2V5c1xuZXhwb3J0IGNvbnN0IGtleUV4cGFuc2lvbiA9IChrZXk6IG51bWJlcltdLCBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4KTogbnVtYmVyW11bXSA9PiB7XG4gIGNvbnN0IGtleVdvcmRzID0ga2V5Lmxlbmd0aCAvIDQ7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xMjggPyAxMCA6IFxuICAgICAgICAgICAgICAgICAgICBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTkyID8gMTIgOiAxNDtcbiAgXG4gIGNvbnN0IHJvdW5kS2V5czogbnVtYmVyW11bXSA9IFtrZXkuc2xpY2UoKV07IC8vIEZpcnN0IHJvdW5kIGtleSBpcyB0aGUgb3JpZ2luYWwga2V5XG4gIFxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGNvbnN0IHByZXZLZXkgPSByb3VuZEtleXNbcm91bmQgLSAxXTtcbiAgICBjb25zdCBuZXdLZXkgPSBwcmV2S2V5LnNsaWNlKCk7XG4gICAgXG4gICAgLy8gUm90YXRlIHRoZSBsYXN0IHdvcmQgYW5kIGFwcGx5IFMtYm94XG4gICAgY29uc3QgbGFzdEluZGV4ID0gcHJldktleS5sZW5ndGggLSA0O1xuICAgIGNvbnN0IGxhc3RXb3JkID0gW3ByZXZLZXlbbGFzdEluZGV4XSwgcHJldktleVtsYXN0SW5kZXggKyAxXSwgcHJldktleVtsYXN0SW5kZXggKyAyXSwgcHJldktleVtsYXN0SW5kZXggKyAzXV07XG4gICAgY29uc3Qgcm90V29yZCA9IFtsYXN0V29yZFsxXSwgbGFzdFdvcmRbMl0sIGxhc3RXb3JkWzNdLCBsYXN0V29yZFswXV07XG4gICAgY29uc3Qgc3ViV29yZCA9IHJvdFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgXG4gICAgLy8gQXBwbHkgUmNvbiB0byB0aGUgZmlyc3QgYnl0ZVxuICAgIHN1YldvcmRbMF0gXj0gUkNPTltyb3VuZF07XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIG5ldyBrZXlcbiAgICBuZXdLZXlbMF0gPSBwcmV2S2V5WzBdIF4gc3ViV29yZFswXTtcbiAgICBuZXdLZXlbMV0gPSBwcmV2S2V5WzFdIF4gc3ViV29yZFsxXTtcbiAgICBuZXdLZXlbMl0gPSBwcmV2S2V5WzJdIF4gc3ViV29yZFsyXTtcbiAgICBuZXdLZXlbM10gPSBwcmV2S2V5WzNdIF4gc3ViV29yZFszXTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleVdvcmRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgQUVTLTI1NiB3aGVyZSBldmVyeSA0dGggd29yZCBuZWVkcyBTLWJveCB0cmFuc2Zvcm1hdGlvblxuICAgICAgaWYgKGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18yNTYgJiYgaSA9PT0gNCkge1xuICAgICAgICBjb25zdCB0ZW1wV29yZCA9IFtuZXdLZXlbb2Zmc2V0IC0gNF0sIG5ld0tleVtvZmZzZXQgLSAzXSwgbmV3S2V5W29mZnNldCAtIDJdLCBuZXdLZXlbb2Zmc2V0IC0gMV1dO1xuICAgICAgICBjb25zdCBzdWJUZW1wV29yZCA9IHRlbXBXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgICAgICBcbiAgICAgICAgbmV3S2V5W29mZnNldF0gPSBwcmV2S2V5W29mZnNldF0gXiBzdWJUZW1wV29yZFswXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDFdID0gcHJldktleVtvZmZzZXQgKyAxXSBeIHN1YlRlbXBXb3JkWzFdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBwcmV2S2V5W29mZnNldCArIDJdIF4gc3ViVGVtcFdvcmRbMl07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAzXSA9IHByZXZLZXlbb2Zmc2V0ICsgM10gXiBzdWJUZW1wV29yZFszXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0tleVtvZmZzZXRdID0gbmV3S2V5W29mZnNldCAtIDRdIF4gcHJldktleVtvZmZzZXRdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMV0gPSBuZXdLZXlbb2Zmc2V0IC0gM10gXiBwcmV2S2V5W29mZnNldCArIDFdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBuZXdLZXlbb2Zmc2V0IC0gMl0gXiBwcmV2S2V5W29mZnNldCArIDJdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgM10gPSBuZXdLZXlbb2Zmc2V0IC0gMV0gXiBwcmV2S2V5W29mZnNldCArIDNdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByb3VuZEtleXMucHVzaChuZXdLZXkpO1xuICB9XG4gIFxuICByZXR1cm4gcm91bmRLZXlzO1xufTtcblxuLy8gUGVyZm9ybSBvbmUgcm91bmQgb2YgQUVTXG5leHBvcnQgY29uc3QgYWVzUm91bmQgPSAoc3RhdGU6IG51bWJlcltdLCByb3VuZEtleTogbnVtYmVyW10sIGlzTGFzdFJvdW5kOiBib29sZWFuKTogbnVtYmVyW10gPT4ge1xuICBsZXQgbmV3U3RhdGUgPSBzdWJCeXRlcyhzdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2hpZnRSb3dzKG5ld1N0YXRlKTtcbiAgaWYgKCFpc0xhc3RSb3VuZCkge1xuICAgIG5ld1N0YXRlID0gbWl4Q29sdW1ucyhuZXdTdGF0ZSk7XG4gIH1cbiAgbmV3U3RhdGUgPSBhZGRSb3VuZEtleShuZXdTdGF0ZSwgcm91bmRLZXkpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vLyBDb21wbGV0ZSBBRVMgZW5jcnlwdGlvblxuZXhwb3J0IGNvbnN0IGFlc0VuY3J5cHQgPSAocGxhaW50ZXh0OiBzdHJpbmcsIGtleTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIC8vIEluaXRpYWwgc3RhdGVcbiAgY29uc3Qgc3RhdGUgPSB0ZXh0VG9TdGF0ZShwbGFpbnRleHQpO1xuICBcbiAgLy8gS2V5IGV4cGFuc2lvblxuICBjb25zdCByb3VuZEtleXMgPSBrZXlFeHBhbnNpb24oa2V5KTtcbiAgXG4gIC8vIEluaXRpYWwgcm91bmQgLSBqdXN0IEFkZFJvdW5kS2V5XG4gIGxldCBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShzdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgXG4gIC8vIE1haW4gcm91bmRzXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICBjdXJyZW50U3RhdGUgPSBhZXNSb3VuZChjdXJyZW50U3RhdGUsIHJvdW5kS2V5c1tyb3VuZF0sIHJvdW5kID09PSAxMCk7XG4gIH1cbiAgXG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59O1xuXG4vLyBDb252ZXJ0IGZ1bGwgdGV4dCB0byBhcnJheSBvZiAxNi1ieXRlIGJsb2Nrc1xuZXhwb3J0IGNvbnN0IHRleHRUb0Jsb2NrcyA9ICh0ZXh0OiBzdHJpbmcsIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcpOiBudW1iZXJbXVtdID0+IHtcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodGV4dCk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBcbiAgLy8gQ29udmVydCBDcnlwdG9KUyBXb3JkQXJyYXkgdG8gYnl0ZSBhcnJheSwgcmVzcGVjdGluZyBzaWdCeXRlc1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIFxuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgcGFkZGluZ1xuICBsZXQgcGFkZGVkQnl0ZXM6IG51bWJlcltdO1xuICBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuUEtDUzcpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5UEtDUzdQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSBQYWRkaW5nVHlwZS5BTlNJX1g5MjMpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5QW5zaVg5MjNQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIHsgLy8gTk9ORVxuICAgIHBhZGRlZEJ5dGVzID0gWy4uLmJ5dGVzXTtcbiAgICAvLyBGb3IgTk9ORSBwYWRkaW5nLCBtdXN0IGJlIG11bHRpcGxlIG9mIDE2XG4gICAgd2hpbGUgKHBhZGRlZEJ5dGVzLmxlbmd0aCAlIDE2ICE9PSAwKSB7XG4gICAgICBwYWRkZWRCeXRlcy5wdXNoKDApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3BsaXQgaW50byAxNi1ieXRlIGJsb2Nrc1xuICBjb25zdCBibG9ja3M6IG51bWJlcltdW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCeXRlcy5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBibG9ja3MucHVzaChwYWRkZWRCeXRlcy5zbGljZShpLCBpICsgMTYpKTtcbiAgfVxuICBcbiAgcmV0dXJuIGJsb2Nrcztcbn07XG5cbi8vIEFwcGx5IFBLQ1M3IHBhZGRpbmdcbmV4cG9ydCBjb25zdCBhcHBseVBLQ1M3UGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGVkID0gWy4uLmRhdGFdO1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmdMZW5ndGg7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKHBhZGRpbmdMZW5ndGgpO1xuICB9XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gQXBwbHkgQU5TSSBYLjkyMyBwYWRkaW5nXG5leHBvcnQgY29uc3QgYXBwbHlBbnNpWDkyM1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRlZCA9IFsuLi5kYXRhXTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICBcbiAgLy8gQWRkIHBhZGRpbmcgYnl0ZXMgKDB4MDApIGV4Y2VwdCB0aGUgbGFzdCBieXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGluZ0xlbmd0aCAtIDE7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKDB4MDApO1xuICB9XG4gIFxuICAvLyBBZGQgdGhlIHBhZGRpbmcgbGVuZ3RoIGFzIHRoZSBsYXN0IGJ5dGVcbiAgcGFkZGVkLnB1c2gocGFkZGluZ0xlbmd0aCk7XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gUmVtb3ZlIEFOU0kgWC45MjMgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IHJlbW92ZUFuc2lYOTIzUGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBwYWRkaW5nTGVuZ3RoKTtcbn07XG5cbi8vIEdldCBJViBmb3IgQ0JDIG1vZGVcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUlWID0gKCk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaXYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgaXYucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgfVxuICByZXR1cm4gaXY7XG59O1xuXG4vLyBHZXQgYWxsIGludGVybWVkaWF0ZSBzdGF0ZXMgZm9yIHZpc3VhbGl6YXRpb25cbmV4cG9ydCB0eXBlIEFlc1N0ZXAgPSB7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHN0YXRlOiBudW1iZXJbXTtcbiAgYWN0aXZlSW5kaWNlcz86IG51bWJlcltdOyAgLy8gRm9yIGhpZ2hsaWdodGluZyBzcGVjaWZpYyBjZWxsc1xuICBleHBsYW5hdGlvbj86IHN0cmluZzsgICAgICAvLyBNb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uXG4gIHJvdW5kS2V5PzogbnVtYmVyW107XG4gIHByZXZpb3VzU3RhdGU/OiBudW1iZXJbXTsgIC8vIEZvciBzaG93aW5nIGJlZm9yZS9hZnRlciBjb21wYXJpc29uXG59O1xuXG4vLyBHZXQgQUVTIHN0ZXBzIGZvciBhIHNpbmdsZSBibG9jayAoMTYgYnl0ZXMpXG5leHBvcnQgY29uc3QgZ2V0QWVzU3RlcHNGb3JCbG9jayA9IChcbiAgYmxvY2s6IG51bWJlcltdLFxuICBrZXk6IG51bWJlcltdLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIGJsb2NrSW5kZXg6IG51bWJlciA9IDAsXG4gIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrPzogbnVtYmVyW10sXG4gIGl2PzogbnVtYmVyW11cbik6IHtcbiAgc3RlcHM6IEFlc1N0ZXBbXSxcbiAgZmluYWxTdGF0ZTogbnVtYmVyW11cbn0gPT4ge1xuICBjb25zdCBzdGVwczogQWVzU3RlcFtdID0gW107XG4gIFxuICAvLyBFbnN1cmUgYmxvY2sgaXMgZXhhY3RseSAxNiBieXRlc1xuICBjb25zdCBwbGFpbnRleHRCeXRlcyA9IFsuLi5ibG9ja107XG4gIHdoaWxlIChwbGFpbnRleHRCeXRlcy5sZW5ndGggPCAxNikge1xuICAgIHBsYWludGV4dEJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIEFzbCBvY2hpcSBtYXRuYCwgXG4gICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSBiYXl0Z2EgYXlsYW50aXJpbGFkaSB2YSA0w5c0IG1hdHJpdHNhIHNoYWtsaWRhIGlmb2RhbGFuYWRpLmBcbiAgfSk7XG4gIFxuICBjb25zdCBpbml0aWFsU3RhdGUgPSBwbGFpbnRleHRCeXRlcztcbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSk7XG4gIFxuICBsZXQgY3VycmVudFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoYmxvY2tJbmRleCA9PT0gMCAmJiBpdikge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaXZbaV0pO1xuICAgICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBJViBiaWxhbiBYT1JgLCBcbiAgICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHJvdW5kS2V5OiBpdixcbiAgICAgICAgICBleHBsYW5hdGlvbjogYENCQzogYmlyaW5jaGkgYmxvayBJViBiaWxhbiBYT1IgcWlsaW5hZGkuYFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2spIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrW2ldKTtcbiAgICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgT2xkaW5naSBjaXBoZXJ0ZXh0IGJpbGFuIFhPUmAsIFxuICAgICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgICAgcm91bmRLZXk6IHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ0JDOiBrZXlpbmdpIGJsb2tsYXIgb2xkaW5naSBjaXBoZXJ0ZXh0IGJsb2tpIGJpbGFuIFhPUiBxaWxpbmFkaS5gXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGlmICghaXYpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcHM6IFtdLCBmaW5hbFN0YXRlOiBwbGFpbnRleHRCeXRlcyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY291bnRlckJsb2NrID0gWy4uLml2XTtcbiAgICAgIGxldCBjb3VudGVyVmFsdWUgPSBibG9ja0luZGV4O1xuICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDAgJiYgY291bnRlclZhbHVlID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJCbG9ja1tpXSArIChjb3VudGVyVmFsdWUgJiAweGZmKTtcbiAgICAgICAgY291bnRlckJsb2NrW2ldID0gc3VtICYgMHhmZjtcbiAgICAgICAgY291bnRlclZhbHVlID0gKGNvdW50ZXJWYWx1ZSA+PiA4KSArIChzdW0gPj4gOCk7XG4gICAgICB9XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQ291bnRlcmAsIFxuICAgICAgICBzdGF0ZTogY291bnRlckJsb2NrLFxuICAgICAgICBleHBsYW5hdGlvbjogYENUUjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSB1Y2h1biBjb3VudGVyLmBcbiAgICAgIH0pO1xuICAgICAgY3VycmVudFN0YXRlID0gY291bnRlckJsb2NrO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQm9zaGxhbmcnaWNoYCwgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgRUNCOiBibG9rICR7YmxvY2tJbmRleCArIDF9IG11c3RhcWlsIHNoaWZybGFuYWRpLmBcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGNvbnN0IGFmdGVySW5pdGlhbFJvdW5kID0gYWRkUm91bmRLZXkoY3VycmVudFN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAwLWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgc3RhdGU6IGFmdGVySW5pdGlhbFJvdW5kLFxuICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgZXhwbGFuYXRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9OiBib3NobGFuZydpY2ggQWRkUm91bmRLZXkuYCxcbiAgICByb3VuZEtleTogcm91bmRLZXlzWzBdLFxuICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgfSk7XG4gIFxuICBjdXJyZW50U3RhdGUgPSBhZnRlckluaXRpYWxSb3VuZDtcbiAgXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICBjb25zdCBhZnRlclN1YkJ5dGVzID0gc3ViQnl0ZXMoY3VycmVudFN0YXRlKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFN1YkJ5dGVzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTdWJCeXRlcyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX06IFN1YkJ5dGVzLmAsXG4gICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGVcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBhZnRlclNoaWZ0Um93cyA9IHNoaWZ0Um93cyhhZnRlclN1YkJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFNoaWZ0Um93c2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU2hpZnRSb3dzLFxuICAgICAgYWN0aXZlSW5kaWNlczogWzEsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMSwgMTMsIDE0LCAxNV0sXG4gICAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX06IFNoaWZ0Um93cy5gLFxuICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTdWJCeXRlc1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXk6IG51bWJlcltdO1xuICAgIFxuICAgIGlmIChyb3VuZCA8IDEwKSB7XG4gICAgICBjb25zdCBhZnRlck1peENvbHVtbnMgPSBtaXhDb2x1bW5zKGFmdGVyU2hpZnRSb3dzKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAke3JvdW5kfS1ib3NxaWNoIOKAlCBNaXhDb2x1bW5zYCwgXG4gICAgICAgIHN0YXRlOiBhZnRlck1peENvbHVtbnMsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfTogTWl4Q29sdW1ucy5gLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclNoaWZ0Um93c1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyTWl4Q29sdW1ucywgcm91bmRLZXlzW3JvdW5kXSk7XG4gICAgICBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkgPSBhZnRlck1peENvbHVtbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyU2hpZnRSb3dzLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyU2hpZnRSb3dzO1xuICAgIH1cbiAgICBcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfTogQWRkUm91bmRLZXkuYCxcbiAgICAgIHJvdW5kS2V5OiByb3VuZEtleXNbcm91bmRdLFxuICAgICAgcHJldmlvdXNTdGF0ZTogcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5LFxuICAgIH0pO1xuICB9XG4gIFxuICBsZXQgZmluYWxTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGluaXRpYWxTdGF0ZVtpXSk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQ291bnRlciBYT1JgLCBcbiAgICAgICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgQ1RSOiBibG9rICR7YmxvY2tJbmRleCArIDF9IHVjaHVuIGNvdW50ZXIgWE9SLmAsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcm91bmRLZXk6IGN1cnJlbnRTdGF0ZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBZYWt1bml5YCwgXG4gICAgc3RhdGU6IGZpbmFsU3RhdGUsXG4gICAgZXhwbGFuYXRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IHVjaHVuIHlha3VuaXkgc2hpZnJsYW5nYW4gbmF0aWphLmBcbiAgfSk7XG4gIFxuICByZXR1cm4geyBzdGVwcywgZmluYWxTdGF0ZSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFlc1N0ZXBzID0gKFxuICBwbGFpbnRleHQ6IHN0cmluZywgXG4gIGtleTogbnVtYmVyW10sIFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcsXG4gIHByb3ZpZGVkSXY/OiBudW1iZXJbXVxuKToge1xuICBzdGVwczogQWVzU3RlcFtdLFxuICBmaW5hbENpcGhlcnRleHQ6IHtcbiAgICBiYXNlNjQ6IHN0cmluZztcbiAgICBoZXg6IHN0cmluZztcbiAgICBiaW5hcnk6IHN0cmluZztcbiAgfSxcbiAgaXY/OiBudW1iZXJbXSxcbiAgYWxsQmxvY2tzPzogeyBibG9ja0luZGV4OiBudW1iZXIsIHN0ZXBzOiBBZXNTdGVwW10sIGZpbmFsU3RhdGU6IG51bWJlcltdIH1bXVxufSA9PiB7XG4gIGNvbnN0IHN0ZXBzOiBBZXNTdGVwW10gPSBbXTtcbiAgbGV0IGl2OiBudW1iZXJbXSB8IHVuZGVmaW5lZCA9IHByb3ZpZGVkSXYgPyBbLi4ucHJvdmlkZWRJdl0gOiB1bmRlZmluZWQ7XG4gIFxuICAvLyBDb252ZXJ0IGZ1bGwgdGV4dCB0byBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gdGV4dFRvQmxvY2tzKHBsYWludGV4dCwgcGFkZGluZyk7XG4gIGNvbnN0IGFsbEJsb2NrczogeyBibG9ja0luZGV4OiBudW1iZXIsIHN0ZXBzOiBBZXNTdGVwW10sIGZpbmFsU3RhdGU6IG51bWJlcltdIH1bXSA9IFtdO1xuICBcbiAgLy8gQ29udmVydCBwbGFpbnRleHQgdG8gYnl0ZXMgKGZvciBmaXJzdCBibG9jayB2aXN1YWxpemF0aW9uKVxuICBsZXQgcGxhaW50ZXh0Qnl0ZXMgPSBibG9ja3NbMF0gfHwgdGV4dFRvU3RhdGUocGxhaW50ZXh0KTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiAnQXNsIG9jaGlxIG1hdG4nLCBcbiAgICBzdGF0ZTogcGxhaW50ZXh0Qnl0ZXMsXG4gICAgZXhwbGFuYXRpb246IGBPY2hpcSBtYXRuIFwiJHtwbGFpbnRleHR9XCIgYmF5dGdhIGF5bGFudGlyaWxhZGkgdmEgNMOXNCBtYXRyaXRzYSBzaGFrbGlkYSBpZm9kYWxhbmFkaS5gXG4gIH0pO1xuICBcbiAgLy8gQXBwbHkgcGFkZGluZyBpZiBuZWVkZWRcbiAgaWYgKHBhZGRpbmcgPT09IFBhZGRpbmdUeXBlLkFOU0lfWDkyMykge1xuICAgIHBsYWludGV4dEJ5dGVzID0gYXBwbHlBbnNpWDkyM1BhZGRpbmcocGxhaW50ZXh0Qnl0ZXMpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiAnQU5TSSBYLjkyMyB0b+KAmGxkaXJpc2hkYW4ga2V5aW4nLCBcbiAgICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICAgIGV4cGxhbmF0aW9uOiAnQU5TSSBYLjkyMyB0b+KAmGxkaXJpc2ggbm9sbGFyIGJpbGFuIHRv4oCYbGRpcmFkaSB2YSBveGlyZ2kgYnl0ZSBnYSB0b+KAmGxkaXJpc2ggdXp1bmxpZ2luaSBxb+KAmHlhZGkuJ1xuICAgIH0pO1xuICB9XG4gIFxuICAvLyBHZW5lcmF0ZSBJViBmb3IgQ0JDL0NUUiBtb2RlIG9ubHkgaWYgbm90IHByb3ZpZGVkXG4gIGlmICgobW9kZSA9PT0gQWVzTW9kZS5DQkMgfHwgbW9kZSA9PT0gQWVzTW9kZS5DVFIpICYmICFpdikge1xuICAgIGl2ID0gZ2VuZXJhdGVJVigpO1xuICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBPbmx5IHNob3cgSVYgc3RlcCBpZiBzaW5nbGUgYmxvY2sgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgY29uc3QgaXZEZXNjcmlwdGlvbiA9IG1vZGUgPT09IEFlc01vZGUuQ0JDIFxuICAgICAgICA/ICdCb3NobGFuZ1xcJ2ljaCB2ZWt0b3IgKEluaXRpYWxpemF0aW9uIFZlY3RvciwgSVYpJyBcbiAgICAgICAgOiAnQ291bnRlciAoTm9uY2UpJztcbiAgICAgIGNvbnN0IGl2RXhwbGFuYXRpb24gPSBgJHttb2RlID09PSBBZXNNb2RlLkNCQyA/ICdDQkMnIDogJ0NUUid9IHJlamltaSB1Y2h1biAxNi1iYXl0IHRhc29kaWZpeSAke21vZGUgPT09IEFlc01vZGUuQ0JDID8gJ0lWJyA6ICdOb25jZSd9IHlhcmF0aWxhZGkuYDtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGl2RGVzY3JpcHRpb24sXG4gICAgICAgIHN0YXRlOiBpdixcbiAgICAgICAgZXhwbGFuYXRpb246IGl2RXhwbGFuYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RhcnQgZW5jcnlwdGlvbiBwcm9jZXNzIChmb3IgZmlyc3QgYmxvY2sgdmlzdWFsaXphdGlvbilcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGxhaW50ZXh0Qnl0ZXM7XG4gIFxuICAvLyBLZXkgZXhwYW5zaW9uXG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXkpO1xuICBcbiAgLy8gSW5pdGlhbCBzZXR1cCBiYXNlZCBvbiBtb2RlXG4gIGxldCBjdXJyZW50U3RhdGU6IG51bWJlcltdO1xuICBcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgIGlmICghaXYpIGl2ID0gZ2VuZXJhdGVJVigpOyAvLyBGYWlsc2FmZVxuICAgICAgLy8gWE9SIHBsYWludGV4dCB3aXRoIElWXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaXYhW2ldKVxuXG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQm9zaGxhbmdcXCdpY2ggaG9sYXRuaSBJViBiaWxhbiBYT1IgcWlsaXNoJywgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcm91bmRLZXk6IGl2LCAvLyBJViBuaSByb3VuZEtleSBzaWZhdGlkYSBrbydyc2F0aXNoIHVjaHVuXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgQ0JDIHJlamltaWRhIHNoaWZybGFzaCBib3NobGFuaXNoaWRhbiBvbGRpbiBvY2hpcSBtYXRuIElWIGJpbGFuIFhPUiBxaWxpbmFkaS4gQnUgamFyYXlvbiBDQkMgcmVqaW1pbmluZyBhc29zaXkgeHVzdXNpeWF0aWRpciAtIGhhciBiaXIgb2NoaXEgbWF0biBibG9raSBhdnZhbGdpIHNoaWZybGFuZ2FuIG1hdG4gYmxva2kgKHlva2kgYmlyaW5jaGkgYmxvayB1Y2h1biBJVikgYmlsYW4gWE9SIHFpbGluYWRpLCBrZXlpbiBzaGlmcmxhbmFkaS4gQnUgYmlyIHhpbCBvY2hpcSBtYXRuIGJsb2tsYXJpbmkgdHVybGkgc2hpZnJsYW5nYW4gbWF0biBibG9rbGFyZ2EgYXlsYW50aXJhZGkgdmEgc2hpZnJsYW5nYW4gbWF0bmRhZ2kgbmFxc2hsYXJuaSB5YXNoaXJpc2hnYSB5b3JkYW0gYmVyYWRpLmBcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIC8vIEluIENUUiBtb2RlLCB3ZSBlbmNyeXB0IGEgY291bnRlciB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBwbGFpbnRleHRcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBpdiB8fCBnZW5lcmF0ZUlWKCk7XG4gICAgICBpZiAoIWl2KSBpdiA9IGNvdW50ZXI7XG4gICAgICBcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb3VudGVyIHFpeW1hdGknLCBcbiAgICAgICAgc3RhdGU6IGNvdW50ZXIsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnQ1RSIHJlamltaWRhIG9jaGlxIG1hdG4gb+KAmHJuaWdhIGNvdW50ZXIgcWl5bWF0aSBzaGlmcmxhbmFkaS4nXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY3VycmVudFN0YXRlID0gY291bnRlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Jvc2hsYW5n4oCYaWNoIGhvbGF0IChvY2hpcSBtYXRuKScsIFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0VDQiByZWppbWlkYSBvY2hpcSBtYXRuIGJsb2tsYXJpIG11c3RhcWlsIHJhdmlzaGRhIHNoaWZybGFuYWRpLidcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIC8vIEluaXRpYWwgcm91bmQgLSBqdXN0IEFkZFJvdW5kS2V5IChSb3VuZCAwKVxuICBjb25zdCBhZnRlckluaXRpYWxSb3VuZCA9IGFkZFJvdW5kS2V5KGN1cnJlbnRTdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiAnMC1ib3NxaWNoIOKAlCBCb3NobGFuZ1xcJ2ljaCBBZGRSb3VuZEtleScsIFxuICAgIHN0YXRlOiBhZnRlckluaXRpYWxSb3VuZCxcbiAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICByb3VuZEtleTogcm91bmRLZXlzWzBdLFxuICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgfSk7XG4gIFxuICBjdXJyZW50U3RhdGUgPSBhZnRlckluaXRpYWxSb3VuZDtcbiAgXG4gIC8vIE1haW4gcm91bmRzXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gMTA7IHJvdW5kKyspIHtcbiAgICAvLyBTdWJCeXRlc1xuICAgIGNvbnN0IGFmdGVyU3ViQnl0ZXMgPSBzdWJCeXRlcyhjdXJyZW50U3RhdGUpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgU3ViQnl0ZXNgLCBcbiAgICAgIHN0YXRlOiBhZnRlclN1YkJ5dGVzLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiBgSGFyIGJpciBiYXl0IFMtYm94IGphZHZhbGlkYWdpIG1vcyBxaXltYXQgYmlsYW4gYWxtYXNodGlyaWxhZGkuIEJ1IEFFUyBhbGdvcml0bWlkYWdpIHlhZ29uYSBuby1jaGl6aXFsaSBhbWFsIGhpc29ibGFuYWRpLmAsXG4gICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGUgLy8gQWRkIHByZXZpb3VzIHN0YXRlIGZvciBTLWJveCBsb29rdXBcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTaGlmdFJvd3NcbiAgICBjb25zdCBhZnRlclNoaWZ0Um93cyA9IHNoaWZ0Um93cyhhZnRlclN1YkJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIFNoaWZ0Um93c2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU2hpZnRSb3dzLFxuICAgICAgYWN0aXZlSW5kaWNlczogWzEsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMSwgMTMsIDE0LCAxNV0sIC8vIFJvd3MgMSwgMiwgMyAobm90IFJvdyAwKSBpbiBjb2x1bW4tbWFqb3JcbiAgICAgIGV4cGxhbmF0aW9uOiBgSG9sYXQgbWF0cml0c2FzaW5pbmcgcWF0b3JsYXJpIGNoYXAgdG9tb25nYSBxdXlpZGFnaWNoYSBzaWxqaXRpbGFkaTogMC1xYXRvciDigJMgMCB0YSwgMS1xYXRvciDigJMgMSB0YSwgMi1xYXRvciDigJMgMiB0YSB2YSAzLXFhdG9yIOKAkyAzIHRhIGJheXRnYS5gLFxuICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTdWJCeXRlcyAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIGNvbXBhcmlzb25cbiAgICB9KTtcbiAgICBcbiAgICBsZXQgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5OiBudW1iZXJbXTtcbiAgICBcbiAgICBpZiAocm91bmQgPCAxMCkge1xuICAgICAgLy8gTWl4Q29sdW1ucyAobm90IGluIGZpbmFsIHJvdW5kKVxuICAgICAgY29uc3QgYWZ0ZXJNaXhDb2x1bW5zID0gbWl4Q29sdW1ucyhhZnRlclNoaWZ0Um93cyk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgTWl4Q29sdW1uc2AsIFxuICAgICAgICBzdGF0ZTogYWZ0ZXJNaXhDb2x1bW5zLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogYEhhciBiaXIgdXN0dW4gR2Fsb2lzIG1heWRvbmkgdXN0aWRhIGNoaXppcWxpIG8nemdhcnRpcmlzaCBvcnFhbGkgbyd6Z2FydGlyaWxhZGkuXG4gICAgICAgICAgICAgICAgICAgICAgQnUgamFyYXlvbiBzaGlmcmRhIGRpZmZ1eml5YSAoeWEnbmkgbWEnbHVtb3RsYXJuaW5nIGtlbmcgdGFycWFsaXNoaSkgbmkgdGEnbWlubGF5ZGkuYCxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTaGlmdFJvd3MgLy8gQWRkIHByZXZpb3VzIHN0YXRlIGZvciBNaXhDb2x1bW5zIGNvbXBhcmlzb25cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBZGRSb3VuZEtleVxuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJNaXhDb2x1bW5zLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyTWl4Q29sdW1ucztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluYWwgcm91bmQgaGFzIG5vIE1peENvbHVtbnNcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KGFmdGVyU2hpZnRSb3dzLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyU2hpZnRSb3dzO1xuICAgIH1cbiAgICBcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiBgSG9sYXQgICR7cm91bmR9LWJvc3FpY2hkYWdpIFJvdW5kIEthbGl0IGJpbGFuIFhPUiBhbWFsaXlvdGkgb3JxYWxpIGJpcmxhc2h0aXJpbGFkaS5gLFxuICAgICAgcm91bmRLZXk6IHJvdW5kS2V5c1tyb3VuZF0sXG4gICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXksXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEZpbmFsIG91dHB1dCBiYXNlZCBvbiBtb2RlXG4gIGxldCBmaW5hbFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICAvLyBPdXRwdXQgaXMgdGhlIGN1cnJlbnQgc3RhdGUgKGFscmVhZHkgY29tcGxldGVkIGVuY3J5cHRpb24pXG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIC8vIFhPUiB0aGUgZW5jcnlwdGVkIGNvdW50ZXIgd2l0aCBwbGFpbnRleHRcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaW5pdGlhbFN0YXRlW2ldKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdPY2hpcSBtYXRuIHNoaWZybGFuZ2FuIGhpc29ibGFnaWNoIGJpbGFuIFhPUiBhbWFsaXlvdGlkYSBiaXJsYXNodGlyaWxhZGkuJywgXG4gICAgICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0NUUiByZWppbWlkYSwgeWFrdW5peSBib3NxaWNoZGEgc2hpZnJsYW5nYW4gaGlzb2JsYWdpY2ggb2NoaXEgbWF0biBiaWxhbiBYT1IgYW1hbGl5b3RpIG9ycWFsaSBiaXJsYXNodGlyaWxhZGkgdmEgbmF0aWphZGEgc2hpZnJsYW5nYW4gbWF0biBob3NpbCBib+KAmGxhZGkuJyxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogY3VycmVudFN0YXRlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICdZYWt1bml5IHNoaWZybGFuZ2FuIG1hdG4nLCBcbiAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICBleHBsYW5hdGlvbjogYCR7bW9kZX0gcmVqaW1pZGEgQUVTLTEyOCB5b3JkYW1pZGEgb2xpbmdhbiB5YWt1bml5IHNoaWZybGFuZ2FuIG5hdGlqYS5gXG4gIH0pO1xuICBcbiAgLy8gUHJvY2VzcyBhbGwgYmxvY2tzIGZvciBtdWx0aS1ibG9jayBzdXBwb3J0XG4gIGxldCBwcmV2aW91c0NpcGhlcnRleHRCbG9jazogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGNvbWJpbmVkRmluYWxTdGF0ZXM6IG51bWJlcltdID0gW107XG4gIFxuICAvLyBHZW5lcmF0ZSBJViBpZiBuZWVkZWRcbiAgaWYgKChtb2RlID09PSBBZXNNb2RlLkNCQyB8fCBtb2RlID09PSBBZXNNb2RlLkNUUikgJiYgIWl2KSB7XG4gICAgaXYgPSBnZW5lcmF0ZUlWKCk7XG4gIH1cbiAgXG4gIGZvciAobGV0IGJsb2NrSW5kZXggPSAwOyBibG9ja0luZGV4IDwgYmxvY2tzLmxlbmd0aDsgYmxvY2tJbmRleCsrKSB7XG4gICAgY29uc3QgYmxvY2tSZXN1bHQgPSBnZXRBZXNTdGVwc0ZvckJsb2NrKFxuICAgICAgYmxvY2tzW2Jsb2NrSW5kZXhdLFxuICAgICAga2V5LFxuICAgICAgbW9kZSxcbiAgICAgIGJsb2NrSW5kZXgsXG4gICAgICBwcmV2aW91c0NpcGhlcnRleHRCbG9jayxcbiAgICAgIGl2XG4gICAgKTtcbiAgICBcbiAgICBhbGxCbG9ja3MucHVzaCh7XG4gICAgICBibG9ja0luZGV4LFxuICAgICAgc3RlcHM6IGJsb2NrUmVzdWx0LnN0ZXBzLFxuICAgICAgZmluYWxTdGF0ZTogYmxvY2tSZXN1bHQuZmluYWxTdGF0ZVxuICAgIH0pO1xuICAgIFxuICAgIGNvbWJpbmVkRmluYWxTdGF0ZXMucHVzaCguLi5ibG9ja1Jlc3VsdC5maW5hbFN0YXRlKTtcbiAgICBcbiAgICAvLyBGb3IgQ0JDIG1vZGUsIHVzZSBjdXJyZW50IGNpcGhlcnRleHQgYXMgcHJldmlvdXMgZm9yIG5leHQgYmxvY2tcbiAgICBpZiAobW9kZSA9PT0gQWVzTW9kZS5DQkMpIHtcbiAgICAgIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrID0gYmxvY2tSZXN1bHQuZmluYWxTdGF0ZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFVzZSBjb21iaW5lZCBmaW5hbCBzdGF0ZXMgaWYgd2UgaGF2ZSBtdWx0aXBsZSBibG9ja3MsIG90aGVyd2lzZSB1c2Ugc2luZ2xlIGJsb2NrIHJlc3VsdFxuICBjb25zdCBmaW5hbFN0YXRlVG9Vc2UgPSBibG9ja3MubGVuZ3RoID4gMSA/IGNvbWJpbmVkRmluYWxTdGF0ZXMgOiBmaW5hbFN0YXRlO1xuICBcbiAgLy8gQ29udmVydCB0aGUgZmluYWwgc3RhdGUgdG8gdGhlIHJlcXVlc3RlZCBvdXRwdXQgZm9ybWF0XG4gIGNvbnN0IGZpbmFsV29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoXG4gICAgbmV3IFVpbnQ4QXJyYXkoZmluYWxTdGF0ZVRvVXNlKSBhcyBhbnlcbiAgKTtcbiAgXG4gIGNvbnN0IGZpbmFsQ2lwaGVydGV4dEJhc2U2NCA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KGZpbmFsV29yZEFycmF5KTtcbiAgY29uc3QgZmluYWxDaXBoZXJ0ZXh0SGV4ID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoZmluYWxXb3JkQXJyYXkpO1xuICBjb25zdCBmaW5hbENpcGhlcnRleHRCaW5hcnkgPSBieXRlc1RvQmluYXJ5KGZpbmFsU3RhdGVUb1VzZSwgJycpO1xuICBcbiAgcmV0dXJuIHsgXG4gICAgc3RlcHMsIFxuICAgIGZpbmFsQ2lwaGVydGV4dDoge1xuICAgICAgYmFzZTY0OiBmaW5hbENpcGhlcnRleHRCYXNlNjQsXG4gICAgICBoZXg6IGZpbmFsQ2lwaGVydGV4dEhleCxcbiAgICAgIGJpbmFyeTogZmluYWxDaXBoZXJ0ZXh0QmluYXJ5XG4gICAgfSwgXG4gICAgaXYsXG4gICAgYWxsQmxvY2tzOiBhbGxCbG9ja3MubGVuZ3RoID4gMSA/IGFsbEJsb2NrcyA6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuLy8gR2V0IGtleSBleHBhbnNpb24gc3RlcHMgd2l0aCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRLZXlFeHBhbnNpb25TdGVwcyA9IChrZXk6IG51bWJlcltdKTogeyBcbiAgZGVzY3JpcHRpb246IHN0cmluZywgXG4gIGtleTogbnVtYmVyW10sXG4gIGV4cGxhbmF0aW9uPzogc3RyaW5nLFxuICBoaWdobGlnaHRlZENlbGxzPzogbnVtYmVyW11cbn1bXSA9PiB7XG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXkpO1xuICBjb25zdCBzdGVwcyA9IFtdO1xuICBcbiAgc3RlcHMucHVzaCh7XG4gICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ+KAmGljaCBrYWxpdCcsXG4gICAga2V5OiByb3VuZEtleXNbMF0sXG4gICAgZXhwbGFuYXRpb246ICdCdSBmb3lkYWxhbnV2Y2hpIHRvbW9uaWRhbiBiZXJpbGdhbiBhc2wgMTI4LWJpdGxpIGthbGl0ZGlyLidcbiAgfSk7XG4gIFxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IDEwOyByb3VuZCsrKSB7XG4gICAgY29uc3QgcHJldktleSA9IHJvdW5kS2V5c1tyb3VuZCAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRLZXkgPSByb3VuZEtleXNbcm91bmRdO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtYXRpb25zIGZvciBhIG1vcmUgZGV0YWlsZWQgZXhwbGFuYXRpb25cbiAgICBjb25zdCBsYXN0V29yZCA9IFtwcmV2S2V5WzEyXSwgcHJldktleVsxM10sIHByZXZLZXlbMTRdLCBwcmV2S2V5WzE1XV07XG4gICAgY29uc3Qgcm90V29yZCA9IFtsYXN0V29yZFsxXSwgbGFzdFdvcmRbMl0sIGxhc3RXb3JkWzNdLCBsYXN0V29yZFswXV07XG4gICAgY29uc3Qgc2JveFdvcmQgPSByb3RXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgIGNvbnN0IHJjb25WYWx1ZSA9IFJDT05bcm91bmRdO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkV29yZCA9IFsuLi5zYm94V29yZF07XG4gICAgdHJhbnNmb3JtZWRXb3JkWzBdIF49IHJjb25WYWx1ZTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIHByZXZpb3VzIGtleSBhbmQgaXRzIFhPUiB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB3b3JkXG4gICAgY29uc3QgZmlyc3RXb3JkUHJldiA9IFtwcmV2S2V5WzBdLCBwcmV2S2V5WzFdLCBwcmV2S2V5WzJdLCBwcmV2S2V5WzNdXTtcbiAgICBjb25zdCB4b3JSZXN1bHQgPSBmaXJzdFdvcmRQcmV2Lm1hcCgoYnl0ZSwgaW5kZXgpID0+IGJ5dGUgXiB0cmFuc2Zvcm1lZFdvcmRbaW5kZXhdKTtcblxuXG4gICAgLy8gU2hvdyB0aGUga2V5IHdpdGggaGlnaGxpZ2h0ZWQgY2VsbHMgZm9yIHRoZSBuZXcgd29yZFxuICAgIHN0ZXBzLnB1c2goe1xuICAgICAgZGVzY3JpcHRpb246IGBSb3VuZCBrYWxpdGkgJHtyb3VuZH1gLFxuICAgICAga2V5OiBjdXJyZW50S2V5LFxuICAgICAgZXhwbGFuYXRpb246IGBcbiAgICAgICAgJHtyb3VuZH0tcm91bmQgdWNodW4ga2FsaXRuaSBrZW5nYXl0aXJpc2ggamFyYXlvbmk6XG4gICAgICAgIDEuIE9sZGluZ2kga2FsaXRuaW5nIG94aXJnaSB3b3JkIHFpc21pbmkgb2xpbmc6IFske2xhc3RXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICAyLiBXb3JkbmkgYXlsYW50aXJpbmc6IFske3JvdFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDMuIEF5bGFudGlyaWxnYW4gd29yZCBnYSBTLWJveCBuaSBxb+KAmGxsYW5nOiBbJHtzYm94V29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgNC4gQmlyaW5jaGkgYmF5dGdhIFJDT04gKFJvdW5kIENvbnN0YW50ICR7cmNvblZhbHVlLnRvU3RyaW5nKDE2KX0pIG5pIHFv4oCYbGxhbmc6XG4gICAgICAgICAgTmF0aWphOiBbJHt0cmFuc2Zvcm1lZFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDUuIE9sZGluZ2kga2FsaXRuaW5nIGJpcmluY2hpIHdvcmQgaTogWyR7Zmlyc3RXb3JkUHJldi5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV0gbmkgb+KAmHpnYXJ0aXJpbGdhbiB3b3JkIGJpbGFuIFhPUiBxaWxpbmc6IFske3RyYW5zZm9ybWVkV29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV0sIG5hdGlqYWRhOiBbJHt4b3JSZXN1bHQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dIGhvc2lsIGJv4oCYbGFkaS4gU2/igJhuZ3JhIHFvbGdhbiB3b3JkIGxhciBzaHUgdGFyemRhIGhvc2lsIHFpbGluYWRpLlxuICAgICAgYCxcbiAgICAgIGhpZ2hsaWdodGVkQ2VsbHM6IFswLCAxLCAyLCAzXSAvLyBIaWdobGlnaHQgdGhlIGZpcnN0IHdvcmQgdGhhdCdzIGRpcmVjdGx5IHRyYW5zZm9ybWVkXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBzdGVwcztcbn07XG5cbi8vIFJldHVybiBpbnRlcm1lZGlhdGUgc3RlcHMgZm9yIGVhY2ggd29yZCBleHBhbnNpb24gZm9yIHZpc3VhbGl6YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlTY2hlZHVsZURldGFpbGVkU3RlcHMoa2V5OiBudW1iZXJbXSwga2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgpIHtcbiAgY29uc3Qga2V5V29yZHMgPSBrZXkubGVuZ3RoIC8gNDtcbiAgY29uc3QgbnVtUm91bmRzID0ga2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzEyOCA/IDEwIDoga2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzE5MiA/IDEyIDogMTQ7XG5cbiAgLy8gRmxhdHRlbiBieXRlIGFycmF5IC0+IHdvcmRzXG4gIGxldCBwcmV2S2V5ID0ga2V5LnNsaWNlKCk7XG4gIGxldCByb3VuZEtleXMgPSBbcHJldktleS5zbGljZSgpXTtcblxuICAvLyBGb3IgcmVzdWx0IHZpc3VhbGl6YXRpb246IGVhY2ggc3RlcCBmb3IgZWFjaCByb3VuZFxuICBsZXQgc3RlcHNQZXJSb3VuZCA9IFtdO1xuXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gbnVtUm91bmRzOyByb3VuZCsrKSB7XG4gICAgbGV0IHN0ZXBEZXRhaWxzID0gW107XG4gICAgbGV0IG5ld0tleSA9IHByZXZLZXkuc2xpY2UoKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBwcmV2S2V5Lmxlbmd0aCAtIDQ7XG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVtsYXN0SW5kZXhdLCBwcmV2S2V5W2xhc3RJbmRleCArIDFdLCBwcmV2S2V5W2xhc3RJbmRleCArIDJdLCBwcmV2S2V5W2xhc3RJbmRleCArIDNdXTtcblxuICAgIC8vIFN0ZXAgMTogUm90V29yZFxuICAgIGNvbnN0IHJvdFdvcmQgPSBbbGFzdFdvcmRbMV0sIGxhc3RXb3JkWzJdLCBsYXN0V29yZFszXSwgbGFzdFdvcmRbMF1dO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1JvdFdvcmQnLCBpbnB1dDogbGFzdFdvcmQuc2xpY2UoKSwgb3V0cHV0OiByb3RXb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDI6IFN1YkJ5dGVzIChTLWJveClcbiAgICBjb25zdCBzYm94V29yZCA9IHJvdFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnU3ViQnl0ZXMnLCBpbnB1dDogcm90V29yZC5zbGljZSgpLCBvdXRwdXQ6IHNib3hXb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDM6IFJjb24gdG8gZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJjb25WYWx1ZSA9IFJDT05bcm91bmRdO1xuICAgIGNvbnN0IHJjb25Xb3JkID0gc2JveFdvcmQuc2xpY2UoKTtcbiAgICByY29uV29yZFswXSBePSByY29uVmFsdWU7XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnQXBwbHkgUmNvbicsIGlucHV0OiBzYm94V29yZC5zbGljZSgpLCByY29uOiByY29uVmFsdWUsIG91dHB1dDogcmNvbldvcmQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFN0ZXAgNDogWE9SIHdpdGggcHJldmlvdXMgKGZpcnN0IHdvcmQpXG4gICAgY29uc3QgeG9yUmVzdWx0ID0gW1xuICAgICAgcHJldktleVswXSBeIHJjb25Xb3JkWzBdLFxuICAgICAgcHJldktleVsxXSBeIHJjb25Xb3JkWzFdLFxuICAgICAgcHJldktleVsyXSBeIHJjb25Xb3JkWzJdLFxuICAgICAgcHJldktleVszXSBeIHJjb25Xb3JkWzNdLFxuICAgIF07XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnWE9SIHdpdGggcHJldmlvdXMnLCBpbnB1dHM6IFtwcmV2S2V5LnNsaWNlKDAsNCksIHJjb25Xb3JkLnNsaWNlKCldLCBvdXRwdXQ6IHhvclJlc3VsdC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU2F2ZSBhbmQgdXBkYXRlIG5ld0tleVxuICAgIG5ld0tleVswXSA9IHhvclJlc3VsdFswXTtcbiAgICBuZXdLZXlbMV0gPSB4b3JSZXN1bHRbMV07XG4gICAgbmV3S2V5WzJdID0geG9yUmVzdWx0WzJdO1xuICAgIG5ld0tleVszXSA9IHhvclJlc3VsdFszXTtcbiAgICAvLyBPdGhlciB3b3JkcyAob25seSBzaW1wbGUgeG9yKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5V29yZHM7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG4gICAgICBuZXdLZXlbb2Zmc2V0XSA9IG5ld0tleVtvZmZzZXQgLSA0XSBeIHByZXZLZXlbb2Zmc2V0XTtcbiAgICAgIG5ld0tleVtvZmZzZXQgKyAxXSA9IG5ld0tleVtvZmZzZXQgLSAzXSBeIHByZXZLZXlbb2Zmc2V0ICsgMV07XG4gICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBuZXdLZXlbb2Zmc2V0IC0gMl0gXiBwcmV2S2V5W29mZnNldCArIDJdO1xuICAgICAgbmV3S2V5W29mZnNldCArIDNdID0gbmV3S2V5W29mZnNldCAtIDFdIF4gcHJldktleVtvZmZzZXQgKyAzXTtcbiAgICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgICBzdGVwOiAnWE9SIGNoYWluJywgaW5wdXRzOiBbXG4gICAgICAgICAgbmV3S2V5LnNsaWNlKG9mZnNldCAtIDQsIG9mZnNldCksXG4gICAgICAgICAgcHJldktleS5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpXG4gICAgICAgIF0sIG91dHB1dDogbmV3S2V5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNCksIHdvcmRJbmRleDogaVxuICAgICAgfSk7XG4gICAgfVxuICAgIHN0ZXBzUGVyUm91bmQucHVzaCh7IHJvdW5kLCBzdGVwRGV0YWlscywgcm91bmRLZXk6IG5ld0tleS5zbGljZSgpIH0pO1xuICAgIHByZXZLZXkgPSBuZXdLZXkuc2xpY2UoKTtcbiAgICByb3VuZEtleXMucHVzaChwcmV2S2V5KTtcbiAgfVxuICByZXR1cm4gc3RlcHNQZXJSb3VuZDtcbn1cblxuLy8gUmVhbCBBRVMgZW5jcnlwdGlvbiB1c2luZyBDcnlwdG9KUyBmb3IgdmVyaWZpY2F0aW9uXG5leHBvcnQgY29uc3QgcmVhbEFlc0VuY3J5cHQgPSAoXG4gIHBsYWludGV4dDogc3RyaW5nLFxuICBrZXk6IHN0cmluZyxcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3LFxuICBvdXRwdXRGb3JtYXQ6IE91dHB1dEZvcm1hdCA9IE91dHB1dEZvcm1hdC5CQVNFNjQsXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgsXG4gIGl2U3RyaW5nPzogc3RyaW5nXG4pOiB7IGNpcGhlcnRleHQ6IHN0cmluZywgaXY/OiBzdHJpbmcsIGZvcm1hdHM6IHsgYmFzZTY0OiBzdHJpbmcsIGhleDogc3RyaW5nLCBiaW5hcnk6IHN0cmluZyB9IH0gPT4ge1xuICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBrZXkgaXMgc2hvcnRlciB0aGFuIHJlcXVpcmVkIGJ5IGtleUxlbmd0aFxuICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICBsZXQga2V5SGV4ID0gY2xlYW5LZXkubGVuZ3RoICUgMiA9PT0gMSA/IGNsZWFuS2V5ICsgJzAnIDogY2xlYW5LZXk7XG4gIFxuICAvLyBFbnN1cmUga2V5IGlzIG9mIGNvcnJlY3QgbGVuZ3RoIGZvciB0aGUgc2VsZWN0ZWQga2V5IGxlbmd0aFxuICBjb25zdCByZXF1aXJlZEhleENoYXJzID0ga2V5TGVuZ3RoIC8gNDsgLy8gRWFjaCBoZXggY2hhciBpcyA0IGJpdHNcbiAgaWYgKGtleUhleC5sZW5ndGggPCByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgLy8gUGFkIGtleSBpZiB0b28gc2hvcnRcbiAgICBrZXlIZXggPSBrZXlIZXgucGFkRW5kKHJlcXVpcmVkSGV4Q2hhcnMsICcwJyk7XG4gIH0gZWxzZSBpZiAoa2V5SGV4Lmxlbmd0aCA+IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAvLyBUcnVuY2F0ZSBrZXkgaWYgdG9vIGxvbmdcbiAgICBrZXlIZXggPSBrZXlIZXguc3Vic3RyaW5nKDAsIHJlcXVpcmVkSGV4Q2hhcnMpO1xuICB9XG4gIFxuICBjb25zdCBrZXlXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGtleUhleCk7XG4gIFxuICBsZXQgcGFkZGluZ09wdGlvbjogYW55O1xuICBzd2l0Y2ggKHBhZGRpbmcpIHtcbiAgICBjYXNlIFBhZGRpbmdUeXBlLkFOU0lfWDkyMzpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5BbnNpWDkyMyB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQYWRkaW5nVHlwZS5OT05FOlxuICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7fTsgLy8gZGVmYXVsdCBpcyBQS0NTN1xuICB9XG4gIFxuICBsZXQgbW9kZU9wdGlvbjogYW55O1xuICBsZXQgaXY6IGFueTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoaXZTdHJpbmcpIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAgICB9XG4gICAgICBtb2RlT3B0aW9uID0geyBcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgICAgIGl2OiBpdixcbiAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBpZiAoaXZTdHJpbmcpIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAgICB9XG4gICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNUUixcbiAgICAgICAgaXY6IGl2LFxuICAgICAgICBjb3VudGVyOiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMCwgMCwgMCwgMF0sIDE2KSxcbiAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgY29uc3QgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQocGxhaW50ZXh0LCBrZXlXb3JkQXJyYXksIG1vZGVPcHRpb24pO1xuICBcbiAgLy8gR2V0IGFsbCBvdXRwdXQgZm9ybWF0c1xuICBjb25zdCBiYXNlNjRPdXRwdXQgPSBlbmNyeXB0ZWQudG9TdHJpbmcoKTtcbiAgY29uc3QgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuICAgIGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0T3V0cHV0KVxuICB9KTtcbiAgY29uc3QgaGV4T3V0cHV0ID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgXG4gIC8vIEZvciBiaW5hcnksIHdlIG5lZWQgdG8gY29udmVydCB0aGUgaGV4IHRvIGJpbmFyeVxuICBjb25zdCBoZXhCeXRlcyA9IGhleE91dHB1dC5tYXRjaCgvLnsyfS9nKSEubWFwKGhleCA9PiBwYXJzZUludChoZXgsIDE2KSk7XG4gIGNvbnN0IGJpbmFyeU91dHB1dCA9IGJ5dGVzVG9CaW5hcnkoaGV4Qnl0ZXMsICcnKTtcbiAgXG4gIC8vIFNlbGVjdCB0aGUgcmVxdWVzdGVkIGZvcm1hdCBmb3IgcHJpbWFyeSBvdXRwdXRcbiAgbGV0IHByaW1hcnlPdXRwdXQ6IHN0cmluZztcbiAgc3dpdGNoIChvdXRwdXRGb3JtYXQpIHtcbiAgICBjYXNlIE91dHB1dEZvcm1hdC5IRVg6XG4gICAgICBwcmltYXJ5T3V0cHV0ID0gaGV4T3V0cHV0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPdXRwdXRGb3JtYXQuQklOQVJZOlxuICAgICAgcHJpbWFyeU91dHB1dCA9IGJpbmFyeU91dHB1dDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEJBU0U2NFxuICAgICAgcHJpbWFyeU91dHB1dCA9IGJhc2U2NE91dHB1dDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICByZXR1cm4geyBcbiAgICBjaXBoZXJ0ZXh0OiBwcmltYXJ5T3V0cHV0LFxuICAgIGl2OiBpdiA/IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KGl2KSA6IHVuZGVmaW5lZCxcbiAgICBmb3JtYXRzOiB7XG4gICAgICBiYXNlNjQ6IGJhc2U2NE91dHB1dCxcbiAgICAgIGhleDogaGV4T3V0cHV0LFxuICAgICAgYmluYXJ5OiBiaW5hcnlPdXRwdXRcbiAgICB9XG4gIH07XG59O1xuXG4vLyBSZWFsIEFFUyBkZWNyeXB0aW9uIHVzaW5nIENyeXB0b0pTXG5leHBvcnQgY29uc3QgcmVhbEFlc0RlY3J5cHQgPSAoXG4gIGNpcGhlcnRleHQ6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgaW5wdXRGb3JtYXQ6IE91dHB1dEZvcm1hdCA9IE91dHB1dEZvcm1hdC5CQVNFNjQsXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgsXG4gIGl2U3RyaW5nPzogc3RyaW5nXG4pOiB7IHBsYWludGV4dDogc3RyaW5nLCBlcnJvcj86IHN0cmluZyB9ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBrZXkgaXMgc2hvcnRlciB0aGFuIHJlcXVpcmVkIGJ5IGtleUxlbmd0aFxuICAgIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgbGV0IGtleUhleCA9IGNsZWFuS2V5Lmxlbmd0aCAlIDIgPT09IDEgPyBjbGVhbktleSArICcwJyA6IGNsZWFuS2V5O1xuICAgIFxuICAgIC8vIEVuc3VyZSBrZXkgaXMgb2YgY29ycmVjdCBsZW5ndGggZm9yIHRoZSBzZWxlY3RlZCBrZXkgbGVuZ3RoXG4gICAgY29uc3QgcmVxdWlyZWRIZXhDaGFycyA9IGtleUxlbmd0aCAvIDQ7IC8vIEVhY2ggaGV4IGNoYXIgaXMgNCBiaXRzXG4gICAgaWYgKGtleUhleC5sZW5ndGggPCByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgICAvLyBQYWQga2V5IGlmIHRvbyBzaG9ydFxuICAgICAga2V5SGV4ID0ga2V5SGV4LnBhZEVuZChyZXF1aXJlZEhleENoYXJzLCAnMCcpO1xuICAgIH0gZWxzZSBpZiAoa2V5SGV4Lmxlbmd0aCA+IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAgIC8vIFRydW5jYXRlIGtleSBpZiB0b28gbG9uZ1xuICAgICAga2V5SGV4ID0ga2V5SGV4LnN1YnN0cmluZygwLCByZXF1aXJlZEhleENoYXJzKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qga2V5V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShrZXlIZXgpO1xuICAgIFxuICAgIC8vIFBhcnNlIGNpcGhlcnRleHQgYmFzZWQgb24gaW5wdXQgZm9ybWF0XG4gICAgbGV0IGNpcGhlcnRleHRXb3JkQXJyYXk6IGFueTtcbiAgICBzd2l0Y2ggKGlucHV0Rm9ybWF0KSB7XG4gICAgICBjYXNlIE91dHB1dEZvcm1hdC5IRVg6XG4gICAgICAgIGNpcGhlcnRleHRXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGNpcGhlcnRleHQucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPdXRwdXRGb3JtYXQuQklOQVJZOlxuICAgICAgICAvLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgdG8gaGV4IGZpcnN0XG4gICAgICAgIGNvbnN0IGhleEZyb21CaW5hcnkgPSBjaXBoZXJ0ZXh0LnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goLy57OH0vZyk/Lm1hcChiaW4gPT4gcGFyc2VJbnQoYmluLCAyKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJykgfHwgJyc7XG4gICAgICAgIGNpcGhlcnRleHRXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleEZyb21CaW5hcnkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIEJBU0U2NFxuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGxldCBwYWRkaW5nT3B0aW9uOiBhbnk7XG4gICAgc3dpdGNoIChwYWRkaW5nKSB7XG4gICAgICBjYXNlIFBhZGRpbmdUeXBlLkFOU0lfWDkyMzpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLkFuc2lYOTIzIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWRkaW5nVHlwZS5OT05FOlxuICAgICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHt9OyAvLyBkZWZhdWx0IGlzIFBLQ1M3XG4gICAgfVxuICAgIFxuICAgIGxldCBtb2RlT3B0aW9uOiBhbnk7XG4gICAgbGV0IGl2OiBhbnk7XG4gICAgXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgICBpZiAoIWl2U3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdDQkMgcmVqaW1pIHVjaHVuIElWIGtlcmFrJyB9O1xuICAgICAgICB9XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgbW9kZU9wdGlvbiA9IHsgXG4gICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgICBpZiAoIWl2U3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdDVFIgcmVqaW1pIHVjaHVuIElWIChOb25jZSkga2VyYWsnIH07XG4gICAgICAgIH1cbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ1RSLFxuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICBjb3VudGVyOiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMCwgMCwgMCwgMF0sIDE2KSxcbiAgICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGVjcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoXG4gICAgICB7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXkgfSBhcyBhbnksXG4gICAgICBrZXlXb3JkQXJyYXksXG4gICAgICBtb2RlT3B0aW9uXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBwbGFpbnRleHQgPSBkZWNyeXB0ZWQudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuICAgIFxuICAgIGlmICghcGxhaW50ZXh0KSB7XG4gICAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogJ0Rlc2hpZnJsYXNoIG11dmFmZmFxaXlhdHNpei4gS2FsaXQgeW9raSBzaGlmcmxhbmdhbiBtYXRuIG5vdG9cXCdnXFwncmkuJyB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBwbGFpbnRleHQgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdEZXNoaWZybGFzaGRhIHhhdG9saWsgeXV6IGJlcmRpJyB9O1xuICB9XG59O1xuXG4vLyBUZXN0IHNwZWNpZmljIGNhc2UgZm9yIFwiU2Fsb20sIEFFUyFcIiB3aXRoIGtleSBcImNjIDBlIGMxIDcwIDI0IDI0IDAxIDhkIDRlIGZkIDVlIGYzIDhkIDE1IDJmIDYzXCJcbmV4cG9ydCBjb25zdCB0ZXN0U3BlY2lmaWNDYXNlID0gKCk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHBsYWludGV4dCA9IFwiU2Fsb20sIEFFUyFcIjtcbiAgY29uc3Qga2V5ID0gXCJjYyAwZSBjMSA3MCAyNCAyNCAwMSA4ZCA0ZSBmZCA1ZSBmMyA4ZCAxNSAyZiA2M1wiO1xuICBcbiAgLy8gQ3JlYXRlIGtleSBhbmQgaW5wdXQgYXMgYnl0ZSBhcnJheXNcbiAgY29uc3Qga2V5Qnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBrZXlCeXRlcy5wdXNoKHBhcnNlSW50KGtleS5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgXG4gIC8vIFVzZSBvdXIgaW1wbGVtZW50YXRpb25cbiAgY29uc3QgeyBmaW5hbENpcGhlcnRleHQgfSA9IGdldEFlc1N0ZXBzKHBsYWludGV4dCwga2V5Qnl0ZXMsIEFlc01vZGUuRUNCLCBQYWRkaW5nVHlwZS5QS0NTNyk7XG4gIFxuICAvLyBVc2UgQ3J5cHRvSlMgaW1wbGVtZW50YXRpb25cbiAgY29uc3QgY3J5cHRvUmVzdWx0ID0gcmVhbEFlc0VuY3J5cHQocGxhaW50ZXh0LCBrZXksIEFlc01vZGUuRUNCLCBQYWRkaW5nVHlwZS5QS0NTNywgT3V0cHV0Rm9ybWF0LkhFWCk7XG4gIFxuICByZXR1cm4gYFxuICAgIEJpem5pbmcgaW1wbGVtZW50YXRzaXlhbWl6IChIRVgpOiAke2ZpbmFsQ2lwaGVydGV4dC5oZXh9XG4gICAgQ3J5cHRvSlMgaW1wbGVtZW50YXRzaXlhc2kgKEhFWCk6ICR7Y3J5cHRvUmVzdWx0LmZvcm1hdHMuaGV4fVxuICAgIEt1dGlsYXlvdGdhbiBuYXRpamE6IDMwNDg0QjhGOEM2QkIwOUNBM0Y5NEM2Rjg0RjAzMDVFXG4gIGA7XG59O1xuIl0sIm5hbWVzIjpbIkNyeXB0b0pTIiwiQWVzTW9kZSIsIlBhZGRpbmdUeXBlIiwiT3V0cHV0Rm9ybWF0IiwiS2V5TGVuZ3RoIiwiU0JPWCIsIlJDT04iLCJHQUxPSVNfTVVMXzIiLCJHQUxPSVNfTVVMXzMiLCJ0ZXh0VG9TdGF0ZSIsInRleHQiLCJ3b3JkQXJyYXkiLCJlbmMiLCJVdGY4IiwicGFyc2UiLCJieXRlcyIsInNpZ0J5dGVzIiwiaSIsIndvcmRzIiwibGVuZ3RoIiwid29yZCIsImJ5dGVzSW5UaGlzV29yZCIsIk1hdGgiLCJtaW4iLCJwdXNoIiwiYmxvY2siLCJzbGljZSIsImtleVRvQnl0ZXMiLCJrZXkiLCJjbGVhbktleSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJwYXJzZUludCIsInN1YnN0ciIsImdlbmVyYXRlUmFuZG9tS2V5Iiwia2V5TGVuZ3RoIiwia2V5Qnl0ZXMiLCJmbG9vciIsInJhbmRvbSIsImJ5dGVzVG9IZXgiLCJqb2luQ2hhciIsIm1hcCIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsImJ5dGVzVG9CaW5hcnkiLCJzdWJCeXRlcyIsInN0YXRlIiwic2hpZnRSb3dzIiwicmVzdWx0IiwiaWR4Iiwicm93IiwiY29sIiwicm93VmFsdWVzIiwic2hpZnRlZCIsImNvbmNhdCIsIm1peENvbHVtbnMiLCJzMCIsInMxIiwiczIiLCJzMyIsImFkZFJvdW5kS2V5Iiwicm91bmRLZXkiLCJrZXlFeHBhbnNpb24iLCJrZXlXb3JkcyIsIm51bVJvdW5kcyIsInJvdW5kS2V5cyIsInJvdW5kIiwicHJldktleSIsIm5ld0tleSIsImxhc3RJbmRleCIsImxhc3RXb3JkIiwicm90V29yZCIsInN1YldvcmQiLCJvZmZzZXQiLCJ0ZW1wV29yZCIsInN1YlRlbXBXb3JkIiwiYWVzUm91bmQiLCJpc0xhc3RSb3VuZCIsIm5ld1N0YXRlIiwiYWVzRW5jcnlwdCIsInBsYWludGV4dCIsImN1cnJlbnRTdGF0ZSIsInRleHRUb0Jsb2NrcyIsInBhZGRpbmciLCJwYWRkZWRCeXRlcyIsImFwcGx5UEtDUzdQYWRkaW5nIiwiYXBwbHlBbnNpWDkyM1BhZGRpbmciLCJibG9ja3MiLCJkYXRhIiwicGFkZGVkIiwicGFkZGluZ0xlbmd0aCIsInJlbW92ZUFuc2lYOTIzUGFkZGluZyIsImdlbmVyYXRlSVYiLCJpdiIsImdldEFlc1N0ZXBzRm9yQmxvY2siLCJtb2RlIiwiYmxvY2tJbmRleCIsInByZXZpb3VzQ2lwaGVydGV4dEJsb2NrIiwic3RlcHMiLCJwbGFpbnRleHRCeXRlcyIsImRlc2NyaXB0aW9uIiwiZXhwbGFuYXRpb24iLCJpbml0aWFsU3RhdGUiLCJhY3RpdmVJbmRpY2VzIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInByZXZpb3VzU3RhdGUiLCJmaW5hbFN0YXRlIiwiY291bnRlckJsb2NrIiwiY291bnRlclZhbHVlIiwic3VtIiwiYWZ0ZXJJbml0aWFsUm91bmQiLCJhZnRlclN1YkJ5dGVzIiwiYWZ0ZXJTaGlmdFJvd3MiLCJwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkiLCJhZnRlck1peENvbHVtbnMiLCJnZXRBZXNTdGVwcyIsInByb3ZpZGVkSXYiLCJ1bmRlZmluZWQiLCJhbGxCbG9ja3MiLCJpdkRlc2NyaXB0aW9uIiwiaXZFeHBsYW5hdGlvbiIsImNvdW50ZXIiLCJjb21iaW5lZEZpbmFsU3RhdGVzIiwiYmxvY2tSZXN1bHQiLCJmaW5hbFN0YXRlVG9Vc2UiLCJmaW5hbFdvcmRBcnJheSIsImxpYiIsIldvcmRBcnJheSIsImNyZWF0ZSIsIlVpbnQ4QXJyYXkiLCJmaW5hbENpcGhlcnRleHRCYXNlNjQiLCJCYXNlNjQiLCJzdHJpbmdpZnkiLCJmaW5hbENpcGhlcnRleHRIZXgiLCJIZXgiLCJmaW5hbENpcGhlcnRleHRCaW5hcnkiLCJmaW5hbENpcGhlcnRleHQiLCJiYXNlNjQiLCJoZXgiLCJiaW5hcnkiLCJnZXRLZXlFeHBhbnNpb25TdGVwcyIsImN1cnJlbnRLZXkiLCJzYm94V29yZCIsInJjb25WYWx1ZSIsInRyYW5zZm9ybWVkV29yZCIsImZpcnN0V29yZFByZXYiLCJ4b3JSZXN1bHQiLCJpbmRleCIsImIiLCJoaWdobGlnaHRlZENlbGxzIiwiZ2V0S2V5U2NoZWR1bGVEZXRhaWxlZFN0ZXBzIiwic3RlcHNQZXJSb3VuZCIsInN0ZXBEZXRhaWxzIiwic3RlcCIsImlucHV0Iiwib3V0cHV0IiwicmNvbldvcmQiLCJyY29uIiwiaW5wdXRzIiwid29yZEluZGV4IiwicmVhbEFlc0VuY3J5cHQiLCJvdXRwdXRGb3JtYXQiLCJpdlN0cmluZyIsImtleUhleCIsInJlcXVpcmVkSGV4Q2hhcnMiLCJwYWRFbmQiLCJzdWJzdHJpbmciLCJrZXlXb3JkQXJyYXkiLCJwYWRkaW5nT3B0aW9uIiwicGFkIiwiQW5zaVg5MjMiLCJOb1BhZGRpbmciLCJtb2RlT3B0aW9uIiwiQ0JDIiwiQ1RSIiwiRUNCIiwiZW5jcnlwdGVkIiwiQUVTIiwiZW5jcnlwdCIsImJhc2U2NE91dHB1dCIsImNpcGhlclBhcmFtcyIsIkNpcGhlclBhcmFtcyIsImNpcGhlcnRleHQiLCJoZXhPdXRwdXQiLCJmb3JtYXQiLCJoZXhCeXRlcyIsIm1hdGNoIiwiYmluYXJ5T3V0cHV0IiwicHJpbWFyeU91dHB1dCIsImZvcm1hdHMiLCJyZWFsQWVzRGVjcnlwdCIsImlucHV0Rm9ybWF0IiwiY2lwaGVydGV4dFdvcmRBcnJheSIsImhleEZyb21CaW5hcnkiLCJiaW4iLCJlcnJvciIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJtZXNzYWdlIiwidGVzdFNwZWNpZmljQ2FzZSIsImNyeXB0b1Jlc3VsdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/aes.ts\n"));

/***/ })

});