"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/aes.ts":
/*!**************************!*\
  !*** ./src/utils/aes.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AesMode: () => (/* binding */ AesMode),\n/* harmony export */   GALOIS_MUL_2: () => (/* binding */ GALOIS_MUL_2),\n/* harmony export */   GALOIS_MUL_3: () => (/* binding */ GALOIS_MUL_3),\n/* harmony export */   KeyLength: () => (/* binding */ KeyLength),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   PaddingType: () => (/* binding */ PaddingType),\n/* harmony export */   RCON: () => (/* binding */ RCON),\n/* harmony export */   SBOX: () => (/* binding */ SBOX),\n/* harmony export */   addRoundKey: () => (/* binding */ addRoundKey),\n/* harmony export */   aesEncrypt: () => (/* binding */ aesEncrypt),\n/* harmony export */   aesRound: () => (/* binding */ aesRound),\n/* harmony export */   applyAnsiX923Padding: () => (/* binding */ applyAnsiX923Padding),\n/* harmony export */   applyPKCS7Padding: () => (/* binding */ applyPKCS7Padding),\n/* harmony export */   bytesToBinary: () => (/* binding */ bytesToBinary),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   generateIV: () => (/* binding */ generateIV),\n/* harmony export */   generateRandomKey: () => (/* binding */ generateRandomKey),\n/* harmony export */   getAesSteps: () => (/* binding */ getAesSteps),\n/* harmony export */   getAesStepsForBlock: () => (/* binding */ getAesStepsForBlock),\n/* harmony export */   getKeyExpansionSteps: () => (/* binding */ getKeyExpansionSteps),\n/* harmony export */   getKeyScheduleDetailedSteps: () => (/* binding */ getKeyScheduleDetailedSteps),\n/* harmony export */   keyExpansion: () => (/* binding */ keyExpansion),\n/* harmony export */   keyToBytes: () => (/* binding */ keyToBytes),\n/* harmony export */   mixColumns: () => (/* binding */ mixColumns),\n/* harmony export */   realAesDecrypt: () => (/* binding */ realAesDecrypt),\n/* harmony export */   realAesEncrypt: () => (/* binding */ realAesEncrypt),\n/* harmony export */   removeAnsiX923Padding: () => (/* binding */ removeAnsiX923Padding),\n/* harmony export */   shiftRows: () => (/* binding */ shiftRows),\n/* harmony export */   subBytes: () => (/* binding */ subBytes),\n/* harmony export */   testSpecificCase: () => (/* binding */ testSpecificCase),\n/* harmony export */   textToBlocks: () => (/* binding */ textToBlocks),\n/* harmony export */   textToState: () => (/* binding */ textToState)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(pages-dir-browser)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// AES mode enum\nvar AesMode = /*#__PURE__*/ function(AesMode) {\n    AesMode[\"ECB\"] = \"ECB\";\n    AesMode[\"CBC\"] = \"CBC\";\n    AesMode[\"CTR\"] = \"CTR\";\n    return AesMode;\n}({});\n// Padding enum\nvar PaddingType = /*#__PURE__*/ function(PaddingType) {\n    PaddingType[\"PKCS7\"] = \"PKCS7\";\n    PaddingType[\"ANSI_X923\"] = \"ANSI X.923\";\n    PaddingType[\"NONE\"] = \"None\";\n    return PaddingType;\n}({});\n// Output format enum\nvar OutputFormat = /*#__PURE__*/ function(OutputFormat) {\n    OutputFormat[\"BASE64\"] = \"Base64\";\n    OutputFormat[\"HEX\"] = \"Hex\";\n    OutputFormat[\"BINARY\"] = \"Binary\";\n    return OutputFormat;\n}({});\n// Key length enum\nvar KeyLength = /*#__PURE__*/ function(KeyLength) {\n    KeyLength[KeyLength[\"AES_128\"] = 128] = \"AES_128\";\n    KeyLength[KeyLength[\"AES_192\"] = 192] = \"AES_192\";\n    KeyLength[KeyLength[\"AES_256\"] = 256] = \"AES_256\";\n    return KeyLength;\n}({});\nconst getNumRounds = (keyLength)=>keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\nconst getKeyByteLength = (keyLength)=>keyLength / 8;\n// AES S-Box (Standard Rijndael S-box)\nconst SBOX = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\n// AES Rcon (Round Constants)\nconst RCON = [\n    0x00,\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a\n];\n// Used in MixColumns\nconst GALOIS_MUL_2 = [\n    0x00,\n    0x02,\n    0x04,\n    0x06,\n    0x08,\n    0x0a,\n    0x0c,\n    0x0e,\n    0x10,\n    0x12,\n    0x14,\n    0x16,\n    0x18,\n    0x1a,\n    0x1c,\n    0x1e,\n    0x20,\n    0x22,\n    0x24,\n    0x26,\n    0x28,\n    0x2a,\n    0x2c,\n    0x2e,\n    0x30,\n    0x32,\n    0x34,\n    0x36,\n    0x38,\n    0x3a,\n    0x3c,\n    0x3e,\n    0x40,\n    0x42,\n    0x44,\n    0x46,\n    0x48,\n    0x4a,\n    0x4c,\n    0x4e,\n    0x50,\n    0x52,\n    0x54,\n    0x56,\n    0x58,\n    0x5a,\n    0x5c,\n    0x5e,\n    0x60,\n    0x62,\n    0x64,\n    0x66,\n    0x68,\n    0x6a,\n    0x6c,\n    0x6e,\n    0x70,\n    0x72,\n    0x74,\n    0x76,\n    0x78,\n    0x7a,\n    0x7c,\n    0x7e,\n    0x80,\n    0x82,\n    0x84,\n    0x86,\n    0x88,\n    0x8a,\n    0x8c,\n    0x8e,\n    0x90,\n    0x92,\n    0x94,\n    0x96,\n    0x98,\n    0x9a,\n    0x9c,\n    0x9e,\n    0xa0,\n    0xa2,\n    0xa4,\n    0xa6,\n    0xa8,\n    0xaa,\n    0xac,\n    0xae,\n    0xb0,\n    0xb2,\n    0xb4,\n    0xb6,\n    0xb8,\n    0xba,\n    0xbc,\n    0xbe,\n    0xc0,\n    0xc2,\n    0xc4,\n    0xc6,\n    0xc8,\n    0xca,\n    0xcc,\n    0xce,\n    0xd0,\n    0xd2,\n    0xd4,\n    0xd6,\n    0xd8,\n    0xda,\n    0xdc,\n    0xde,\n    0xe0,\n    0xe2,\n    0xe4,\n    0xe6,\n    0xe8,\n    0xea,\n    0xec,\n    0xee,\n    0xf0,\n    0xf2,\n    0xf4,\n    0xf6,\n    0xf8,\n    0xfa,\n    0xfc,\n    0xfe,\n    0x1b,\n    0x19,\n    0x1f,\n    0x1d,\n    0x13,\n    0x11,\n    0x17,\n    0x15,\n    0x0b,\n    0x09,\n    0x0f,\n    0x0d,\n    0x03,\n    0x01,\n    0x07,\n    0x05,\n    0x3b,\n    0x39,\n    0x3f,\n    0x3d,\n    0x33,\n    0x31,\n    0x37,\n    0x35,\n    0x2b,\n    0x29,\n    0x2f,\n    0x2d,\n    0x23,\n    0x21,\n    0x27,\n    0x25,\n    0x5b,\n    0x59,\n    0x5f,\n    0x5d,\n    0x53,\n    0x51,\n    0x57,\n    0x55,\n    0x4b,\n    0x49,\n    0x4f,\n    0x4d,\n    0x43,\n    0x41,\n    0x47,\n    0x45,\n    0x7b,\n    0x79,\n    0x7f,\n    0x7d,\n    0x73,\n    0x71,\n    0x77,\n    0x75,\n    0x6b,\n    0x69,\n    0x6f,\n    0x6d,\n    0x63,\n    0x61,\n    0x67,\n    0x65,\n    0x9b,\n    0x99,\n    0x9f,\n    0x9d,\n    0x93,\n    0x91,\n    0x97,\n    0x95,\n    0x8b,\n    0x89,\n    0x8f,\n    0x8d,\n    0x83,\n    0x81,\n    0x87,\n    0x85,\n    0xbb,\n    0xb9,\n    0xbf,\n    0xbd,\n    0xb3,\n    0xb1,\n    0xb7,\n    0xb5,\n    0xab,\n    0xa9,\n    0xaf,\n    0xad,\n    0xa3,\n    0xa1,\n    0xa7,\n    0xa5,\n    0xdb,\n    0xd9,\n    0xdf,\n    0xdd,\n    0xd3,\n    0xd1,\n    0xd7,\n    0xd5,\n    0xcb,\n    0xc9,\n    0xcf,\n    0xcd,\n    0xc3,\n    0xc1,\n    0xc7,\n    0xc5,\n    0xfb,\n    0xf9,\n    0xff,\n    0xfd,\n    0xf3,\n    0xf1,\n    0xf7,\n    0xf5,\n    0xeb,\n    0xe9,\n    0xef,\n    0xed,\n    0xe3,\n    0xe1,\n    0xe7,\n    0xe5\n];\nconst GALOIS_MUL_3 = [\n    0x00,\n    0x03,\n    0x06,\n    0x05,\n    0x0c,\n    0x0f,\n    0x0a,\n    0x09,\n    0x18,\n    0x1b,\n    0x1e,\n    0x1d,\n    0x14,\n    0x17,\n    0x12,\n    0x11,\n    0x30,\n    0x33,\n    0x36,\n    0x35,\n    0x3c,\n    0x3f,\n    0x3a,\n    0x39,\n    0x28,\n    0x2b,\n    0x2e,\n    0x2d,\n    0x24,\n    0x27,\n    0x22,\n    0x21,\n    0x60,\n    0x63,\n    0x66,\n    0x65,\n    0x6c,\n    0x6f,\n    0x6a,\n    0x69,\n    0x78,\n    0x7b,\n    0x7e,\n    0x7d,\n    0x74,\n    0x77,\n    0x72,\n    0x71,\n    0x50,\n    0x53,\n    0x56,\n    0x55,\n    0x5c,\n    0x5f,\n    0x5a,\n    0x59,\n    0x48,\n    0x4b,\n    0x4e,\n    0x4d,\n    0x44,\n    0x47,\n    0x42,\n    0x41,\n    0xc0,\n    0xc3,\n    0xc6,\n    0xc5,\n    0xcc,\n    0xcf,\n    0xca,\n    0xc9,\n    0xd8,\n    0xdb,\n    0xde,\n    0xdd,\n    0xd4,\n    0xd7,\n    0xd2,\n    0xd1,\n    0xf0,\n    0xf3,\n    0xf6,\n    0xf5,\n    0xfc,\n    0xff,\n    0xfa,\n    0xf9,\n    0xe8,\n    0xeb,\n    0xee,\n    0xed,\n    0xe4,\n    0xe7,\n    0xe2,\n    0xe1,\n    0xa0,\n    0xa3,\n    0xa6,\n    0xa5,\n    0xac,\n    0xaf,\n    0xaa,\n    0xa9,\n    0xb8,\n    0xbb,\n    0xbe,\n    0xbd,\n    0xb4,\n    0xb7,\n    0xb2,\n    0xb1,\n    0x90,\n    0x93,\n    0x96,\n    0x95,\n    0x9c,\n    0x9f,\n    0x9a,\n    0x99,\n    0x88,\n    0x8b,\n    0x8e,\n    0x8d,\n    0x84,\n    0x87,\n    0x82,\n    0x81,\n    0x9b,\n    0x98,\n    0x9d,\n    0x9e,\n    0x97,\n    0x94,\n    0x91,\n    0x92,\n    0x83,\n    0x80,\n    0x85,\n    0x86,\n    0x8f,\n    0x8c,\n    0x89,\n    0x8a,\n    0xab,\n    0xa8,\n    0xad,\n    0xae,\n    0xa7,\n    0xa4,\n    0xa1,\n    0xa2,\n    0xb3,\n    0xb0,\n    0xb5,\n    0xb6,\n    0xbf,\n    0xbc,\n    0xb9,\n    0xba,\n    0xfb,\n    0xf8,\n    0xfd,\n    0xfe,\n    0xf7,\n    0xf4,\n    0xf1,\n    0xf2,\n    0xe3,\n    0xe0,\n    0xe5,\n    0xe6,\n    0xef,\n    0xec,\n    0xe9,\n    0xea,\n    0xcb,\n    0xc8,\n    0xcd,\n    0xce,\n    0xc7,\n    0xc4,\n    0xc1,\n    0xc2,\n    0xd3,\n    0xd0,\n    0xd5,\n    0xd6,\n    0xdf,\n    0xdc,\n    0xd9,\n    0xda,\n    0x5b,\n    0x58,\n    0x5d,\n    0x5e,\n    0x57,\n    0x54,\n    0x51,\n    0x52,\n    0x43,\n    0x40,\n    0x45,\n    0x46,\n    0x4f,\n    0x4c,\n    0x49,\n    0x4a,\n    0x6b,\n    0x68,\n    0x6d,\n    0x6e,\n    0x67,\n    0x64,\n    0x61,\n    0x62,\n    0x73,\n    0x70,\n    0x75,\n    0x76,\n    0x7f,\n    0x7c,\n    0x79,\n    0x7a,\n    0x3b,\n    0x38,\n    0x3d,\n    0x3e,\n    0x37,\n    0x34,\n    0x31,\n    0x32,\n    0x23,\n    0x20,\n    0x25,\n    0x26,\n    0x2f,\n    0x2c,\n    0x29,\n    0x2a,\n    0x0b,\n    0x08,\n    0x0d,\n    0x0e,\n    0x07,\n    0x04,\n    0x01,\n    0x02,\n    0x13,\n    0x10,\n    0x15,\n    0x16,\n    0x1f,\n    0x1c,\n    0x19,\n    0x1a\n];\n// Convert text to a state matrix - returns array of bytes\nconst textToState = (text)=>{\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Pad to 16 bytes if needed\n    while(bytes.length < 16){\n        bytes.push(0);\n    }\n    const block = bytes.slice(0, 16);\n    // AES state is column-major: state[r + 4*c] = input[4*c + r]\n    return block;\n};\n// Convert a key string to bytes using selected key length\nconst keyToBytes = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const requiredHexLength = requiredBytes * 2;\n    // Remove spaces and convert to lowercase\n    const cleanKey = key.replace(/\\s/g, '').toLowerCase();\n    // If it's a hex string, convert it\n    if (/^[0-9a-f]+$/.test(cleanKey)) {\n        const bytes = [];\n        for(let i = 0; i < Math.min(cleanKey.length, requiredHexLength); i += 2){\n            bytes.push(parseInt(cleanKey.substr(i, 2), 16));\n        }\n        while(bytes.length < requiredBytes){\n            bytes.push(0);\n        }\n        return bytes.slice(0, requiredBytes);\n    }\n    // Otherwise, treat as UTF-8 text and normalize to selected key size\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(key);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    while(bytes.length < requiredBytes){\n        bytes.push(0);\n    }\n    return bytes.slice(0, requiredBytes);\n};\n// Generate a random key as byte array based on key length\nconst generateRandomKey = function() {\n    let keyLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;\n    const keyBytes = getKeyByteLength(keyLength);\n    const bytes = [];\n    for(let i = 0; i < keyBytes; i++){\n        bytes.push(Math.floor(Math.random() * 256));\n    }\n    return bytes;\n};\n// Format bytes as hex\nconst bytesToHex = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(16).padStart(2, '0')).join(joinChar);\n};\n// Format bytes as binary\nconst bytesToBinary = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(2).padStart(8, '0')).join(joinChar);\n};\n// SubBytes operation - substitute each byte with its S-box value\nconst subBytes = (state)=>{\n    return state.map((byte)=>SBOX[byte]);\n};\n// ShiftRows operation - rotate rows of the state matrix\nconst shiftRows = (state)=>{\n    const result = [\n        ...state\n    ];\n    // Column-major state index helper: idx(row, col) = row + 4*col\n    const idx = (row, col)=>row + 4 * col;\n    for(let row = 1; row < 4; row++){\n        const rowValues = [\n            state[idx(row, 0)],\n            state[idx(row, 1)],\n            state[idx(row, 2)],\n            state[idx(row, 3)]\n        ];\n        const shifted = rowValues.slice(row).concat(rowValues.slice(0, row));\n        for(let col = 0; col < 4; col++){\n            result[idx(row, col)] = shifted[col];\n        }\n    }\n    return result;\n};\n// MixColumns operation - mix data within columns\nconst mixColumns = (state)=>{\n    const result = [\n        ...state\n    ];\n    const idx = (row, col)=>row + 4 * col;\n    for(let i = 0; i < 4; i++){\n        const s0 = state[idx(0, i)];\n        const s1 = state[idx(1, i)];\n        const s2 = state[idx(2, i)];\n        const s3 = state[idx(3, i)];\n        result[idx(0, i)] = GALOIS_MUL_2[s0] ^ GALOIS_MUL_3[s1] ^ s2 ^ s3;\n        result[idx(1, i)] = s0 ^ GALOIS_MUL_2[s1] ^ GALOIS_MUL_3[s2] ^ s3;\n        result[idx(2, i)] = s0 ^ s1 ^ GALOIS_MUL_2[s2] ^ GALOIS_MUL_3[s3];\n        result[idx(3, i)] = GALOIS_MUL_3[s0] ^ s1 ^ s2 ^ GALOIS_MUL_2[s3];\n    }\n    return result;\n};\n// AddRoundKey operation - XOR state with round key\nconst addRoundKey = (state, roundKey)=>{\n    return state.map((byte, i)=>byte ^ roundKey[i]);\n};\n// Kalitni kengaytirish — raund kalitlarini generatsiya qilish\nconst keyExpansion = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const normalizedKey = key.slice(0, requiredBytes);\n    while(normalizedKey.length < requiredBytes){\n        normalizedKey.push(0);\n    }\n    const keyWords = normalizedKey.length / 4;\n    const numRounds = getNumRounds(keyLength);\n    const roundKeys = [\n        normalizedKey.slice()\n    ]; // 1-raund kaliti boshlang‘ich kalitning o‘zi hisoblanadi\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const newKey = prevKey.slice();\n        // Oxirgi word ni aylantirib, S-box ni qo‘llang\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const subWord = rotWord.map((byte)=>SBOX[byte]);\n        // Birinchi baytni Rcon bilan XOR qilinadi\n        subWord[0] ^= RCON[round];\n        // Yangi kalitning birinchi word i generatsiya qilinadi\n        newKey[0] = prevKey[0] ^ subWord[0];\n        newKey[1] = prevKey[1] ^ subWord[1];\n        newKey[2] = prevKey[2] ^ subWord[2];\n        newKey[3] = prevKey[3] ^ subWord[3];\n        // Qolgan word lar hosil qilinadi\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            // AES-256 holatida har to‘rtinchi word ga qo‘shimcha S-box (SubWord) qo‘llanadi\n            if (keyLength === 256 && i === 4) {\n                const tempWord = [\n                    newKey[offset - 4],\n                    newKey[offset - 3],\n                    newKey[offset - 2],\n                    newKey[offset - 1]\n                ];\n                const subTempWord = tempWord.map((byte)=>SBOX[byte]);\n                newKey[offset] = prevKey[offset] ^ subTempWord[0];\n                newKey[offset + 1] = prevKey[offset + 1] ^ subTempWord[1];\n                newKey[offset + 2] = prevKey[offset + 2] ^ subTempWord[2];\n                newKey[offset + 3] = prevKey[offset + 3] ^ subTempWord[3];\n            } else {\n                newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n                newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n                newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n                newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            }\n        }\n        roundKeys.push(newKey);\n    }\n    return roundKeys;\n};\n// Perform one round of AES\nconst aesRound = (state, roundKey, isLastRound)=>{\n    let newState = subBytes(state);\n    newState = shiftRows(newState);\n    if (!isLastRound) {\n        newState = mixColumns(newState);\n    }\n    newState = addRoundKey(newState, roundKey);\n    return newState;\n};\n// Complete AES encryption\nconst aesEncrypt = function(plaintext, key) {\n    let keyLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 128;\n    // Initial state\n    const state = textToState(plaintext);\n    // Key expansion\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    // Initial round - just AddRoundKey\n    let currentState = addRoundKey(state, roundKeys[0]);\n    // Main rounds\n    for(let round = 1; round <= numRounds; round++){\n        currentState = aesRound(currentState, roundKeys[round], round === numRounds);\n    }\n    return currentState;\n};\n// Convert full text to array of 16-byte blocks\nconst textToBlocks = function(text) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"PKCS7\";\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    // Convert CryptoJS WordArray to byte array, respecting sigBytes\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Apply padding\n    let paddedBytes;\n    if (padding === \"PKCS7\") {\n        paddedBytes = applyPKCS7Padding(bytes);\n    } else if (padding === \"ANSI X.923\") {\n        paddedBytes = applyAnsiX923Padding(bytes);\n    } else {\n        paddedBytes = [\n            ...bytes\n        ];\n        // For NONE padding, must be multiple of 16\n        while(paddedBytes.length % 16 !== 0){\n            paddedBytes.push(0);\n        }\n    }\n    // Split into 16-byte blocks\n    const blocks = [];\n    for(let i = 0; i < paddedBytes.length; i += 16){\n        blocks.push(paddedBytes.slice(i, i + 16));\n    }\n    return blocks;\n};\n// Apply PKCS7 padding\nconst applyPKCS7Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    for(let i = 0; i < paddingLength; i++){\n        padded.push(paddingLength);\n    }\n    return padded;\n};\n// Apply ANSI X.923 padding\nconst applyAnsiX923Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    // Add padding bytes (0x00) except the last byte\n    for(let i = 0; i < paddingLength - 1; i++){\n        padded.push(0x00);\n    }\n    // Add the padding length as the last byte\n    padded.push(paddingLength);\n    return padded;\n};\n// Remove ANSI X.923 padding\nconst removeAnsiX923Padding = (data)=>{\n    const paddingLength = data[data.length - 1];\n    return data.slice(0, data.length - paddingLength);\n};\n// Get IV for CBC mode\nconst generateIV = ()=>{\n    const iv = [];\n    for(let i = 0; i < 16; i++){\n        iv.push(Math.floor(Math.random() * 256));\n    }\n    return iv;\n};\n// Get AES steps for a single block (16 bytes)\nconst getAesStepsForBlock = function(block, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", blockIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, previousCiphertextBlock = arguments.length > 4 ? arguments[4] : void 0, iv = arguments.length > 5 ? arguments[5] : void 0, keyLength = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 128;\n    const steps = [];\n    // Ensure block is exactly 16 bytes\n    const plaintextBytes = [\n        ...block\n    ];\n    while(plaintextBytes.length < 16){\n        plaintextBytes.push(0);\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Asl ochiq matn\"),\n        state: plaintextBytes,\n        explanation: \"Blok \".concat(blockIndex + 1, \" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.\")\n    });\n    const initialState = plaintextBytes;\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (blockIndex === 0 && iv) {\n                currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — IV bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: iv,\n                    explanation: \"CBC: birinchi blok IV bilan XOR qilinadi.\"\n                });\n            } else if (previousCiphertextBlock) {\n                currentState = initialState.map((byte, i)=>byte ^ previousCiphertextBlock[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — Oldingi ciphertext bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: previousCiphertextBlock,\n                    explanation: \"CBC: keyingi bloklar oldingi ciphertext bloki bilan XOR qilinadi.\"\n                });\n            } else {\n                currentState = initialState;\n            }\n            break;\n        case \"CTR\":\n            if (!iv) {\n                return {\n                    steps: [],\n                    finalState: plaintextBytes\n                };\n            }\n            const counterBlock = [\n                ...iv\n            ];\n            let counterValue = blockIndex;\n            for(let i = 15; i >= 0 && counterValue > 0; i--){\n                const sum = counterBlock[i] + (counterValue & 0xff);\n                counterBlock[i] = sum & 0xff;\n                counterValue = (counterValue >> 8) + (sum >> 8);\n            }\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter\"),\n                state: counterBlock,\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter.\")\n            });\n            currentState = counterBlock;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Boshlang'ich\"),\n                state: currentState,\n                explanation: \"ECB: blok \".concat(blockIndex + 1, \" mustaqil shifrlanadi.\")\n            });\n            break;\n    }\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — 0-bosqich — AddRoundKey\"),\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    for(let round = 1; round <= numRounds; round++){\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState\n        });\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes\n        });\n        let previousStateForAddRoundKey;\n        if (round < numRounds) {\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows\n            });\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter XOR\"),\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter XOR.\"),\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Yakuniy\"),\n        state: finalState,\n        explanation: \"Blok \".concat(blockIndex + 1, \" uchun yakuniy shifrlangan natija.\")\n    });\n    return {\n        steps,\n        finalState\n    };\n};\nconst getAesSteps = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", providedIv = arguments.length > 4 ? arguments[4] : void 0, keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128;\n    const steps = [];\n    let iv = providedIv ? [\n        ...providedIv\n    ] : undefined;\n    // Convert full text to blocks\n    const blocks = textToBlocks(plaintext, padding);\n    const allBlocks = [];\n    // Convert plaintext to bytes (for first block visualization)\n    let plaintextBytes = blocks[0] || textToState(plaintext);\n    steps.push({\n        description: 'Asl ochiq matn',\n        state: plaintextBytes,\n        explanation: 'Ochiq matn \"'.concat(plaintext, '\" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.')\n    });\n    // Apply padding if needed\n    if (padding === \"ANSI X.923\") {\n        plaintextBytes = applyAnsiX923Padding(plaintextBytes);\n        steps.push({\n            description: 'ANSI X.923 to‘ldirishdan keyin',\n            state: plaintextBytes,\n            explanation: 'ANSI X.923 to‘ldirish nollar bilan to‘ldiradi va oxirgi byte ga to‘ldirish uzunligini qo‘yadi.'\n        });\n    }\n    // Generate IV for CBC/CTR mode only if not provided\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n        if (blocks.length === 1) {\n            // Only show IV step if single block (for backward compatibility)\n            const ivDescription = mode === \"CBC\" ? 'Boshlang\\'ich vektor (Initialization Vector, IV)' : 'Counter (Nonce)';\n            const ivExplanation = \"\".concat(mode === \"CBC\" ? 'CBC' : 'CTR', \" rejimi uchun 16-bayt tasodifiy \").concat(mode === \"CBC\" ? 'IV' : 'Nonce', \" yaratiladi.\");\n            steps.push({\n                description: ivDescription,\n                state: iv,\n                explanation: ivExplanation\n            });\n        }\n    }\n    // Start encryption process (for first block visualization)\n    const initialState = plaintextBytes;\n    // Key expansion\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    // Initial setup based on mode\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (!iv) iv = generateIV(); // Failsafe\n            // XOR plaintext with IV\n            currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n            steps.push({\n                description: 'Boshlang\\'ich holatni IV bilan XOR qilish',\n                state: currentState,\n                activeIndices: Array.from(Array(16).keys()),\n                previousState: initialState,\n                roundKey: iv,\n                explanation: \"CBC rejimida shifrlash boshlanishidan oldin ochiq matn IV bilan XOR qilinadi. Bu jarayon CBC rejimining asosiy xususiyatidir - har bir ochiq matn bloki avvalgi shifrlangan matn bloki (yoki birinchi blok uchun IV) bilan XOR qilinadi, keyin shifrlanadi. Bu bir xil ochiq matn bloklarini turli shifrlangan matn bloklarga aylantiradi va shifrlangan matndagi naqshlarni yashirishga yordam beradi.\"\n            });\n            break;\n        case \"CTR\":\n            // In CTR mode, we encrypt a counter value instead of the plaintext\n            const counter = iv || generateIV();\n            if (!iv) iv = counter;\n            steps.push({\n                description: 'Counter qiymati',\n                state: counter,\n                explanation: 'CTR rejimida ochiq matn o‘rniga counter qiymati shifrlanadi.'\n            });\n            currentState = counter;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: 'Boshlang‘ich holat (ochiq matn)',\n                state: currentState,\n                explanation: 'ECB rejimida ochiq matn bloklari mustaqil ravishda shifrlanadi.'\n            });\n            break;\n    }\n    // Initial round - just AddRoundKey (Round 0)\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: '0-bosqich — Boshlang\\'ich AddRoundKey',\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    // Main rounds\n    for(let round = 1; round <= numRounds; round++){\n        // SubBytes\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState // Add previous state for S-box lookup\n        });\n        // ShiftRows\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes // Add previous state for comparison\n        });\n        let previousStateForAddRoundKey;\n        if (round < numRounds) {\n            // MixColumns (not in final round)\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"\".concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows // Add previous state for MixColumns comparison\n            });\n            // AddRoundKey\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            // Final round has no MixColumns\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    // Final output based on mode\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            // Output is the current state (already completed encryption)\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            // XOR the encrypted counter with plaintext\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: 'Ochiq matn shifrlangan hisoblagich bilan XOR amaliyotida birlashtiriladi.',\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: 'CTR rejimida, yakuniy bosqichda shifrlangan hisoblagich ochiq matn bilan XOR amaliyoti orqali birlashtiriladi va natijada shifrlangan matn hosil bo‘ladi.',\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: 'Yakuniy shifrlangan matn',\n        state: finalState,\n        explanation: \"\".concat(mode, \" rejimida AES-\").concat(keyLength, \" yordamida olingan yakuniy shifrlangan natija.\")\n    });\n    // Process all blocks for multi-block support\n    let previousCiphertextBlock;\n    const combinedFinalStates = [];\n    // Generate IV if needed\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n    }\n    for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){\n        const blockResult = getAesStepsForBlock(blocks[blockIndex], key, mode, blockIndex, previousCiphertextBlock, iv, keyLength);\n        allBlocks.push({\n            blockIndex,\n            steps: blockResult.steps,\n            finalState: blockResult.finalState\n        });\n        combinedFinalStates.push(...blockResult.finalState);\n        // For CBC mode, use current ciphertext as previous for next block\n        if (mode === \"CBC\") {\n            previousCiphertextBlock = blockResult.finalState;\n        }\n    }\n    // Use combined final states if we have multiple blocks, otherwise use single block result\n    const finalStateToUse = blocks.length > 1 ? combinedFinalStates : finalState;\n    // Convert the final state to the requested output format\n    const finalWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create(new Uint8Array(finalStateToUse));\n    const finalCiphertextBase64 = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.stringify(finalWordArray);\n    const finalCiphertextHex = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(finalWordArray);\n    const finalCiphertextBinary = bytesToBinary(finalStateToUse, '');\n    return {\n        steps,\n        finalCiphertext: {\n            base64: finalCiphertextBase64,\n            hex: finalCiphertextHex,\n            binary: finalCiphertextBinary\n        },\n        iv,\n        allBlocks: allBlocks.length > 1 ? allBlocks : undefined\n    };\n};\n// Get key expansion steps with detailed explanations\nconst getKeyExpansionSteps = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    const steps = [];\n    steps.push({\n        description: 'Boshlang‘ich kalit',\n        key: roundKeys[0],\n        explanation: \"Bu foydalanuvchi tomonidan berilgan asl \".concat(keyLength, \"-bitli kalitdir.\")\n    });\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const currentKey = roundKeys[round];\n        // Calculate the transformations for a more detailed explanation\n        const lastWord = [\n            prevKey[12],\n            prevKey[13],\n            prevKey[14],\n            prevKey[15]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        const rconValue = RCON[round];\n        const transformedWord = [\n            ...sboxWord\n        ];\n        transformedWord[0] ^= rconValue;\n        // Calculate the first word of the previous key and its XOR with the transformed word\n        const firstWordPrev = [\n            prevKey[0],\n            prevKey[1],\n            prevKey[2],\n            prevKey[3]\n        ];\n        const xorResult = firstWordPrev.map((byte, index)=>byte ^ transformedWord[index]);\n        // Show the key with highlighted cells for the new word\n        steps.push({\n            description: \"Raund kaliti \".concat(round),\n            key: currentKey,\n            explanation: \"\\n        \".concat(round, \"-raund uchun kalitni kengaytirish jarayoni:\\n        1. Oldingi kalitning oxirgi word qismini oling: [\").concat(lastWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        2. Wordni aylantiring: [\").concat(rotWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        3. Aylantirilgan word ga S-box ni qo‘llang: [\").concat(sboxWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        4. Birinchi baytga RCON (Round Constant \").concat(rconValue.toString(16), \") ni qo‘llang:\\n          Natija: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        5. Oldingi kalitning birinchi word i: [\").concat(firstWordPrev.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] ni o‘zgartirilgan word bilan XOR qiling: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"], natijada: [\").concat(xorResult.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] hosil bo‘ladi. So‘ngra qolgan word lar shu tarzda hosil qilinadi.\\n      \"),\n            highlightedCells: [\n                0,\n                1,\n                2,\n                3\n            ] // Highlight the first word that's directly transformed\n        });\n    }\n    return steps;\n};\n// Return intermediate steps for each word expansion for visualization\nfunction getKeyScheduleDetailedSteps(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = getNumRounds(keyLength);\n    // Flatten byte array -> words\n    let prevKey = key.slice();\n    let roundKeys = [\n        prevKey.slice()\n    ];\n    // For result visualization: each step for each round\n    let stepsPerRound = [];\n    for(let round = 1; round <= numRounds; round++){\n        let stepDetails = [];\n        let newKey = prevKey.slice();\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        // Step 1: RotWord\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        stepDetails.push({\n            step: 'RotWord',\n            input: lastWord.slice(),\n            output: rotWord.slice()\n        });\n        // Step 2: SubBytes (S-box)\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        stepDetails.push({\n            step: 'SubBytes',\n            input: rotWord.slice(),\n            output: sboxWord.slice()\n        });\n        // Step 3: Rcon to first byte\n        const rconValue = RCON[round];\n        const rconWord = sboxWord.slice();\n        rconWord[0] ^= rconValue;\n        stepDetails.push({\n            step: 'Apply Rcon',\n            input: sboxWord.slice(),\n            rcon: rconValue,\n            output: rconWord.slice()\n        });\n        // Step 4: XOR with previous (first word)\n        const xorResult = [\n            prevKey[0] ^ rconWord[0],\n            prevKey[1] ^ rconWord[1],\n            prevKey[2] ^ rconWord[2],\n            prevKey[3] ^ rconWord[3]\n        ];\n        stepDetails.push({\n            step: 'XOR with previous',\n            inputs: [\n                prevKey.slice(0, 4),\n                rconWord.slice()\n            ],\n            output: xorResult.slice()\n        });\n        // Save and update newKey\n        newKey[0] = xorResult[0];\n        newKey[1] = xorResult[1];\n        newKey[2] = xorResult[2];\n        newKey[3] = xorResult[3];\n        // Other words (only simple xor)\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n            newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n            newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n            newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            stepDetails.push({\n                step: 'XOR chain',\n                inputs: [\n                    newKey.slice(offset - 4, offset),\n                    prevKey.slice(offset, offset + 4)\n                ],\n                output: newKey.slice(offset, offset + 4),\n                wordIndex: i\n            });\n        }\n        stepsPerRound.push({\n            round,\n            stepDetails,\n            roundKey: newKey.slice()\n        });\n        prevKey = newKey.slice();\n        roundKeys.push(prevKey);\n    }\n    return stepsPerRound;\n}\n// Real AES encryption using CryptoJS for verification\nconst realAesEncrypt = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", outputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    // Handle case where key is shorter than required by keyLength\n    const cleanKey = key.replace(/\\s/g, '');\n    let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n    // Ensure key is of correct length for the selected key length\n    const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n    if (keyHex.length < requiredHexChars) {\n        // Pad key if too short\n        keyHex = keyHex.padEnd(requiredHexChars, '0');\n    } else if (keyHex.length > requiredHexChars) {\n        // Truncate key if too long\n        keyHex = keyHex.substring(0, requiredHexChars);\n    }\n    const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n    let paddingOption;\n    switch(padding){\n        case \"ANSI X.923\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n            };\n            break;\n        case \"None\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n            };\n            break;\n        default:\n            paddingOption = {}; // default is PKCS7\n    }\n    let modeOption;\n    let iv;\n    switch(mode){\n        case \"CBC\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                iv: iv,\n                ...paddingOption\n            };\n            break;\n        case \"CTR\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                iv: iv,\n                counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                    0,\n                    0,\n                    0,\n                    0\n                ], 16),\n                ...paddingOption\n            };\n            break;\n        default:\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                ...paddingOption\n            };\n            break;\n    }\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(plaintext, keyWordArray, modeOption);\n    // Get all output formats\n    const base64Output = encrypted.toString();\n    const cipherParams = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.CipherParams.create({\n        ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(base64Output)\n    });\n    const hexOutput = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().format.Hex.stringify(cipherParams);\n    // For binary, we need to convert the hex to binary\n    const hexBytes = hexOutput.match(/.{2}/g).map((hex)=>parseInt(hex, 16));\n    const binaryOutput = bytesToBinary(hexBytes, '');\n    // Select the requested format for primary output\n    let primaryOutput;\n    switch(outputFormat){\n        case \"Hex\":\n            primaryOutput = hexOutput;\n            break;\n        case \"Binary\":\n            primaryOutput = binaryOutput;\n            break;\n        default:\n            primaryOutput = base64Output;\n            break;\n    }\n    return {\n        ciphertext: primaryOutput,\n        iv: iv ? crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(iv) : undefined,\n        formats: {\n            base64: base64Output,\n            hex: hexOutput,\n            binary: binaryOutput\n        }\n    };\n};\n// Real AES decryption using CryptoJS\nconst realAesDecrypt = function(ciphertext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", inputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    try {\n        // Handle case where key is shorter than required by keyLength\n        const cleanKey = key.replace(/\\s/g, '');\n        let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n        // Ensure key is of correct length for the selected key length\n        const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n        if (keyHex.length < requiredHexChars) {\n            // Pad key if too short\n            keyHex = keyHex.padEnd(requiredHexChars, '0');\n        } else if (keyHex.length > requiredHexChars) {\n            // Truncate key if too long\n            keyHex = keyHex.substring(0, requiredHexChars);\n        }\n        const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n        // Parse ciphertext based on input format\n        let ciphertextWordArray;\n        switch(inputFormat){\n            case \"Hex\":\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ciphertext.replace(/\\s/g, ''));\n                break;\n            case \"Binary\":\n                var _ciphertext_replace_match;\n                // Convert binary string to hex first\n                const hexFromBinary = ((_ciphertext_replace_match = ciphertext.replace(/\\s/g, '').match(/.{8}/g)) === null || _ciphertext_replace_match === void 0 ? void 0 : _ciphertext_replace_match.map((bin)=>parseInt(bin, 2).toString(16).padStart(2, '0')).join('')) || '';\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(hexFromBinary);\n                break;\n            default:\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(ciphertext);\n                break;\n        }\n        let paddingOption;\n        switch(padding){\n            case \"ANSI X.923\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n                };\n                break;\n            case \"None\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n                };\n                break;\n            default:\n                paddingOption = {}; // default is PKCS7\n        }\n        let modeOption;\n        let iv;\n        switch(mode){\n            case \"CBC\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CBC rejimi uchun IV kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                    iv: iv,\n                    ...paddingOption\n                };\n                break;\n            case \"CTR\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CTR rejimi uchun IV (Nonce) kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                    iv: iv,\n                    counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                        0,\n                        0,\n                        0,\n                        0\n                    ], 16),\n                    ...paddingOption\n                };\n                break;\n            default:\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                    ...paddingOption\n                };\n                break;\n        }\n        const decrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt({\n            ciphertext: ciphertextWordArray\n        }, keyWordArray, modeOption);\n        const plaintext = decrypted.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n        if (!plaintext) {\n            return {\n                plaintext: '',\n                error: 'Deshifrlash muvaffaqiyatsiz. Kalit yoki shifrlangan matn noto\\'g\\'ri.'\n            };\n        }\n        return {\n            plaintext\n        };\n    } catch (error) {\n        return {\n            plaintext: '',\n            error: error.message || 'Deshifrlashda xatolik yuz berdi'\n        };\n    }\n};\n// Test specific case for \"Salom, AES!\" with key \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\"\nconst testSpecificCase = ()=>{\n    const plaintext = \"Salom, AES!\";\n    const key = \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\";\n    // Create key and input as byte arrays\n    const keyBytes = [];\n    for(let i = 0; i < key.length; i += 2){\n        keyBytes.push(parseInt(key.substr(i, 2), 16));\n    }\n    // Use our implementation\n    const { finalCiphertext } = getAesSteps(plaintext, keyBytes, \"ECB\", \"PKCS7\");\n    // Use CryptoJS implementation\n    const cryptoResult = realAesEncrypt(plaintext, key, \"ECB\", \"PKCS7\", \"Hex\");\n    return \"\\n    Bizning implementatsiyamiz (HEX): \".concat(finalCiphertext.hex, \"\\n    CryptoJS implementatsiyasi (HEX): \").concat(cryptoResult.formats.hex, \"\\n    Kutilayotgan natija: 30484B8F8C6BB09CA3F94C6F84F0305E\\n  \");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9hZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUVqQyxnQkFBZ0I7QUFDVCxxQ0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELGVBQWU7QUFDUix5Q0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELHFCQUFxQjtBQUNkLDBDQUFLQzs7OztXQUFBQTtNQUlYO0FBRUQsa0JBQWtCO0FBQ1gsdUNBQUtDOzs7O1dBQUFBO01BSVg7QUFFRCxNQUFNQyxlQUFlLENBQUNDLFlBQ3BCQSxvQkFBa0MsS0FDbENBLG9CQUFrQyxLQUFLO0FBR3pDLE1BQU1DLG1CQUFtQixDQUFDRCxZQUFpQ0EsWUFBWTtBQUV2RSxzQ0FBc0M7QUFDL0IsTUFBTUUsT0FBTztJQUNsQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRixDQUFDO0FBRUYsNkJBQTZCO0FBQ3RCLE1BQU1DLE9BQU87SUFDbEI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLHFCQUFxQjtBQUNkLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVLLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxj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RTtBQUVGLGtHQUFrRztBQUMzRixNQUFNQyxtQkFBbUI7SUFDOUIsTUFBTXpILFlBQVk7SUFDbEIsTUFBTXpELE1BQU07SUFFWixzQ0FBc0M7SUFDdEMsTUFBTVUsV0FBVyxFQUFFO0lBQ25CLElBQUssSUFBSXJCLElBQUksR0FBR0EsSUFBSVcsSUFBSVQsTUFBTSxFQUFFRixLQUFLLEVBQUc7UUFDdENxQixTQUFTZCxJQUFJLENBQUNXLFNBQVNQLElBQUlRLE1BQU0sQ0FBQ25CLEdBQUcsSUFBSTtJQUMzQztJQUVBLHlCQUF5QjtJQUN6QixNQUFNLEVBQUU4SCxlQUFlLEVBQUUsR0FBR3JCLFlBQVlyQyxXQUFXL0M7SUFFbkQsOEJBQThCO0lBQzlCLE1BQU15SyxlQUFleEMsZUFBZWxGLFdBQVd6RDtJQUUvQyxPQUFPLDJDQUUrQm1MLE9BREFoRSxnQkFBZ0JFLEdBQUcsRUFBQyw0Q0FDSyxPQUF6QjhELGFBQWFYLE9BQU8sQ0FBQ25ELEdBQUcsRUFBQztBQUdqRSxFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHZpY3R1c1xcRGVza3RvcFxcYWVzXFxGaW5hbCBBRVNcXGFlc1xcc3JjXFx1dGlsc1xcYWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDcnlwdG9KUyBmcm9tICdjcnlwdG8tanMnO1xuXG4vLyBBRVMgbW9kZSBlbnVtXG5leHBvcnQgZW51bSBBZXNNb2RlIHtcbiAgRUNCID0gJ0VDQicsXG4gIENCQyA9ICdDQkMnLFxuICBDVFIgPSAnQ1RSJ1xufVxuXG4vLyBQYWRkaW5nIGVudW1cbmV4cG9ydCBlbnVtIFBhZGRpbmdUeXBlIHtcbiAgUEtDUzcgPSAnUEtDUzcnLFxuICBBTlNJX1g5MjMgPSAnQU5TSSBYLjkyMycsXG4gIE5PTkUgPSAnTm9uZSdcbn1cblxuLy8gT3V0cHV0IGZvcm1hdCBlbnVtXG5leHBvcnQgZW51bSBPdXRwdXRGb3JtYXQge1xuICBCQVNFNjQgPSAnQmFzZTY0JyxcbiAgSEVYID0gJ0hleCcsXG4gIEJJTkFSWSA9ICdCaW5hcnknXG59XG5cbi8vIEtleSBsZW5ndGggZW51bVxuZXhwb3J0IGVudW0gS2V5TGVuZ3RoIHtcbiAgQUVTXzEyOCA9IDEyOCxcbiAgQUVTXzE5MiA9IDE5MixcbiAgQUVTXzI1NiA9IDI1NlxufVxuXG5jb25zdCBnZXROdW1Sb3VuZHMgPSAoa2V5TGVuZ3RoOiBLZXlMZW5ndGgpOiBudW1iZXIgPT4gKFxuICBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTI4ID8gMTAgOlxuICBrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMTkyID8gMTIgOiAxNFxuKTtcblxuY29uc3QgZ2V0S2V5Qnl0ZUxlbmd0aCA9IChrZXlMZW5ndGg6IEtleUxlbmd0aCk6IG51bWJlciA9PiBrZXlMZW5ndGggLyA4O1xuXG4vLyBBRVMgUy1Cb3ggKFN0YW5kYXJkIFJpam5kYWVsIFMtYm94KVxuZXhwb3J0IGNvbnN0IFNCT1ggPSBbXG4gIDB4NjMsIDB4N2MsIDB4NzcsIDB4N2IsIDB4ZjIsIDB4NmIsIDB4NmYsIDB4YzUsIDB4MzAsIDB4MDEsIDB4NjcsIDB4MmIsIDB4ZmUsIDB4ZDcsIDB4YWIsIDB4NzYsXG4gIDB4Y2EsIDB4ODIsIDB4YzksIDB4N2QsIDB4ZmEsIDB4NTksIDB4NDcsIDB4ZjAsIDB4YWQsIDB4ZDQsIDB4YTIsIDB4YWYsIDB4OWMsIDB4YTQsIDB4NzIsIDB4YzAsXG4gIDB4YjcsIDB4ZmQsIDB4OTMsIDB4MjYsIDB4MzYsIDB4M2YsIDB4ZjcsIDB4Y2MsIDB4MzQsIDB4YTUsIDB4ZTUsIDB4ZjEsIDB4NzEsIDB4ZDgsIDB4MzEsIDB4MTUsXG4gIDB4MDQsIDB4YzcsIDB4MjMsIDB4YzMsIDB4MTgsIDB4OTYsIDB4MDUsIDB4OWEsIDB4MDcsIDB4MTIsIDB4ODAsIDB4ZTIsIDB4ZWIsIDB4MjcsIDB4YjIsIDB4NzUsXG4gIDB4MDksIDB4ODMsIDB4MmMsIDB4MWEsIDB4MWIsIDB4NmUsIDB4NWEsIDB4YTAsIDB4NTIsIDB4M2IsIDB4ZDYsIDB4YjMsIDB4MjksIDB4ZTMsIDB4MmYsIDB4ODQsXG4gIDB4NTMsIDB4ZDEsIDB4MDAsIDB4ZWQsIDB4MjAsIDB4ZmMsIDB4YjEsIDB4NWIsIDB4NmEsIDB4Y2IsIDB4YmUsIDB4MzksIDB4NGEsIDB4NGMsIDB4NTgsIDB4Y2YsXG4gIDB4ZDAsIDB4ZWYsIDB4YWEsIDB4ZmIsIDB4NDMsIDB4NGQsIDB4MzMsIDB4ODUsIDB4NDUsIDB4ZjksIDB4MDIsIDB4N2YsIDB4NTAsIDB4M2MsIDB4OWYsIDB4YTgsXG4gIDB4NTEsIDB4YTMsIDB4NDAsIDB4OGYsIDB4OTIsIDB4OWQsIDB4MzgsIDB4ZjUsIDB4YmMsIDB4YjYsIDB4ZGEsIDB4MjEsIDB4MTAsIDB4ZmYsIDB4ZjMsIDB4ZDIsXG4gIDB4Y2QsIDB4MGMsIDB4MTMsIDB4ZWMsIDB4NWYsIDB4OTcsIDB4NDQsIDB4MTcsIDB4YzQsIDB4YTcsIDB4N2UsIDB4M2QsIDB4NjQsIDB4NWQsIDB4MTksIDB4NzMsXG4gIDB4NjAsIDB4ODEsIDB4NGYsIDB4ZGMsIDB4MjIsIDB4MmEsIDB4OTAsIDB4ODgsIDB4NDYsIDB4ZWUsIDB4YjgsIDB4MTQsIDB4ZGUsIDB4NWUsIDB4MGIsIDB4ZGIsXG4gIDB4ZTAsIDB4MzIsIDB4M2EsIDB4MGEsIDB4NDksIDB4MDYsIDB4MjQsIDB4NWMsIDB4YzIsIDB4ZDMsIDB4YWMsIDB4NjIsIDB4OTEsIDB4OTUsIDB4ZTQsIDB4NzksXG4gIDB4ZTcsIDB4YzgsIDB4MzcsIDB4NmQsIDB4OGQsIDB4ZDUsIDB4NGUsIDB4YTksIDB4NmMsIDB4NTYsIDB4ZjQsIDB4ZWEsIDB4NjUsIDB4N2EsIDB4YWUsIDB4MDgsXG4gIDB4YmEsIDB4NzgsIDB4MjUsIDB4MmUsIDB4MWMsIDB4YTYsIDB4YjQsIDB4YzYsIDB4ZTgsIDB4ZGQsIDB4NzQsIDB4MWYsIDB4NGIsIDB4YmQsIDB4OGIsIDB4OGEsXG4gIDB4NzAsIDB4M2UsIDB4YjUsIDB4NjYsIDB4NDgsIDB4MDMsIDB4ZjYsIDB4MGUsIDB4NjEsIDB4MzUsIDB4NTcsIDB4YjksIDB4ODYsIDB4YzEsIDB4MWQsIDB4OWUsXG4gIDB4ZTEsIDB4ZjgsIDB4OTgsIDB4MTEsIDB4NjksIDB4ZDksIDB4OGUsIDB4OTQsIDB4OWIsIDB4MWUsIDB4ODcsIDB4ZTksIDB4Y2UsIDB4NTUsIDB4MjgsIDB4ZGYsXG4gIDB4OGMsIDB4YTEsIDB4ODksIDB4MGQsIDB4YmYsIDB4ZTYsIDB4NDIsIDB4NjgsIDB4NDEsIDB4OTksIDB4MmQsIDB4MGYsIDB4YjAsIDB4NTQsIDB4YmIsIDB4MTYsXG5dO1xuXG4vLyBBRVMgUmNvbiAoUm91bmQgQ29uc3RhbnRzKVxuZXhwb3J0IGNvbnN0IFJDT04gPSBbXG4gIDB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsXG5dO1xuXG4vLyBVc2VkIGluIE1peENvbHVtbnNcbmV4cG9ydCBjb25zdCBHQUxPSVNfTVVMXzIgPSBbXG4gIDB4MDAsIDB4MDIsIDB4MDQsIDB4MDYsIDB4MDgsIDB4MGEsIDB4MGMsIDB4MGUsIDB4MTAsIDB4MTIsIDB4MTQsIDB4MTYsIDB4MTgsIDB4MWEsIDB4MWMsIDB4MWUsXG4gIDB4MjAsIDB4MjIsIDB4MjQsIDB4MjYsIDB4MjgsIDB4MmEsIDB4MmMsIDB4MmUsIDB4MzAsIDB4MzIsIDB4MzQsIDB4MzYsIDB4MzgsIDB4M2EsIDB4M2MsIDB4M2UsXG4gIDB4NDAsIDB4NDIsIDB4NDQsIDB4NDYsIDB4NDgsIDB4NGEsIDB4NGMsIDB4NGUsIDB4NTAsIDB4NTIsIDB4NTQsIDB4NTYsIDB4NTgsIDB4NWEsIDB4NWMsIDB4NWUsXG4gIDB4NjAsIDB4NjIsIDB4NjQsIDB4NjYsIDB4NjgsIDB4NmEsIDB4NmMsIDB4NmUsIDB4NzAsIDB4NzIsIDB4NzQsIDB4NzYsIDB4NzgsIDB4N2EsIDB4N2MsIDB4N2UsXG4gIDB4ODAsIDB4ODIsIDB4ODQsIDB4ODYsIDB4ODgsIDB4OGEsIDB4OGMsIDB4OGUsIDB4OTAsIDB4OTIsIDB4OTQsIDB4OTYsIDB4OTgsIDB4OWEsIDB4OWMsIDB4OWUsXG4gIDB4YTAsIDB4YTIsIDB4YTQsIDB4YTYsIDB4YTgsIDB4YWEsIDB4YWMsIDB4YWUsIDB4YjAsIDB4YjIsIDB4YjQsIDB4YjYsIDB4YjgsIDB4YmEsIDB4YmMsIDB4YmUsXG4gIDB4YzAsIDB4YzIsIDB4YzQsIDB4YzYsIDB4YzgsIDB4Y2EsIDB4Y2MsIDB4Y2UsIDB4ZDAsIDB4ZDIsIDB4ZDQsIDB4ZDYsIDB4ZDgsIDB4ZGEsIDB4ZGMsIDB4ZGUsXG4gIDB4ZTAsIDB4ZTIsIDB4ZTQsIDB4ZTYsIDB4ZTgsIDB4ZWEsIDB4ZWMsIDB4ZWUsIDB4ZjAsIDB4ZjIsIDB4ZjQsIDB4ZjYsIDB4ZjgsIDB4ZmEsIDB4ZmMsIDB4ZmUsXG4gIDB4MWIsIDB4MTksIDB4MWYsIDB4MWQsIDB4MTMsIDB4MTEsIDB4MTcsIDB4MTUsIDB4MGIsIDB4MDksIDB4MGYsIDB4MGQsIDB4MDMsIDB4MDEsIDB4MDcsIDB4MDUsXG4gIDB4M2IsIDB4MzksIDB4M2YsIDB4M2QsIDB4MzMsIDB4MzEsIDB4MzcsIDB4MzUsIDB4MmIsIDB4MjksIDB4MmYsIDB4MmQsIDB4MjMsIDB4MjEsIDB4MjcsIDB4MjUsXG4gIDB4NWIsIDB4NTksIDB4NWYsIDB4NWQsIDB4NTMsIDB4NTEsIDB4NTcsIDB4NTUsIDB4NGIsIDB4NDksIDB4NGYsIDB4NGQsIDB4NDMsIDB4NDEsIDB4NDcsIDB4NDUsXG4gIDB4N2IsIDB4NzksIDB4N2YsIDB4N2QsIDB4NzMsIDB4NzEsIDB4NzcsIDB4NzUsIDB4NmIsIDB4NjksIDB4NmYsIDB4NmQsIDB4NjMsIDB4NjEsIDB4NjcsIDB4NjUsXG4gIDB4OWIsIDB4OTksIDB4OWYsIDB4OWQsIDB4OTMsIDB4OTEsIDB4OTcsIDB4OTUsIDB4OGIsIDB4ODksIDB4OGYsIDB4OGQsIDB4ODMsIDB4ODEsIDB4ODcsIDB4ODUsXG4gIDB4YmIsIDB4YjksIDB4YmYsIDB4YmQsIDB4YjMsIDB4YjEsIDB4YjcsIDB4YjUsIDB4YWIsIDB4YTksIDB4YWYsIDB4YWQsIDB4YTMsIDB4YTEsIDB4YTcsIDB4YTUsXG4gIDB4ZGIsIDB4ZDksIDB4ZGYsIDB4ZGQsIDB4ZDMsIDB4ZDEsIDB4ZDcsIDB4ZDUsIDB4Y2IsIDB4YzksIDB4Y2YsIDB4Y2QsIDB4YzMsIDB4YzEsIDB4YzcsIDB4YzUsXG4gIDB4ZmIsIDB4ZjksIDB4ZmYsIDB4ZmQsIDB4ZjMsIDB4ZjEsIDB4ZjcsIDB4ZjUsIDB4ZWIsIDB4ZTksIDB4ZWYsIDB4ZWQsIDB4ZTMsIDB4ZTEsIDB4ZTcsIDB4ZTUsXG5dO1xuXG5leHBvcnQgY29uc3QgR0FMT0lTX01VTF8zID0gW1xuICAweDAwLCAweDAzLCAweDA2LCAweDA1LCAweDBjLCAweDBmLCAweDBhLCAweDA5LCAweDE4LCAweDFiLCAweDFlLCAweDFkLCAweDE0LCAweDE3LCAweDEyLCAweDExLFxuICAweDMwLCAweDMzLCAweDM2LCAweDM1LCAweDNjLCAweDNmLCAweDNhLCAweDM5LCAweDI4LCAweDJiLCAweDJlLCAweDJkLCAweDI0LCAweDI3LCAweDIyLCAweDIxLFxuICAweDYwLCAweDYzLCAweDY2LCAweDY1LCAweDZjLCAweDZmLCAweDZhLCAweDY5LCAweDc4LCAweDdiLCAweDdlLCAweDdkLCAweDc0LCAweDc3LCAweDcyLCAweDcxLFxuICAweDUwLCAweDUzLCAweDU2LCAweDU1LCAweDVjLCAweDVmLCAweDVhLCAweDU5LCAweDQ4LCAweDRiLCAweDRlLCAweDRkLCAweDQ0LCAweDQ3LCAweDQyLCAweDQxLFxuICAweGMwLCAweGMzLCAweGM2LCAweGM1LCAweGNjLCAweGNmLCAweGNhLCAweGM5LCAweGQ4LCAweGRiLCAweGRlLCAweGRkLCAweGQ0LCAweGQ3LCAweGQyLCAweGQxLFxuICAweGYwLCAweGYzLCAweGY2LCAweGY1LCAweGZjLCAweGZmLCAweGZhLCAweGY5LCAweGU4LCAweGViLCAweGVlLCAweGVkLCAweGU0LCAweGU3LCAweGUyLCAweGUxLFxuICAweGEwLCAweGEzLCAweGE2LCAweGE1LCAweGFjLCAweGFmLCAweGFhLCAweGE5LCAweGI4LCAweGJiLCAweGJlLCAweGJkLCAweGI0LCAweGI3LCAweGIyLCAweGIxLFxuICAweDkwLCAweDkzLCAweDk2LCAweDk1LCAweDljLCAweDlmLCAweDlhLCAweDk5LCAweDg4LCAweDhiLCAweDhlLCAweDhkLCAweDg0LCAweDg3LCAweDgyLCAweDgxLFxuICAweDliLCAweDk4LCAweDlkLCAweDllLCAweDk3LCAweDk0LCAweDkxLCAweDkyLCAweDgzLCAweDgwLCAweDg1LCAweDg2LCAweDhmLCAweDhjLCAweDg5LCAweDhhLFxuICAweGFiLCAweGE4LCAweGFkLCAweGFlLCAweGE3LCAweGE0LCAweGExLCAweGEyLCAweGIzLCAweGIwLCAweGI1LCAweGI2LCAweGJmLCAweGJjLCAweGI5LCAweGJhLFxuICAweGZiLCAweGY4LCAweGZkLCAweGZlLCAweGY3LCAweGY0LCAweGYxLCAweGYyLCAweGUzLCAweGUwLCAweGU1LCAweGU2LCAweGVmLCAweGVjLCAweGU5LCAweGVhLFxuICAweGNiLCAweGM4LCAweGNkLCAweGNlLCAweGM3LCAweGM0LCAweGMxLCAweGMyLCAweGQzLCAweGQwLCAweGQ1LCAweGQ2LCAweGRmLCAweGRjLCAweGQ5LCAweGRhLFxuICAweDViLCAweDU4LCAweDVkLCAweDVlLCAweDU3LCAweDU0LCAweDUxLCAweDUyLCAweDQzLCAweDQwLCAweDQ1LCAweDQ2LCAweDRmLCAweDRjLCAweDQ5LCAweDRhLFxuICAweDZiLCAweDY4LCAweDZkLCAweDZlLCAweDY3LCAweDY0LCAweDYxLCAweDYyLCAweDczLCAweDcwLCAweDc1LCAweDc2LCAweDdmLCAweDdjLCAweDc5LCAweDdhLFxuICAweDNiLCAweDM4LCAweDNkLCAweDNlLCAweDM3LCAweDM0LCAweDMxLCAweDMyLCAweDIzLCAweDIwLCAweDI1LCAweDI2LCAweDJmLCAweDJjLCAweDI5LCAweDJhLFxuICAweDBiLCAweDA4LCAweDBkLCAweDBlLCAweDA3LCAweDA0LCAweDAxLCAweDAyLCAweDEzLCAweDEwLCAweDE1LCAweDE2LCAweDFmLCAweDFjLCAweDE5LCAweDFhLFxuXTtcblxuLy8gQ29udmVydCB0ZXh0IHRvIGEgc3RhdGUgbWF0cml4IC0gcmV0dXJucyBhcnJheSBvZiBieXRlc1xuZXhwb3J0IGNvbnN0IHRleHRUb1N0YXRlID0gKHRleHQ6IHN0cmluZyk6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodGV4dCk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICBcbiAgLy8gUGFkIHRvIDE2IGJ5dGVzIGlmIG5lZWRlZFxuICB3aGlsZSAoYnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG4gIFxuICBjb25zdCBibG9jayA9IGJ5dGVzLnNsaWNlKDAsIDE2KTtcbiAgLy8gQUVTIHN0YXRlIGlzIGNvbHVtbi1tYWpvcjogc3RhdGVbciArIDQqY10gPSBpbnB1dFs0KmMgKyByXVxuICByZXR1cm4gYmxvY2s7XG59O1xuXG4vLyBDb252ZXJ0IGEga2V5IHN0cmluZyB0byBieXRlcyB1c2luZyBzZWxlY3RlZCBrZXkgbGVuZ3RoXG5leHBvcnQgY29uc3Qga2V5VG9CeXRlcyA9IChcbiAga2V5OiBzdHJpbmcsXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjhcbik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVxdWlyZWRCeXRlcyA9IGdldEtleUJ5dGVMZW5ndGgoa2V5TGVuZ3RoKTtcbiAgY29uc3QgcmVxdWlyZWRIZXhMZW5ndGggPSByZXF1aXJlZEJ5dGVzICogMjtcblxuICAvLyBSZW1vdmUgc3BhY2VzIGFuZCBjb252ZXJ0IHRvIGxvd2VyY2FzZVxuICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBJZiBpdCdzIGEgaGV4IHN0cmluZywgY29udmVydCBpdFxuICBpZiAoL15bMC05YS1mXSskLy50ZXN0KGNsZWFuS2V5KSkge1xuICAgIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oY2xlYW5LZXkubGVuZ3RoLCByZXF1aXJlZEhleExlbmd0aCk7IGkgKz0gMikge1xuICAgICAgYnl0ZXMucHVzaChwYXJzZUludChjbGVhbktleS5zdWJzdHIoaSwgMiksIDE2KSk7XG4gICAgfVxuICAgIHdoaWxlIChieXRlcy5sZW5ndGggPCByZXF1aXJlZEJ5dGVzKSB7XG4gICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgcmVxdWlyZWRCeXRlcyk7XG4gIH1cbiAgXG4gIC8vIE90aGVyd2lzZSwgdHJlYXQgYXMgVVRGLTggdGV4dCBhbmQgbm9ybWFsaXplIHRvIHNlbGVjdGVkIGtleSBzaXplXG4gIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKGtleSk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICB3aGlsZSAoYnl0ZXMubGVuZ3RoIDwgcmVxdWlyZWRCeXRlcykge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIHJlcXVpcmVkQnl0ZXMpO1xufTtcblxuLy8gR2VuZXJhdGUgYSByYW5kb20ga2V5IGFzIGJ5dGUgYXJyYXkgYmFzZWQgb24ga2V5IGxlbmd0aFxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUmFuZG9tS2V5ID0gKGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGtleUJ5dGVzID0gZ2V0S2V5Qnl0ZUxlbmd0aChrZXlMZW5ndGgpO1xuICBjb25zdCBieXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUJ5dGVzOyBpKyspIHtcbiAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn07XG5cbi8vIEZvcm1hdCBieXRlcyBhcyBoZXhcbmV4cG9ydCBjb25zdCBieXRlc1RvSGV4ID0gKGJ5dGVzOiBudW1iZXJbXSwgam9pbkNoYXI6IHN0cmluZyA9ICcgJyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBieXRlcy5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKGpvaW5DaGFyKTtcbn07XG5cbi8vIEZvcm1hdCBieXRlcyBhcyBiaW5hcnlcbmV4cG9ydCBjb25zdCBieXRlc1RvQmluYXJ5ID0gKGJ5dGVzOiBudW1iZXJbXSwgam9pbkNoYXI6IHN0cmluZyA9ICcgJyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBieXRlcy5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDgsICcwJykpLmpvaW4oam9pbkNoYXIpO1xufTtcblxuLy8gU3ViQnl0ZXMgb3BlcmF0aW9uIC0gc3Vic3RpdHV0ZSBlYWNoIGJ5dGUgd2l0aCBpdHMgUy1ib3ggdmFsdWVcbmV4cG9ydCBjb25zdCBzdWJCeXRlcyA9IChzdGF0ZTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIHJldHVybiBzdGF0ZS5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbn07XG5cbi8vIFNoaWZ0Um93cyBvcGVyYXRpb24gLSByb3RhdGUgcm93cyBvZiB0aGUgc3RhdGUgbWF0cml4XG5leHBvcnQgY29uc3Qgc2hpZnRSb3dzID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gWy4uLnN0YXRlXTtcbiAgXG4gIC8vIENvbHVtbi1tYWpvciBzdGF0ZSBpbmRleCBoZWxwZXI6IGlkeChyb3csIGNvbCkgPSByb3cgKyA0KmNvbFxuICBjb25zdCBpZHggPSAocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKSA9PiByb3cgKyA0ICogY29sO1xuXG4gIGZvciAobGV0IHJvdyA9IDE7IHJvdyA8IDQ7IHJvdysrKSB7XG4gICAgY29uc3Qgcm93VmFsdWVzID0gW3N0YXRlW2lkeChyb3csIDApXSwgc3RhdGVbaWR4KHJvdywgMSldLCBzdGF0ZVtpZHgocm93LCAyKV0sIHN0YXRlW2lkeChyb3csIDMpXV07XG4gICAgY29uc3Qgc2hpZnRlZCA9IHJvd1ZhbHVlcy5zbGljZShyb3cpLmNvbmNhdChyb3dWYWx1ZXMuc2xpY2UoMCwgcm93KSk7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgNDsgY29sKyspIHtcbiAgICAgIHJlc3VsdFtpZHgocm93LCBjb2wpXSA9IHNoaWZ0ZWRbY29sXTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBNaXhDb2x1bW5zIG9wZXJhdGlvbiAtIG1peCBkYXRhIHdpdGhpbiBjb2x1bW5zXG5leHBvcnQgY29uc3QgbWl4Q29sdW1ucyA9IChzdGF0ZTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFsuLi5zdGF0ZV07XG4gIGNvbnN0IGlkeCA9IChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpID0+IHJvdyArIDQgKiBjb2w7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgczAgPSBzdGF0ZVtpZHgoMCwgaSldO1xuICAgIGNvbnN0IHMxID0gc3RhdGVbaWR4KDEsIGkpXTtcbiAgICBjb25zdCBzMiA9IHN0YXRlW2lkeCgyLCBpKV07XG4gICAgY29uc3QgczMgPSBzdGF0ZVtpZHgoMywgaSldO1xuICAgIFxuICAgIHJlc3VsdFtpZHgoMCwgaSldID0gR0FMT0lTX01VTF8yW3MwXSBeIEdBTE9JU19NVUxfM1tzMV0gXiBzMiBeIHMzO1xuICAgIHJlc3VsdFtpZHgoMSwgaSldID0gczAgXiBHQUxPSVNfTVVMXzJbczFdIF4gR0FMT0lTX01VTF8zW3MyXSBeIHMzO1xuICAgIHJlc3VsdFtpZHgoMiwgaSldID0gczAgXiBzMSBeIEdBTE9JU19NVUxfMltzMl0gXiBHQUxPSVNfTVVMXzNbczNdO1xuICAgIHJlc3VsdFtpZHgoMywgaSldID0gR0FMT0lTX01VTF8zW3MwXSBeIHMxIF4gczIgXiBHQUxPSVNfTVVMXzJbczNdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBBZGRSb3VuZEtleSBvcGVyYXRpb24gLSBYT1Igc3RhdGUgd2l0aCByb3VuZCBrZXlcbmV4cG9ydCBjb25zdCBhZGRSb3VuZEtleSA9IChzdGF0ZTogbnVtYmVyW10sIHJvdW5kS2V5OiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgcmV0dXJuIHN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIHJvdW5kS2V5W2ldKTtcbn07XG5cbi8vIEthbGl0bmkga2VuZ2F5dGlyaXNoIOKAlCByYXVuZCBrYWxpdGxhcmluaSBnZW5lcmF0c2l5YSBxaWxpc2hcbmV4cG9ydCBjb25zdCBrZXlFeHBhbnNpb24gPSAoa2V5OiBudW1iZXJbXSwga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCk6IG51bWJlcltdW10gPT4ge1xuICBjb25zdCByZXF1aXJlZEJ5dGVzID0gZ2V0S2V5Qnl0ZUxlbmd0aChrZXlMZW5ndGgpO1xuICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnNsaWNlKDAsIHJlcXVpcmVkQnl0ZXMpO1xuICB3aGlsZSAobm9ybWFsaXplZEtleS5sZW5ndGggPCByZXF1aXJlZEJ5dGVzKSB7XG4gICAgbm9ybWFsaXplZEtleS5wdXNoKDApO1xuICB9XG5cbiAgY29uc3Qga2V5V29yZHMgPSBub3JtYWxpemVkS2V5Lmxlbmd0aCAvIDQ7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGdldE51bVJvdW5kcyhrZXlMZW5ndGgpO1xuICBcbiAgY29uc3Qgcm91bmRLZXlzOiBudW1iZXJbXVtdID0gW25vcm1hbGl6ZWRLZXkuc2xpY2UoKV07IC8vIDEtcmF1bmQga2FsaXRpIGJvc2hsYW5n4oCYaWNoIGthbGl0bmluZyBv4oCYemkgaGlzb2JsYW5hZGlcbiAgXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gbnVtUm91bmRzOyByb3VuZCsrKSB7XG4gICAgY29uc3QgcHJldktleSA9IHJvdW5kS2V5c1tyb3VuZCAtIDFdO1xuICAgIGNvbnN0IG5ld0tleSA9IHByZXZLZXkuc2xpY2UoKTtcbiAgICBcbiAgICAvLyBPeGlyZ2kgd29yZCBuaSBheWxhbnRpcmliLCBTLWJveCBuaSBxb+KAmGxsYW5nXG4gICAgY29uc3QgbGFzdEluZGV4ID0gcHJldktleS5sZW5ndGggLSA0O1xuICAgIGNvbnN0IGxhc3RXb3JkID0gW3ByZXZLZXlbbGFzdEluZGV4XSwgcHJldktleVtsYXN0SW5kZXggKyAxXSwgcHJldktleVtsYXN0SW5kZXggKyAyXSwgcHJldktleVtsYXN0SW5kZXggKyAzXV07XG4gICAgY29uc3Qgcm90V29yZCA9IFtsYXN0V29yZFsxXSwgbGFzdFdvcmRbMl0sIGxhc3RXb3JkWzNdLCBsYXN0V29yZFswXV07XG4gICAgY29uc3Qgc3ViV29yZCA9IHJvdFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgXG4gICAgLy8gQmlyaW5jaGkgYmF5dG5pIFJjb24gYmlsYW4gWE9SIHFpbGluYWRpXG4gICAgc3ViV29yZFswXSBePSBSQ09OW3JvdW5kXTtcbiAgICBcbiAgICAvLyBZYW5naSBrYWxpdG5pbmcgYmlyaW5jaGkgd29yZCBpIGdlbmVyYXRzaXlhIHFpbGluYWRpXG4gICAgbmV3S2V5WzBdID0gcHJldktleVswXSBeIHN1YldvcmRbMF07XG4gICAgbmV3S2V5WzFdID0gcHJldktleVsxXSBeIHN1YldvcmRbMV07XG4gICAgbmV3S2V5WzJdID0gcHJldktleVsyXSBeIHN1YldvcmRbMl07XG4gICAgbmV3S2V5WzNdID0gcHJldktleVszXSBeIHN1YldvcmRbM107XG4gICAgXG4gICAgLy8gUW9sZ2FuIHdvcmQgbGFyIGhvc2lsIHFpbGluYWRpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBrZXlXb3JkczsgaSsrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcbiAgICAgIC8vIEFFUy0yNTYgaG9sYXRpZGEgaGFyIHRv4oCYcnRpbmNoaSB3b3JkIGdhIHFv4oCYc2hpbWNoYSBTLWJveCAoU3ViV29yZCkgcW/igJhsbGFuYWRpXG4gICAgICBpZiAoa2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzI1NiAmJiBpID09PSA0KSB7XG4gICAgICAgIGNvbnN0IHRlbXBXb3JkID0gW25ld0tleVtvZmZzZXQgLSA0XSwgbmV3S2V5W29mZnNldCAtIDNdLCBuZXdLZXlbb2Zmc2V0IC0gMl0sIG5ld0tleVtvZmZzZXQgLSAxXV07XG4gICAgICAgIGNvbnN0IHN1YlRlbXBXb3JkID0gdGVtcFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgICAgIFxuICAgICAgICBuZXdLZXlbb2Zmc2V0XSA9IHByZXZLZXlbb2Zmc2V0XSBeIHN1YlRlbXBXb3JkWzBdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgMV0gPSBwcmV2S2V5W29mZnNldCArIDFdIF4gc3ViVGVtcFdvcmRbMV07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAyXSA9IHByZXZLZXlbb2Zmc2V0ICsgMl0gXiBzdWJUZW1wV29yZFsyXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDNdID0gcHJldktleVtvZmZzZXQgKyAzXSBeIHN1YlRlbXBXb3JkWzNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3S2V5W29mZnNldF0gPSBuZXdLZXlbb2Zmc2V0IC0gNF0gXiBwcmV2S2V5W29mZnNldF07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAxXSA9IG5ld0tleVtvZmZzZXQgLSAzXSBeIHByZXZLZXlbb2Zmc2V0ICsgMV07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAyXSA9IG5ld0tleVtvZmZzZXQgLSAyXSBeIHByZXZLZXlbb2Zmc2V0ICsgMl07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAzXSA9IG5ld0tleVtvZmZzZXQgLSAxXSBeIHByZXZLZXlbb2Zmc2V0ICsgM107XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJvdW5kS2V5cy5wdXNoKG5ld0tleSk7XG4gIH1cbiAgXG4gIHJldHVybiByb3VuZEtleXM7XG59O1xuXG4vLyBQZXJmb3JtIG9uZSByb3VuZCBvZiBBRVNcbmV4cG9ydCBjb25zdCBhZXNSb3VuZCA9IChzdGF0ZTogbnVtYmVyW10sIHJvdW5kS2V5OiBudW1iZXJbXSwgaXNMYXN0Um91bmQ6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gIGxldCBuZXdTdGF0ZSA9IHN1YkJ5dGVzKHN0YXRlKTtcbiAgbmV3U3RhdGUgPSBzaGlmdFJvd3MobmV3U3RhdGUpO1xuICBpZiAoIWlzTGFzdFJvdW5kKSB7XG4gICAgbmV3U3RhdGUgPSBtaXhDb2x1bW5zKG5ld1N0YXRlKTtcbiAgfVxuICBuZXdTdGF0ZSA9IGFkZFJvdW5kS2V5KG5ld1N0YXRlLCByb3VuZEtleSk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn07XG5cbi8vIENvbXBsZXRlIEFFUyBlbmNyeXB0aW9uXG5leHBvcnQgY29uc3QgYWVzRW5jcnlwdCA9IChcbiAgcGxhaW50ZXh0OiBzdHJpbmcsXG4gIGtleTogbnVtYmVyW10sXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjhcbik6IG51bWJlcltdID0+IHtcbiAgLy8gSW5pdGlhbCBzdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHRleHRUb1N0YXRlKHBsYWludGV4dCk7XG4gIFxuICAvLyBLZXkgZXhwYW5zaW9uXG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXksIGtleUxlbmd0aCk7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGdldE51bVJvdW5kcyhrZXlMZW5ndGgpO1xuICBcbiAgLy8gSW5pdGlhbCByb3VuZCAtIGp1c3QgQWRkUm91bmRLZXlcbiAgbGV0IGN1cnJlbnRTdGF0ZSA9IGFkZFJvdW5kS2V5KHN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBcbiAgLy8gTWFpbiByb3VuZHNcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICBjdXJyZW50U3RhdGUgPSBhZXNSb3VuZChjdXJyZW50U3RhdGUsIHJvdW5kS2V5c1tyb3VuZF0sIHJvdW5kID09PSBudW1Sb3VuZHMpO1xuICB9XG4gIFxuICByZXR1cm4gY3VycmVudFN0YXRlO1xufTtcblxuLy8gQ29udmVydCBmdWxsIHRleHQgdG8gYXJyYXkgb2YgMTYtYnl0ZSBibG9ja3NcbmV4cG9ydCBjb25zdCB0ZXh0VG9CbG9ja3MgPSAodGV4dDogc3RyaW5nLCBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3KTogbnVtYmVyW11bXSA9PiB7XG4gIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHRleHQpO1xuICBjb25zdCBieXRlczogbnVtYmVyW10gPSBbXTtcbiAgXG4gIC8vIENvbnZlcnQgQ3J5cHRvSlMgV29yZEFycmF5IHRvIGJ5dGUgYXJyYXksIHJlc3BlY3Rpbmcgc2lnQnl0ZXNcbiAgY29uc3Qgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZEFycmF5LndvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgd29yZCA9IHdvcmRBcnJheS53b3Jkc1tpXTtcbiAgICBjb25zdCBieXRlc0luVGhpc1dvcmQgPSBNYXRoLm1pbig0LCBzaWdCeXRlcyAtIGkgKiA0KTtcbiAgICBcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDEpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMikgYnl0ZXMucHVzaCgod29yZCA+Pj4gMTYpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAzKSBieXRlcy5wdXNoKCh3b3JkID4+PiA4KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gNCkgYnl0ZXMucHVzaCh3b3JkICYgMHhmZik7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IHBhZGRpbmdcbiAgbGV0IHBhZGRlZEJ5dGVzOiBudW1iZXJbXTtcbiAgaWYgKHBhZGRpbmcgPT09IFBhZGRpbmdUeXBlLlBLQ1M3KSB7XG4gICAgcGFkZGVkQnl0ZXMgPSBhcHBseVBLQ1M3UGFkZGluZyhieXRlcyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuQU5TSV9YOTIzKSB7XG4gICAgcGFkZGVkQnl0ZXMgPSBhcHBseUFuc2lYOTIzUGFkZGluZyhieXRlcyk7XG4gIH0gZWxzZSB7IC8vIE5PTkVcbiAgICBwYWRkZWRCeXRlcyA9IFsuLi5ieXRlc107XG4gICAgLy8gRm9yIE5PTkUgcGFkZGluZywgbXVzdCBiZSBtdWx0aXBsZSBvZiAxNlxuICAgIHdoaWxlIChwYWRkZWRCeXRlcy5sZW5ndGggJSAxNiAhPT0gMCkge1xuICAgICAgcGFkZGVkQnl0ZXMucHVzaCgwKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNwbGl0IGludG8gMTYtYnl0ZSBibG9ja3NcbiAgY29uc3QgYmxvY2tzOiBudW1iZXJbXVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQnl0ZXMubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgYmxvY2tzLnB1c2gocGFkZGVkQnl0ZXMuc2xpY2UoaSwgaSArIDE2KSk7XG4gIH1cbiAgXG4gIHJldHVybiBibG9ja3M7XG59O1xuXG4vLyBBcHBseSBQS0NTNyBwYWRkaW5nXG5leHBvcnQgY29uc3QgYXBwbHlQS0NTN1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRlZCA9IFsuLi5kYXRhXTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nTGVuZ3RoOyBpKyspIHtcbiAgICBwYWRkZWQucHVzaChwYWRkaW5nTGVuZ3RoKTtcbiAgfVxuICBcbiAgcmV0dXJuIHBhZGRlZDtcbn07XG5cbi8vIEFwcGx5IEFOU0kgWC45MjMgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IGFwcGx5QW5zaVg5MjNQYWRkaW5nID0gKGRhdGE6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBwYWRkZWQgPSBbLi4uZGF0YV07XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcbiAgXG4gIC8vIEFkZCBwYWRkaW5nIGJ5dGVzICgweDAwKSBleGNlcHQgdGhlIGxhc3QgYnl0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmdMZW5ndGggLSAxOyBpKyspIHtcbiAgICBwYWRkZWQucHVzaCgweDAwKTtcbiAgfVxuICBcbiAgLy8gQWRkIHRoZSBwYWRkaW5nIGxlbmd0aCBhcyB0aGUgbGFzdCBieXRlXG4gIHBhZGRlZC5wdXNoKHBhZGRpbmdMZW5ndGgpO1xuICBcbiAgcmV0dXJuIHBhZGRlZDtcbn07XG5cbi8vIFJlbW92ZSBBTlNJIFguOTIzIHBhZGRpbmdcbmV4cG9ydCBjb25zdCByZW1vdmVBbnNpWDkyM1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gIHJldHVybiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aCk7XG59O1xuXG4vLyBHZXQgSVYgZm9yIENCQyBtb2RlXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJViA9ICgpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGl2ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGl2LnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gIH1cbiAgcmV0dXJuIGl2O1xufTtcblxuLy8gR2V0IGFsbCBpbnRlcm1lZGlhdGUgc3RhdGVzIGZvciB2aXN1YWxpemF0aW9uXG5leHBvcnQgdHlwZSBBZXNTdGVwID0ge1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBzdGF0ZTogbnVtYmVyW107XG4gIGFjdGl2ZUluZGljZXM/OiBudW1iZXJbXTsgIC8vIEZvciBoaWdobGlnaHRpbmcgc3BlY2lmaWMgY2VsbHNcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmc7ICAgICAgLy8gTW9yZSBkZXRhaWxlZCBleHBsYW5hdGlvblxuICByb3VuZEtleT86IG51bWJlcltdO1xuICBwcmV2aW91c1N0YXRlPzogbnVtYmVyW107ICAvLyBGb3Igc2hvd2luZyBiZWZvcmUvYWZ0ZXIgY29tcGFyaXNvblxufTtcblxuLy8gR2V0IEFFUyBzdGVwcyBmb3IgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKVxuZXhwb3J0IGNvbnN0IGdldEFlc1N0ZXBzRm9yQmxvY2sgPSAoXG4gIGJsb2NrOiBudW1iZXJbXSxcbiAga2V5OiBudW1iZXJbXSxcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBibG9ja0luZGV4OiBudW1iZXIgPSAwLFxuICBwcmV2aW91c0NpcGhlcnRleHRCbG9jaz86IG51bWJlcltdLFxuICBpdj86IG51bWJlcltdLFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4XG4pOiB7XG4gIHN0ZXBzOiBBZXNTdGVwW10sXG4gIGZpbmFsU3RhdGU6IG51bWJlcltdXG59ID0+IHtcbiAgY29uc3Qgc3RlcHM6IEFlc1N0ZXBbXSA9IFtdO1xuICBcbiAgLy8gRW5zdXJlIGJsb2NrIGlzIGV4YWN0bHkgMTYgYnl0ZXNcbiAgY29uc3QgcGxhaW50ZXh0Qnl0ZXMgPSBbLi4uYmxvY2tdO1xuICB3aGlsZSAocGxhaW50ZXh0Qnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICBwbGFpbnRleHRCeXRlcy5wdXNoKDApO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBBc2wgb2NoaXEgbWF0bmAsIFxuICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0gYmF5dGdhIGF5bGFudGlyaWxhZGkgdmEgNMOXNCBtYXRyaXRzYSBzaGFrbGlkYSBpZm9kYWxhbmFkaS5gXG4gIH0pO1xuICBcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGxhaW50ZXh0Qnl0ZXM7XG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXksIGtleUxlbmd0aCk7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGdldE51bVJvdW5kcyhrZXlMZW5ndGgpO1xuICBcbiAgbGV0IGN1cnJlbnRTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKGJsb2NrSW5kZXggPT09IDAgJiYgaXYpIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGl2W2ldKTtcbiAgICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgSVYgYmlsYW4gWE9SYCwgXG4gICAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICAgIHByZXZpb3VzU3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICAgICAgICByb3VuZEtleTogaXYsXG4gICAgICAgICAgZXhwbGFuYXRpb246IGBDQkM6IGJpcmluY2hpIGJsb2sgSVYgYmlsYW4gWE9SIHFpbGluYWRpLmBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBwcmV2aW91c0NpcGhlcnRleHRCbG9ja1tpXSk7XG4gICAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIE9sZGluZ2kgY2lwaGVydGV4dCBiaWxhbiBYT1JgLCBcbiAgICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHJvdW5kS2V5OiBwcmV2aW91c0NpcGhlcnRleHRCbG9jayxcbiAgICAgICAgICBleHBsYW5hdGlvbjogYENCQzoga2V5aW5naSBibG9rbGFyIG9sZGluZ2kgY2lwaGVydGV4dCBibG9raSBiaWxhbiBYT1IgcWlsaW5hZGkuYFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBpZiAoIWl2KSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBzOiBbXSwgZmluYWxTdGF0ZTogcGxhaW50ZXh0Qnl0ZXMgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvdW50ZXJCbG9jayA9IFsuLi5pdl07XG4gICAgICBsZXQgY291bnRlclZhbHVlID0gYmxvY2tJbmRleDtcbiAgICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwICYmIGNvdW50ZXJWYWx1ZSA+IDA7IGktLSkge1xuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyQmxvY2tbaV0gKyAoY291bnRlclZhbHVlICYgMHhmZik7XG4gICAgICAgIGNvdW50ZXJCbG9ja1tpXSA9IHN1bSAmIDB4ZmY7XG4gICAgICAgIGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyVmFsdWUgPj4gOCkgKyAoc3VtID4+IDgpO1xuICAgICAgfVxuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIENvdW50ZXJgLCBcbiAgICAgICAgc3RhdGU6IGNvdW50ZXJCbG9jayxcbiAgICAgICAgZXhwbGFuYXRpb246IGBDVFI6IGJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4gY291bnRlci5gXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGNvdW50ZXJCbG9jaztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIEJvc2hsYW5nJ2ljaGAsIFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBleHBsYW5hdGlvbjogYEVDQjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSBtdXN0YXFpbCBzaGlmcmxhbmFkaS5gXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBjb25zdCBhZnRlckluaXRpYWxSb3VuZCA9IGFkZFJvdW5kS2V5KGN1cnJlbnRTdGF0ZSwgcm91bmRLZXlzWzBdKTtcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgMC1ib3NxaWNoIOKAlCBBZGRSb3VuZEtleWAsIFxuICAgIHN0YXRlOiBhZnRlckluaXRpYWxSb3VuZCxcbiAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICByb3VuZEtleTogcm91bmRLZXlzWzBdLFxuICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgfSk7XG4gIFxuICBjdXJyZW50U3RhdGUgPSBhZnRlckluaXRpYWxSb3VuZDtcbiAgXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gbnVtUm91bmRzOyByb3VuZCsrKSB7XG4gICAgY29uc3QgYWZ0ZXJTdWJCeXRlcyA9IHN1YkJ5dGVzKGN1cnJlbnRTdGF0ZSk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAke3JvdW5kfS1ib3NxaWNoIOKAlCBTdWJCeXRlc2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU3ViQnl0ZXMsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgYWZ0ZXJTaGlmdFJvd3MgPSBzaGlmdFJvd3MoYWZ0ZXJTdWJCeXRlcyk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAke3JvdW5kfS1ib3NxaWNoIOKAlCBTaGlmdFJvd3NgLCBcbiAgICAgIHN0YXRlOiBhZnRlclNoaWZ0Um93cyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IFsxLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTEsIDEzLCAxNCwgMTVdLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTdWJCeXRlc1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXk6IG51bWJlcltdO1xuICAgIFxuICAgIGlmIChyb3VuZCA8IG51bVJvdW5kcykge1xuICAgICAgY29uc3QgYWZ0ZXJNaXhDb2x1bW5zID0gbWl4Q29sdW1ucyhhZnRlclNoaWZ0Um93cyk7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgTWl4Q29sdW1uc2AsIFxuICAgICAgICBzdGF0ZTogYWZ0ZXJNaXhDb2x1bW5zLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICAgIHByZXZpb3VzU3RhdGU6IGFmdGVyU2hpZnRSb3dzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJNaXhDb2x1bW5zLCByb3VuZEtleXNbcm91bmRdKTtcbiAgICAgIHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSA9IGFmdGVyTWl4Q29sdW1ucztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJTaGlmdFJvd3MsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJTaGlmdFJvd3M7XG4gICAgfVxuICAgIFxuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgJHtyb3VuZH0tYm9zcWljaCDigJQgQWRkUm91bmRLZXlgLCBcbiAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcm91bmRLZXk6IHJvdW5kS2V5c1tyb3VuZF0sXG4gICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXksXG4gICAgfSk7XG4gIH1cbiAgXG4gIGxldCBmaW5hbFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaW5pdGlhbFN0YXRlW2ldKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBDb3VudGVyIFhPUmAsIFxuICAgICAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246IGBDVFI6IGJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4gY291bnRlciBYT1IuYCxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogY3VycmVudFN0YXRlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIFlha3VuaXlgLCBcbiAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICBleHBsYW5hdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0gdWNodW4geWFrdW5peSBzaGlmcmxhbmdhbiBuYXRpamEuYFxuICB9KTtcbiAgXG4gIHJldHVybiB7IHN0ZXBzLCBmaW5hbFN0YXRlIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWVzU3RlcHMgPSAoXG4gIHBsYWludGV4dDogc3RyaW5nLCBcbiAga2V5OiBudW1iZXJbXSwgXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgcHJvdmlkZWRJdj86IG51bWJlcltdLFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4XG4pOiB7XG4gIHN0ZXBzOiBBZXNTdGVwW10sXG4gIGZpbmFsQ2lwaGVydGV4dDoge1xuICAgIGJhc2U2NDogc3RyaW5nO1xuICAgIGhleDogc3RyaW5nO1xuICAgIGJpbmFyeTogc3RyaW5nO1xuICB9LFxuICBpdj86IG51bWJlcltdLFxuICBhbGxCbG9ja3M/OiB7IGJsb2NrSW5kZXg6IG51bWJlciwgc3RlcHM6IEFlc1N0ZXBbXSwgZmluYWxTdGF0ZTogbnVtYmVyW10gfVtdXG59ID0+IHtcbiAgY29uc3Qgc3RlcHM6IEFlc1N0ZXBbXSA9IFtdO1xuICBsZXQgaXY6IG51bWJlcltdIHwgdW5kZWZpbmVkID0gcHJvdmlkZWRJdiA/IFsuLi5wcm92aWRlZEl2XSA6IHVuZGVmaW5lZDtcbiAgXG4gIC8vIENvbnZlcnQgZnVsbCB0ZXh0IHRvIGJsb2Nrc1xuICBjb25zdCBibG9ja3MgPSB0ZXh0VG9CbG9ja3MocGxhaW50ZXh0LCBwYWRkaW5nKTtcbiAgY29uc3QgYWxsQmxvY2tzOiB7IGJsb2NrSW5kZXg6IG51bWJlciwgc3RlcHM6IEFlc1N0ZXBbXSwgZmluYWxTdGF0ZTogbnVtYmVyW10gfVtdID0gW107XG4gIFxuICAvLyBDb252ZXJ0IHBsYWludGV4dCB0byBieXRlcyAoZm9yIGZpcnN0IGJsb2NrIHZpc3VhbGl6YXRpb24pXG4gIGxldCBwbGFpbnRleHRCeXRlcyA9IGJsb2Nrc1swXSB8fCB0ZXh0VG9TdGF0ZShwbGFpbnRleHQpO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICdBc2wgb2NoaXEgbWF0bicsIFxuICAgIHN0YXRlOiBwbGFpbnRleHRCeXRlcyxcbiAgICBleHBsYW5hdGlvbjogYE9jaGlxIG1hdG4gXCIke3BsYWludGV4dH1cIiBiYXl0Z2EgYXlsYW50aXJpbGFkaSB2YSA0w5c0IG1hdHJpdHNhIHNoYWtsaWRhIGlmb2RhbGFuYWRpLmBcbiAgfSk7XG4gIFxuICAvLyBBcHBseSBwYWRkaW5nIGlmIG5lZWRlZFxuICBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuQU5TSV9YOTIzKSB7XG4gICAgcGxhaW50ZXh0Qnl0ZXMgPSBhcHBseUFuc2lYOTIzUGFkZGluZyhwbGFpbnRleHRCeXRlcyk7XG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246ICdBTlNJIFguOTIzIHRv4oCYbGRpcmlzaGRhbiBrZXlpbicsIFxuICAgICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgICAgZXhwbGFuYXRpb246ICdBTlNJIFguOTIzIHRv4oCYbGRpcmlzaCBub2xsYXIgYmlsYW4gdG/igJhsZGlyYWRpIHZhIG94aXJnaSBieXRlIGdhIHRv4oCYbGRpcmlzaCB1enVubGlnaW5pIHFv4oCYeWFkaS4nXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEdlbmVyYXRlIElWIGZvciBDQkMvQ1RSIG1vZGUgb25seSBpZiBub3QgcHJvdmlkZWRcbiAgaWYgKChtb2RlID09PSBBZXNNb2RlLkNCQyB8fCBtb2RlID09PSBBZXNNb2RlLkNUUikgJiYgIWl2KSB7XG4gICAgaXYgPSBnZW5lcmF0ZUlWKCk7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIE9ubHkgc2hvdyBJViBzdGVwIGlmIHNpbmdsZSBibG9jayAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBjb25zdCBpdkRlc2NyaXB0aW9uID0gbW9kZSA9PT0gQWVzTW9kZS5DQkMgXG4gICAgICAgID8gJ0Jvc2hsYW5nXFwnaWNoIHZla3RvciAoSW5pdGlhbGl6YXRpb24gVmVjdG9yLCBJViknIFxuICAgICAgICA6ICdDb3VudGVyIChOb25jZSknO1xuICAgICAgY29uc3QgaXZFeHBsYW5hdGlvbiA9IGAke21vZGUgPT09IEFlc01vZGUuQ0JDID8gJ0NCQycgOiAnQ1RSJ30gcmVqaW1pIHVjaHVuIDE2LWJheXQgdGFzb2RpZml5ICR7bW9kZSA9PT0gQWVzTW9kZS5DQkMgPyAnSVYnIDogJ05vbmNlJ30geWFyYXRpbGFkaS5gO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogaXZEZXNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6IGl2LFxuICAgICAgICBleHBsYW5hdGlvbjogaXZFeHBsYW5hdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdGFydCBlbmNyeXB0aW9uIHByb2Nlc3MgKGZvciBmaXJzdCBibG9jayB2aXN1YWxpemF0aW9uKVxuICBjb25zdCBpbml0aWFsU3RhdGUgPSBwbGFpbnRleHRCeXRlcztcbiAgXG4gIC8vIEtleSBleHBhbnNpb25cbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSwga2V5TGVuZ3RoKTtcbiAgY29uc3QgbnVtUm91bmRzID0gZ2V0TnVtUm91bmRzKGtleUxlbmd0aCk7XG4gIFxuICAvLyBJbml0aWFsIHNldHVwIGJhc2VkIG9uIG1vZGVcbiAgbGV0IGN1cnJlbnRTdGF0ZTogbnVtYmVyW107XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKCFpdikgaXYgPSBnZW5lcmF0ZUlWKCk7IC8vIEZhaWxzYWZlXG4gICAgICAvLyBYT1IgcGxhaW50ZXh0IHdpdGggSVZcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBpdiFbaV0pXG5cbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ1xcJ2ljaCBob2xhdG5pIElWIGJpbGFuIFhPUiBxaWxpc2gnLCBcbiAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogaXYsIC8vIElWIG5pIHJvdW5kS2V5IHNpZmF0aWRhIGtvJ3JzYXRpc2ggdWNodW5cbiAgICAgICAgZXhwbGFuYXRpb246IGBDQkMgcmVqaW1pZGEgc2hpZnJsYXNoIGJvc2hsYW5pc2hpZGFuIG9sZGluIG9jaGlxIG1hdG4gSVYgYmlsYW4gWE9SIHFpbGluYWRpLiBCdSBqYXJheW9uIENCQyByZWppbWluaW5nIGFzb3NpeSB4dXN1c2l5YXRpZGlyIC0gaGFyIGJpciBvY2hpcSBtYXRuIGJsb2tpIGF2dmFsZ2kgc2hpZnJsYW5nYW4gbWF0biBibG9raSAoeW9raSBiaXJpbmNoaSBibG9rIHVjaHVuIElWKSBiaWxhbiBYT1IgcWlsaW5hZGksIGtleWluIHNoaWZybGFuYWRpLiBCdSBiaXIgeGlsIG9jaGlxIG1hdG4gYmxva2xhcmluaSB0dXJsaSBzaGlmcmxhbmdhbiBtYXRuIGJsb2tsYXJnYSBheWxhbnRpcmFkaSB2YSBzaGlmcmxhbmdhbiBtYXRuZGFnaSBuYXFzaGxhcm5pIHlhc2hpcmlzaGdhIHlvcmRhbSBiZXJhZGkuYFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgLy8gSW4gQ1RSIG1vZGUsIHdlIGVuY3J5cHQgYSBjb3VudGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIHBsYWludGV4dFxuICAgICAgY29uc3QgY291bnRlciA9IGl2IHx8IGdlbmVyYXRlSVYoKTtcbiAgICAgIGlmICghaXYpIGl2ID0gY291bnRlcjtcbiAgICAgIFxuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvdW50ZXIgcWl5bWF0aScsIFxuICAgICAgICBzdGF0ZTogY291bnRlcixcbiAgICAgICAgZXhwbGFuYXRpb246ICdDVFIgcmVqaW1pZGEgb2NoaXEgbWF0biBv4oCYcm5pZ2EgY291bnRlciBxaXltYXRpIHNoaWZybGFuYWRpLidcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjdXJyZW50U3RhdGUgPSBjb3VudGVyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQm9zaGxhbmfigJhpY2ggaG9sYXQgKG9jaGlxIG1hdG4pJywgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnRUNCIHJlamltaWRhIG9jaGlxIG1hdG4gYmxva2xhcmkgbXVzdGFxaWwgcmF2aXNoZGEgc2hpZnJsYW5hZGkuJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgLy8gSW5pdGlhbCByb3VuZCAtIGp1c3QgQWRkUm91bmRLZXkgKFJvdW5kIDApXG4gIGNvbnN0IGFmdGVySW5pdGlhbFJvdW5kID0gYWRkUm91bmRLZXkoY3VycmVudFN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICcwLWJvc3FpY2gg4oCUIEJvc2hsYW5nXFwnaWNoIEFkZFJvdW5kS2V5JywgXG4gICAgc3RhdGU6IGFmdGVySW5pdGlhbFJvdW5kLFxuICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgZXhwbGFuYXRpb246ICcnLFxuICAgIHJvdW5kS2V5OiByb3VuZEtleXNbMF0sXG4gICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlLFxuICB9KTtcbiAgXG4gIGN1cnJlbnRTdGF0ZSA9IGFmdGVySW5pdGlhbFJvdW5kO1xuICBcbiAgLy8gTWFpbiByb3VuZHNcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICAvLyBTdWJCeXRlc1xuICAgIGNvbnN0IGFmdGVyU3ViQnl0ZXMgPSBzdWJCeXRlcyhjdXJyZW50U3RhdGUpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgU3ViQnl0ZXNgLCBcbiAgICAgIHN0YXRlOiBhZnRlclN1YkJ5dGVzLFxuICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHByZXZpb3VzU3RhdGU6IGN1cnJlbnRTdGF0ZSAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIFMtYm94IGxvb2t1cFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNoaWZ0Um93c1xuICAgIGNvbnN0IGFmdGVyU2hpZnRSb3dzID0gc2hpZnRSb3dzKGFmdGVyU3ViQnl0ZXMpO1xuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgU2hpZnRSb3dzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTaGlmdFJvd3MsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBbMSwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExLCAxMywgMTQsIDE1XSwgLy8gUm93cyAxLCAyLCAzIChub3QgUm93IDApIGluIGNvbHVtbi1tYWpvclxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTdWJCeXRlcyAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIGNvbXBhcmlzb25cbiAgICB9KTtcbiAgICBcbiAgICBsZXQgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5OiBudW1iZXJbXTtcbiAgICBcbiAgICBpZiAocm91bmQgPCBudW1Sb3VuZHMpIHtcbiAgICAgIC8vIE1peENvbHVtbnMgKG5vdCBpbiBmaW5hbCByb3VuZClcbiAgICAgIGNvbnN0IGFmdGVyTWl4Q29sdW1ucyA9IG1peENvbHVtbnMoYWZ0ZXJTaGlmdFJvd3MpO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIE1peENvbHVtbnNgLCBcbiAgICAgICAgc3RhdGU6IGFmdGVyTWl4Q29sdW1ucyxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclNoaWZ0Um93cyAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIE1peENvbHVtbnMgY29tcGFyaXNvblxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZFJvdW5kS2V5XG4gICAgICBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShhZnRlck1peENvbHVtbnMsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJNaXhDb2x1bW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5hbCByb3VuZCBoYXMgbm8gTWl4Q29sdW1uc1xuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJTaGlmdFJvd3MsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJTaGlmdFJvd3M7XG4gICAgfVxuICAgIFxuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgQWRkUm91bmRLZXlgLCBcbiAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcm91bmRLZXk6IHJvdW5kS2V5c1tyb3VuZF0sXG4gICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXksXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEZpbmFsIG91dHB1dCBiYXNlZCBvbiBtb2RlXG4gIGxldCBmaW5hbFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICAvLyBPdXRwdXQgaXMgdGhlIGN1cnJlbnQgc3RhdGUgKGFscmVhZHkgY29tcGxldGVkIGVuY3J5cHRpb24pXG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIC8vIFhPUiB0aGUgZW5jcnlwdGVkIGNvdW50ZXIgd2l0aCBwbGFpbnRleHRcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaW5pdGlhbFN0YXRlW2ldKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdPY2hpcSBtYXRuIHNoaWZybGFuZ2FuIGhpc29ibGFnaWNoIGJpbGFuIFhPUiBhbWFsaXlvdGlkYSBiaXJsYXNodGlyaWxhZGkuJywgXG4gICAgICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0NUUiByZWppbWlkYSwgeWFrdW5peSBib3NxaWNoZGEgc2hpZnJsYW5nYW4gaGlzb2JsYWdpY2ggb2NoaXEgbWF0biBiaWxhbiBYT1IgYW1hbGl5b3RpIG9ycWFsaSBiaXJsYXNodGlyaWxhZGkgdmEgbmF0aWphZGEgc2hpZnJsYW5nYW4gbWF0biBob3NpbCBib+KAmGxhZGkuJyxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogY3VycmVudFN0YXRlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICdZYWt1bml5IHNoaWZybGFuZ2FuIG1hdG4nLCBcbiAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICBleHBsYW5hdGlvbjogYCR7bW9kZX0gcmVqaW1pZGEgQUVTLSR7a2V5TGVuZ3RofSB5b3JkYW1pZGEgb2xpbmdhbiB5YWt1bml5IHNoaWZybGFuZ2FuIG5hdGlqYS5gXG4gIH0pO1xuICBcbiAgLy8gUHJvY2VzcyBhbGwgYmxvY2tzIGZvciBtdWx0aS1ibG9jayBzdXBwb3J0XG4gIGxldCBwcmV2aW91c0NpcGhlcnRleHRCbG9jazogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGNvbWJpbmVkRmluYWxTdGF0ZXM6IG51bWJlcltdID0gW107XG4gIFxuICAvLyBHZW5lcmF0ZSBJViBpZiBuZWVkZWRcbiAgaWYgKChtb2RlID09PSBBZXNNb2RlLkNCQyB8fCBtb2RlID09PSBBZXNNb2RlLkNUUikgJiYgIWl2KSB7XG4gICAgaXYgPSBnZW5lcmF0ZUlWKCk7XG4gIH1cbiAgXG4gIGZvciAobGV0IGJsb2NrSW5kZXggPSAwOyBibG9ja0luZGV4IDwgYmxvY2tzLmxlbmd0aDsgYmxvY2tJbmRleCsrKSB7XG4gICAgY29uc3QgYmxvY2tSZXN1bHQgPSBnZXRBZXNTdGVwc0ZvckJsb2NrKFxuICAgICAgYmxvY2tzW2Jsb2NrSW5kZXhdLFxuICAgICAga2V5LFxuICAgICAgbW9kZSxcbiAgICAgIGJsb2NrSW5kZXgsXG4gICAgICBwcmV2aW91c0NpcGhlcnRleHRCbG9jayxcbiAgICAgIGl2LFxuICAgICAga2V5TGVuZ3RoXG4gICAgKTtcbiAgICBcbiAgICBhbGxCbG9ja3MucHVzaCh7XG4gICAgICBibG9ja0luZGV4LFxuICAgICAgc3RlcHM6IGJsb2NrUmVzdWx0LnN0ZXBzLFxuICAgICAgZmluYWxTdGF0ZTogYmxvY2tSZXN1bHQuZmluYWxTdGF0ZVxuICAgIH0pO1xuICAgIFxuICAgIGNvbWJpbmVkRmluYWxTdGF0ZXMucHVzaCguLi5ibG9ja1Jlc3VsdC5maW5hbFN0YXRlKTtcbiAgICBcbiAgICAvLyBGb3IgQ0JDIG1vZGUsIHVzZSBjdXJyZW50IGNpcGhlcnRleHQgYXMgcHJldmlvdXMgZm9yIG5leHQgYmxvY2tcbiAgICBpZiAobW9kZSA9PT0gQWVzTW9kZS5DQkMpIHtcbiAgICAgIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrID0gYmxvY2tSZXN1bHQuZmluYWxTdGF0ZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFVzZSBjb21iaW5lZCBmaW5hbCBzdGF0ZXMgaWYgd2UgaGF2ZSBtdWx0aXBsZSBibG9ja3MsIG90aGVyd2lzZSB1c2Ugc2luZ2xlIGJsb2NrIHJlc3VsdFxuICBjb25zdCBmaW5hbFN0YXRlVG9Vc2UgPSBibG9ja3MubGVuZ3RoID4gMSA/IGNvbWJpbmVkRmluYWxTdGF0ZXMgOiBmaW5hbFN0YXRlO1xuICBcbiAgLy8gQ29udmVydCB0aGUgZmluYWwgc3RhdGUgdG8gdGhlIHJlcXVlc3RlZCBvdXRwdXQgZm9ybWF0XG4gIGNvbnN0IGZpbmFsV29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoXG4gICAgbmV3IFVpbnQ4QXJyYXkoZmluYWxTdGF0ZVRvVXNlKSBhcyBhbnlcbiAgKTtcbiAgXG4gIGNvbnN0IGZpbmFsQ2lwaGVydGV4dEJhc2U2NCA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KGZpbmFsV29yZEFycmF5KTtcbiAgY29uc3QgZmluYWxDaXBoZXJ0ZXh0SGV4ID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoZmluYWxXb3JkQXJyYXkpO1xuICBjb25zdCBmaW5hbENpcGhlcnRleHRCaW5hcnkgPSBieXRlc1RvQmluYXJ5KGZpbmFsU3RhdGVUb1VzZSwgJycpO1xuICBcbiAgcmV0dXJuIHsgXG4gICAgc3RlcHMsIFxuICAgIGZpbmFsQ2lwaGVydGV4dDoge1xuICAgICAgYmFzZTY0OiBmaW5hbENpcGhlcnRleHRCYXNlNjQsXG4gICAgICBoZXg6IGZpbmFsQ2lwaGVydGV4dEhleCxcbiAgICAgIGJpbmFyeTogZmluYWxDaXBoZXJ0ZXh0QmluYXJ5XG4gICAgfSwgXG4gICAgaXYsXG4gICAgYWxsQmxvY2tzOiBhbGxCbG9ja3MubGVuZ3RoID4gMSA/IGFsbEJsb2NrcyA6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuLy8gR2V0IGtleSBleHBhbnNpb24gc3RlcHMgd2l0aCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRLZXlFeHBhbnNpb25TdGVwcyA9IChcbiAga2V5OiBudW1iZXJbXSxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOFxuKTogeyBcbiAgZGVzY3JpcHRpb246IHN0cmluZywgXG4gIGtleTogbnVtYmVyW10sXG4gIGV4cGxhbmF0aW9uPzogc3RyaW5nLFxuICBoaWdobGlnaHRlZENlbGxzPzogbnVtYmVyW11cbn1bXSA9PiB7XG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXksIGtleUxlbmd0aCk7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGdldE51bVJvdW5kcyhrZXlMZW5ndGgpO1xuICBjb25zdCBzdGVwcyA9IFtdO1xuICBcbiAgc3RlcHMucHVzaCh7XG4gICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ+KAmGljaCBrYWxpdCcsXG4gICAga2V5OiByb3VuZEtleXNbMF0sXG4gICAgZXhwbGFuYXRpb246IGBCdSBmb3lkYWxhbnV2Y2hpIHRvbW9uaWRhbiBiZXJpbGdhbiBhc2wgJHtrZXlMZW5ndGh9LWJpdGxpIGthbGl0ZGlyLmBcbiAgfSk7XG4gIFxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGNvbnN0IHByZXZLZXkgPSByb3VuZEtleXNbcm91bmQgLSAxXTtcbiAgICBjb25zdCBjdXJyZW50S2V5ID0gcm91bmRLZXlzW3JvdW5kXTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRyYW5zZm9ybWF0aW9ucyBmb3IgYSBtb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uXG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVsxMl0sIHByZXZLZXlbMTNdLCBwcmV2S2V5WzE0XSwgcHJldktleVsxNV1dO1xuICAgIGNvbnN0IHJvdFdvcmQgPSBbbGFzdFdvcmRbMV0sIGxhc3RXb3JkWzJdLCBsYXN0V29yZFszXSwgbGFzdFdvcmRbMF1dO1xuICAgIGNvbnN0IHNib3hXb3JkID0gcm90V29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICBjb25zdCByY29uVmFsdWUgPSBSQ09OW3JvdW5kXTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFdvcmQgPSBbLi4uc2JveFdvcmRdO1xuICAgIHRyYW5zZm9ybWVkV29yZFswXSBePSByY29uVmFsdWU7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBwcmV2aW91cyBrZXkgYW5kIGl0cyBYT1Igd2l0aCB0aGUgdHJhbnNmb3JtZWQgd29yZFxuICAgIGNvbnN0IGZpcnN0V29yZFByZXYgPSBbcHJldktleVswXSwgcHJldktleVsxXSwgcHJldktleVsyXSwgcHJldktleVszXV07XG4gICAgY29uc3QgeG9yUmVzdWx0ID0gZmlyc3RXb3JkUHJldi5tYXAoKGJ5dGUsIGluZGV4KSA9PiBieXRlIF4gdHJhbnNmb3JtZWRXb3JkW2luZGV4XSk7XG5cblxuICAgIC8vIFNob3cgdGhlIGtleSB3aXRoIGhpZ2hsaWdodGVkIGNlbGxzIGZvciB0aGUgbmV3IHdvcmRcbiAgICBzdGVwcy5wdXNoKHtcbiAgICAgIGRlc2NyaXB0aW9uOiBgUmF1bmQga2FsaXRpICR7cm91bmR9YCxcbiAgICAgIGtleTogY3VycmVudEtleSxcbiAgICAgIGV4cGxhbmF0aW9uOiBgXG4gICAgICAgICR7cm91bmR9LXJhdW5kIHVjaHVuIGthbGl0bmkga2VuZ2F5dGlyaXNoIGphcmF5b25pOlxuICAgICAgICAxLiBPbGRpbmdpIGthbGl0bmluZyBveGlyZ2kgd29yZCBxaXNtaW5pIG9saW5nOiBbJHtsYXN0V29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgMi4gV29yZG5pIGF5bGFudGlyaW5nOiBbJHtyb3RXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICAzLiBBeWxhbnRpcmlsZ2FuIHdvcmQgZ2EgUy1ib3ggbmkgcW/igJhsbGFuZzogWyR7c2JveFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDQuIEJpcmluY2hpIGJheXRnYSBSQ09OIChSb3VuZCBDb25zdGFudCAke3Jjb25WYWx1ZS50b1N0cmluZygxNil9KSBuaSBxb+KAmGxsYW5nOlxuICAgICAgICAgIE5hdGlqYTogWyR7dHJhbnNmb3JtZWRXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICA1LiBPbGRpbmdpIGthbGl0bmluZyBiaXJpbmNoaSB3b3JkIGk6IFske2ZpcnN0V29yZFByZXYubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dIG5pIG/igJh6Z2FydGlyaWxnYW4gd29yZCBiaWxhbiBYT1IgcWlsaW5nOiBbJHt0cmFuc2Zvcm1lZFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dLCBuYXRpamFkYTogWyR7eG9yUmVzdWx0Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XSBob3NpbCBib+KAmGxhZGkuIFNv4oCYbmdyYSBxb2xnYW4gd29yZCBsYXIgc2h1IHRhcnpkYSBob3NpbCBxaWxpbmFkaS5cbiAgICAgIGAsXG4gICAgICBoaWdobGlnaHRlZENlbGxzOiBbMCwgMSwgMiwgM10gLy8gSGlnaGxpZ2h0IHRoZSBmaXJzdCB3b3JkIHRoYXQncyBkaXJlY3RseSB0cmFuc2Zvcm1lZFxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gc3RlcHM7XG59O1xuXG4vLyBSZXR1cm4gaW50ZXJtZWRpYXRlIHN0ZXBzIGZvciBlYWNoIHdvcmQgZXhwYW5zaW9uIGZvciB2aXN1YWxpemF0aW9uXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5U2NoZWR1bGVEZXRhaWxlZFN0ZXBzKGtleTogbnVtYmVyW10sIGtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4KSB7XG4gIGNvbnN0IGtleVdvcmRzID0ga2V5Lmxlbmd0aCAvIDQ7XG4gIGNvbnN0IG51bVJvdW5kcyA9IGdldE51bVJvdW5kcyhrZXlMZW5ndGgpO1xuXG4gIC8vIEZsYXR0ZW4gYnl0ZSBhcnJheSAtPiB3b3Jkc1xuICBsZXQgcHJldktleSA9IGtleS5zbGljZSgpO1xuICBsZXQgcm91bmRLZXlzID0gW3ByZXZLZXkuc2xpY2UoKV07XG5cbiAgLy8gRm9yIHJlc3VsdCB2aXN1YWxpemF0aW9uOiBlYWNoIHN0ZXAgZm9yIGVhY2ggcm91bmRcbiAgbGV0IHN0ZXBzUGVyUm91bmQgPSBbXTtcblxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGxldCBzdGVwRGV0YWlscyA9IFtdO1xuICAgIGxldCBuZXdLZXkgPSBwcmV2S2V5LnNsaWNlKCk7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gcHJldktleS5sZW5ndGggLSA0O1xuICAgIGNvbnN0IGxhc3RXb3JkID0gW3ByZXZLZXlbbGFzdEluZGV4XSwgcHJldktleVtsYXN0SW5kZXggKyAxXSwgcHJldktleVtsYXN0SW5kZXggKyAyXSwgcHJldktleVtsYXN0SW5kZXggKyAzXV07XG5cbiAgICAvLyBTdGVwIDE6IFJvdFdvcmRcbiAgICBjb25zdCByb3RXb3JkID0gW2xhc3RXb3JkWzFdLCBsYXN0V29yZFsyXSwgbGFzdFdvcmRbM10sIGxhc3RXb3JkWzBdXTtcbiAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgIHN0ZXA6ICdSb3RXb3JkJywgaW5wdXQ6IGxhc3RXb3JkLnNsaWNlKCksIG91dHB1dDogcm90V29yZC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU3RlcCAyOiBTdWJCeXRlcyAoUy1ib3gpXG4gICAgY29uc3Qgc2JveFdvcmQgPSByb3RXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1N1YkJ5dGVzJywgaW5wdXQ6IHJvdFdvcmQuc2xpY2UoKSwgb3V0cHV0OiBzYm94V29yZC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU3RlcCAzOiBSY29uIHRvIGZpcnN0IGJ5dGVcbiAgICBjb25zdCByY29uVmFsdWUgPSBSQ09OW3JvdW5kXTtcbiAgICBjb25zdCByY29uV29yZCA9IHNib3hXb3JkLnNsaWNlKCk7XG4gICAgcmNvbldvcmRbMF0gXj0gcmNvblZhbHVlO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ0FwcGx5IFJjb24nLCBpbnB1dDogc2JveFdvcmQuc2xpY2UoKSwgcmNvbjogcmNvblZhbHVlLCBvdXRwdXQ6IHJjb25Xb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDQ6IFhPUiB3aXRoIHByZXZpb3VzIChmaXJzdCB3b3JkKVxuICAgIGNvbnN0IHhvclJlc3VsdCA9IFtcbiAgICAgIHByZXZLZXlbMF0gXiByY29uV29yZFswXSxcbiAgICAgIHByZXZLZXlbMV0gXiByY29uV29yZFsxXSxcbiAgICAgIHByZXZLZXlbMl0gXiByY29uV29yZFsyXSxcbiAgICAgIHByZXZLZXlbM10gXiByY29uV29yZFszXSxcbiAgICBdO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1hPUiB3aXRoIHByZXZpb3VzJywgaW5wdXRzOiBbcHJldktleS5zbGljZSgwLDQpLCByY29uV29yZC5zbGljZSgpXSwgb3V0cHV0OiB4b3JSZXN1bHQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFNhdmUgYW5kIHVwZGF0ZSBuZXdLZXlcbiAgICBuZXdLZXlbMF0gPSB4b3JSZXN1bHRbMF07XG4gICAgbmV3S2V5WzFdID0geG9yUmVzdWx0WzFdO1xuICAgIG5ld0tleVsyXSA9IHhvclJlc3VsdFsyXTtcbiAgICBuZXdLZXlbM10gPSB4b3JSZXN1bHRbM107XG4gICAgLy8gT3RoZXIgd29yZHMgKG9ubHkgc2ltcGxlIHhvcilcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleVdvcmRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuICAgICAgbmV3S2V5W29mZnNldF0gPSBuZXdLZXlbb2Zmc2V0IC0gNF0gXiBwcmV2S2V5W29mZnNldF07XG4gICAgICBuZXdLZXlbb2Zmc2V0ICsgMV0gPSBuZXdLZXlbb2Zmc2V0IC0gM10gXiBwcmV2S2V5W29mZnNldCArIDFdO1xuICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gbmV3S2V5W29mZnNldCAtIDJdIF4gcHJldktleVtvZmZzZXQgKyAyXTtcbiAgICAgIG5ld0tleVtvZmZzZXQgKyAzXSA9IG5ld0tleVtvZmZzZXQgLSAxXSBeIHByZXZLZXlbb2Zmc2V0ICsgM107XG4gICAgICBzdGVwRGV0YWlscy5wdXNoKHtcbiAgICAgICAgc3RlcDogJ1hPUiBjaGFpbicsIGlucHV0czogW1xuICAgICAgICAgIG5ld0tleS5zbGljZShvZmZzZXQgLSA0LCBvZmZzZXQpLFxuICAgICAgICAgIHByZXZLZXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0KVxuICAgICAgICBdLCBvdXRwdXQ6IG5ld0tleS5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLCB3b3JkSW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGVwc1BlclJvdW5kLnB1c2goeyByb3VuZCwgc3RlcERldGFpbHMsIHJvdW5kS2V5OiBuZXdLZXkuc2xpY2UoKSB9KTtcbiAgICBwcmV2S2V5ID0gbmV3S2V5LnNsaWNlKCk7XG4gICAgcm91bmRLZXlzLnB1c2gocHJldktleSk7XG4gIH1cbiAgcmV0dXJuIHN0ZXBzUGVyUm91bmQ7XG59XG5cbi8vIFJlYWwgQUVTIGVuY3J5cHRpb24gdXNpbmcgQ3J5cHRvSlMgZm9yIHZlcmlmaWNhdGlvblxuZXhwb3J0IGNvbnN0IHJlYWxBZXNFbmNyeXB0ID0gKFxuICBwbGFpbnRleHQ6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgb3V0cHV0Rm9ybWF0OiBPdXRwdXRGb3JtYXQgPSBPdXRwdXRGb3JtYXQuQkFTRTY0LFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4LFxuICBpdlN0cmluZz86IHN0cmluZ1xuKTogeyBjaXBoZXJ0ZXh0OiBzdHJpbmcsIGl2Pzogc3RyaW5nLCBmb3JtYXRzOiB7IGJhc2U2NDogc3RyaW5nLCBoZXg6IHN0cmluZywgYmluYXJ5OiBzdHJpbmcgfSB9ID0+IHtcbiAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUga2V5IGlzIHNob3J0ZXIgdGhhbiByZXF1aXJlZCBieSBrZXlMZW5ndGhcbiAgY29uc3QgY2xlYW5LZXkgPSBrZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgbGV0IGtleUhleCA9IGNsZWFuS2V5Lmxlbmd0aCAlIDIgPT09IDEgPyBjbGVhbktleSArICcwJyA6IGNsZWFuS2V5O1xuICBcbiAgLy8gRW5zdXJlIGtleSBpcyBvZiBjb3JyZWN0IGxlbmd0aCBmb3IgdGhlIHNlbGVjdGVkIGtleSBsZW5ndGhcbiAgY29uc3QgcmVxdWlyZWRIZXhDaGFycyA9IGtleUxlbmd0aCAvIDQ7IC8vIEVhY2ggaGV4IGNoYXIgaXMgNCBiaXRzXG4gIGlmIChrZXlIZXgubGVuZ3RoIDwgcmVxdWlyZWRIZXhDaGFycykge1xuICAgIC8vIFBhZCBrZXkgaWYgdG9vIHNob3J0XG4gICAga2V5SGV4ID0ga2V5SGV4LnBhZEVuZChyZXF1aXJlZEhleENoYXJzLCAnMCcpO1xuICB9IGVsc2UgaWYgKGtleUhleC5sZW5ndGggPiByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgLy8gVHJ1bmNhdGUga2V5IGlmIHRvbyBsb25nXG4gICAga2V5SGV4ID0ga2V5SGV4LnN1YnN0cmluZygwLCByZXF1aXJlZEhleENoYXJzKTtcbiAgfVxuICBcbiAgY29uc3Qga2V5V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShrZXlIZXgpO1xuICBcbiAgbGV0IHBhZGRpbmdPcHRpb246IGFueTtcbiAgc3dpdGNoIChwYWRkaW5nKSB7XG4gICAgY2FzZSBQYWRkaW5nVHlwZS5BTlNJX1g5MjM6XG4gICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuQW5zaVg5MjMgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUGFkZGluZ1R5cGUuTk9ORTpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYWRkaW5nT3B0aW9uID0ge307IC8vIGRlZmF1bHQgaXMgUEtDUzdcbiAgfVxuICBcbiAgbGV0IG1vZGVPcHRpb246IGFueTtcbiAgbGV0IGl2OiBhbnk7XG4gIFxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgaWYgKGl2U3RyaW5nKSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuICAgICAgfVxuICAgICAgbW9kZU9wdGlvbiA9IHsgXG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgICBpdjogaXYsXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgaWYgKGl2U3RyaW5nKSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuICAgICAgfVxuICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DVFIsXG4gICAgICAgIGl2OiBpdixcbiAgICAgICAgY291bnRlcjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzAsIDAsIDAsIDBdLCAxNiksXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBFQ0JcbiAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuRUNCLFxuICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGNvbnN0IGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KHBsYWludGV4dCwga2V5V29yZEFycmF5LCBtb2RlT3B0aW9uKTtcbiAgXG4gIC8vIEdldCBhbGwgb3V0cHV0IGZvcm1hdHNcbiAgY29uc3QgYmFzZTY0T3V0cHV0ID0gZW5jcnlwdGVkLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICBjaXBoZXJ0ZXh0OiBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NE91dHB1dClcbiAgfSk7XG4gIGNvbnN0IGhleE91dHB1dCA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG4gIFxuICAvLyBGb3IgYmluYXJ5LCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGhleCB0byBiaW5hcnlcbiAgY29uc3QgaGV4Qnl0ZXMgPSBoZXhPdXRwdXQubWF0Y2goLy57Mn0vZykhLm1hcChoZXggPT4gcGFyc2VJbnQoaGV4LCAxNikpO1xuICBjb25zdCBiaW5hcnlPdXRwdXQgPSBieXRlc1RvQmluYXJ5KGhleEJ5dGVzLCAnJyk7XG4gIFxuICAvLyBTZWxlY3QgdGhlIHJlcXVlc3RlZCBmb3JtYXQgZm9yIHByaW1hcnkgb3V0cHV0XG4gIGxldCBwcmltYXJ5T3V0cHV0OiBzdHJpbmc7XG4gIHN3aXRjaCAob3V0cHV0Rm9ybWF0KSB7XG4gICAgY2FzZSBPdXRwdXRGb3JtYXQuSEVYOlxuICAgICAgcHJpbWFyeU91dHB1dCA9IGhleE91dHB1dDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkJJTkFSWTpcbiAgICAgIHByaW1hcnlPdXRwdXQgPSBiaW5hcnlPdXRwdXQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBCQVNFNjRcbiAgICAgIHByaW1hcnlPdXRwdXQgPSBiYXNlNjRPdXRwdXQ7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgcmV0dXJuIHsgXG4gICAgY2lwaGVydGV4dDogcHJpbWFyeU91dHB1dCxcbiAgICBpdjogaXYgPyBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeShpdikgOiB1bmRlZmluZWQsXG4gICAgZm9ybWF0czoge1xuICAgICAgYmFzZTY0OiBiYXNlNjRPdXRwdXQsXG4gICAgICBoZXg6IGhleE91dHB1dCxcbiAgICAgIGJpbmFyeTogYmluYXJ5T3V0cHV0XG4gICAgfVxuICB9O1xufTtcblxuLy8gUmVhbCBBRVMgZGVjcnlwdGlvbiB1c2luZyBDcnlwdG9KU1xuZXhwb3J0IGNvbnN0IHJlYWxBZXNEZWNyeXB0ID0gKFxuICBjaXBoZXJ0ZXh0OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcsXG4gIGlucHV0Rm9ybWF0OiBPdXRwdXRGb3JtYXQgPSBPdXRwdXRGb3JtYXQuQkFTRTY0LFxuICBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4LFxuICBpdlN0cmluZz86IHN0cmluZ1xuKTogeyBwbGFpbnRleHQ6IHN0cmluZywgZXJyb3I/OiBzdHJpbmcgfSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUga2V5IGlzIHNob3J0ZXIgdGhhbiByZXF1aXJlZCBieSBrZXlMZW5ndGhcbiAgICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGxldCBrZXlIZXggPSBjbGVhbktleS5sZW5ndGggJSAyID09PSAxID8gY2xlYW5LZXkgKyAnMCcgOiBjbGVhbktleTtcbiAgICBcbiAgICAvLyBFbnN1cmUga2V5IGlzIG9mIGNvcnJlY3QgbGVuZ3RoIGZvciB0aGUgc2VsZWN0ZWQga2V5IGxlbmd0aFxuICAgIGNvbnN0IHJlcXVpcmVkSGV4Q2hhcnMgPSBrZXlMZW5ndGggLyA0OyAvLyBFYWNoIGhleCBjaGFyIGlzIDQgYml0c1xuICAgIGlmIChrZXlIZXgubGVuZ3RoIDwgcmVxdWlyZWRIZXhDaGFycykge1xuICAgICAgLy8gUGFkIGtleSBpZiB0b28gc2hvcnRcbiAgICAgIGtleUhleCA9IGtleUhleC5wYWRFbmQocmVxdWlyZWRIZXhDaGFycywgJzAnKTtcbiAgICB9IGVsc2UgaWYgKGtleUhleC5sZW5ndGggPiByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgICAvLyBUcnVuY2F0ZSBrZXkgaWYgdG9vIGxvbmdcbiAgICAgIGtleUhleCA9IGtleUhleC5zdWJzdHJpbmcoMCwgcmVxdWlyZWRIZXhDaGFycyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGtleVdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2Uoa2V5SGV4KTtcbiAgICBcbiAgICAvLyBQYXJzZSBjaXBoZXJ0ZXh0IGJhc2VkIG9uIGlucHV0IGZvcm1hdFxuICAgIGxldCBjaXBoZXJ0ZXh0V29yZEFycmF5OiBhbnk7XG4gICAgc3dpdGNoIChpbnB1dEZvcm1hdCkge1xuICAgICAgY2FzZSBPdXRwdXRGb3JtYXQuSEVYOlxuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShjaXBoZXJ0ZXh0LnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT3V0cHV0Rm9ybWF0LkJJTkFSWTpcbiAgICAgICAgLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nIHRvIGhleCBmaXJzdFxuICAgICAgICBjb25zdCBoZXhGcm9tQmluYXJ5ID0gY2lwaGVydGV4dC5yZXBsYWNlKC9cXHMvZywgJycpLm1hdGNoKC8uezh9L2cpPy5tYXAoYmluID0+IHBhcnNlSW50KGJpbiwgMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpIHx8ICcnO1xuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhGcm9tQmluYXJ5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBCQVNFNjRcbiAgICAgICAgY2lwaGVydGV4dFdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoY2lwaGVydGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcGFkZGluZ09wdGlvbjogYW55O1xuICAgIHN3aXRjaCAocGFkZGluZykge1xuICAgICAgY2FzZSBQYWRkaW5nVHlwZS5BTlNJX1g5MjM6XG4gICAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5BbnNpWDkyMyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFkZGluZ1R5cGUuTk9ORTpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBhZGRpbmdPcHRpb24gPSB7fTsgLy8gZGVmYXVsdCBpcyBQS0NTN1xuICAgIH1cbiAgICBcbiAgICBsZXQgbW9kZU9wdGlvbjogYW55O1xuICAgIGxldCBpdjogYW55O1xuICAgIFxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgICAgaWYgKCFpdlN0cmluZykge1xuICAgICAgICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiAnQ0JDIHJlamltaSB1Y2h1biBJViBrZXJhaycgfTtcbiAgICAgICAgfVxuICAgICAgICBpdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaXZTdHJpbmcucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIG1vZGVPcHRpb24gPSB7IFxuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgICAgaWYgKCFpdlN0cmluZykge1xuICAgICAgICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiAnQ1RSIHJlamltaSB1Y2h1biBJViAoTm9uY2UpIGtlcmFrJyB9O1xuICAgICAgICB9XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNUUixcbiAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgY291bnRlcjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzAsIDAsIDAsIDBdLCAxNiksXG4gICAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuRUNCLFxuICAgICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRlY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KFxuICAgICAgeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5IH0gYXMgYW55LFxuICAgICAga2V5V29yZEFycmF5LFxuICAgICAgbW9kZU9wdGlvblxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcGxhaW50ZXh0ID0gZGVjcnlwdGVkLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICBcbiAgICBpZiAoIXBsYWludGV4dCkge1xuICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdEZXNoaWZybGFzaCBtdXZhZmZhcWl5YXRzaXouIEthbGl0IHlva2kgc2hpZnJsYW5nYW4gbWF0biBub3RvXFwnZ1xcJ3JpLicgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgcGxhaW50ZXh0IH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRGVzaGlmcmxhc2hkYSB4YXRvbGlrIHl1eiBiZXJkaScgfTtcbiAgfVxufTtcblxuLy8gVGVzdCBzcGVjaWZpYyBjYXNlIGZvciBcIlNhbG9tLCBBRVMhXCIgd2l0aCBrZXkgXCJjYyAwZSBjMSA3MCAyNCAyNCAwMSA4ZCA0ZSBmZCA1ZSBmMyA4ZCAxNSAyZiA2M1wiXG5leHBvcnQgY29uc3QgdGVzdFNwZWNpZmljQ2FzZSA9ICgpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBwbGFpbnRleHQgPSBcIlNhbG9tLCBBRVMhXCI7XG4gIGNvbnN0IGtleSA9IFwiY2MgMGUgYzEgNzAgMjQgMjQgMDEgOGQgNGUgZmQgNWUgZjMgOGQgMTUgMmYgNjNcIjtcbiAgXG4gIC8vIENyZWF0ZSBrZXkgYW5kIGlucHV0IGFzIGJ5dGUgYXJyYXlzXG4gIGNvbnN0IGtleUJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAga2V5Qnl0ZXMucHVzaChwYXJzZUludChrZXkuc3Vic3RyKGksIDIpLCAxNikpO1xuICB9XG4gIFxuICAvLyBVc2Ugb3VyIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IHsgZmluYWxDaXBoZXJ0ZXh0IH0gPSBnZXRBZXNTdGVwcyhwbGFpbnRleHQsIGtleUJ5dGVzLCBBZXNNb2RlLkVDQiwgUGFkZGluZ1R5cGUuUEtDUzcpO1xuICBcbiAgLy8gVXNlIENyeXB0b0pTIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IGNyeXB0b1Jlc3VsdCA9IHJlYWxBZXNFbmNyeXB0KHBsYWludGV4dCwga2V5LCBBZXNNb2RlLkVDQiwgUGFkZGluZ1R5cGUuUEtDUzcsIE91dHB1dEZvcm1hdC5IRVgpO1xuICBcbiAgcmV0dXJuIGBcbiAgICBCaXpuaW5nIGltcGxlbWVudGF0c2l5YW1peiAoSEVYKTogJHtmaW5hbENpcGhlcnRleHQuaGV4fVxuICAgIENyeXB0b0pTIGltcGxlbWVudGF0c2l5YXNpIChIRVgpOiAke2NyeXB0b1Jlc3VsdC5mb3JtYXRzLmhleH1cbiAgICBLdXRpbGF5b3RnYW4gbmF0aWphOiAzMDQ4NEI4RjhDNkJCMDlDQTNGOTRDNkY4NEYwMzA1RVxuICBgO1xufTtcbiJdLCJuYW1lcyI6WyJDcnlwdG9KUyIsIkFlc01vZGUiLCJQYWRkaW5nVHlwZSIsIk91dHB1dEZvcm1hdCIsIktleUxlbmd0aCIsImdldE51bVJvdW5kcyIsImtleUxlbmd0aCIsImdldEtleUJ5dGVMZW5ndGgiLCJTQk9YIiwiUkNPTiIsIkdBTE9JU19NVUxfMiIsIkdBTE9JU19NVUxfMyIsInRleHRUb1N0YXRlIiwidGV4dCIsIndvcmRBcnJheSIsImVuYyIsIlV0ZjgiLCJwYXJzZSIsImJ5dGVzIiwic2lnQnl0ZXMiLCJpIiwid29yZHMiLCJsZW5ndGgiLCJ3b3JkIiwiYnl0ZXNJblRoaXNXb3JkIiwiTWF0aCIsIm1pbiIsInB1c2giLCJibG9jayIsInNsaWNlIiwia2V5VG9CeXRlcyIsImtleSIsInJlcXVpcmVkQnl0ZXMiLCJyZXF1aXJlZEhleExlbmd0aCIsImNsZWFuS2V5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidGVzdCIsInBhcnNlSW50Iiwic3Vic3RyIiwiZ2VuZXJhdGVSYW5kb21LZXkiLCJrZXlCeXRlcyIsImZsb29yIiwicmFuZG9tIiwiYnl0ZXNUb0hleCIsImpvaW5DaGFyIiwibWFwIiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiYnl0ZXNUb0JpbmFyeSIsInN1YkJ5dGVzIiwic3RhdGUiLCJzaGlmdFJvd3MiLCJyZXN1bHQiLCJpZHgiLCJyb3ciLCJjb2wiLCJyb3dWYWx1ZXMiLCJzaGlmdGVkIiwiY29uY2F0IiwibWl4Q29sdW1ucyIsInMwIiwiczEiLCJzMiIsInMzIiwiYWRkUm91bmRLZXkiLCJyb3VuZEtleSIsImtleUV4cGFuc2lvbiIsIm5vcm1hbGl6ZWRLZXkiLCJrZXlXb3JkcyIsIm51bVJvdW5kcyIsInJvdW5kS2V5cyIsInJvdW5kIiwicHJldktleSIsIm5ld0tleSIsImxhc3RJbmRleCIsImxhc3RXb3JkIiwicm90V29yZCIsInN1YldvcmQiLCJvZmZzZXQiLCJ0ZW1wV29yZCIsInN1YlRlbXBXb3JkIiwiYWVzUm91bmQiLCJpc0xhc3RSb3VuZCIsIm5ld1N0YXRlIiwiYWVzRW5jcnlwdCIsInBsYWludGV4dCIsImN1cnJlbnRTdGF0ZSIsInRleHRUb0Jsb2NrcyIsInBhZGRpbmciLCJwYWRkZWRCeXRlcyIsImFwcGx5UEtDUzdQYWRkaW5nIiwiYXBwbHlBbnNpWDkyM1BhZGRpbmciLCJibG9ja3MiLCJkYXRhIiwicGFkZGVkIiwicGFkZGluZ0xlbmd0aCIsInJlbW92ZUFuc2lYOTIzUGFkZGluZyIsImdlbmVyYXRlSVYiLCJpdiIsImdldEFlc1N0ZXBzRm9yQmxvY2siLCJtb2RlIiwiYmxvY2tJbmRleCIsInByZXZpb3VzQ2lwaGVydGV4dEJsb2NrIiwic3RlcHMiLCJwbGFpbnRleHRCeXRlcyIsImRlc2NyaXB0aW9uIiwiZXhwbGFuYXRpb24iLCJpbml0aWFsU3RhdGUiLCJhY3RpdmVJbmRpY2VzIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInByZXZpb3VzU3RhdGUiLCJmaW5hbFN0YXRlIiwiY291bnRlckJsb2NrIiwiY291bnRlclZhbHVlIiwic3VtIiwiYWZ0ZXJJbml0aWFsUm91bmQiLCJhZnRlclN1YkJ5dGVzIiwiYWZ0ZXJTaGlmdFJvd3MiLCJwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkiLCJhZnRlck1peENvbHVtbnMiLCJnZXRBZXNTdGVwcyIsInByb3ZpZGVkSXYiLCJ1bmRlZmluZWQiLCJhbGxCbG9ja3MiLCJpdkRlc2NyaXB0aW9uIiwiaXZFeHBsYW5hdGlvbiIsImNvdW50ZXIiLCJjb21iaW5lZEZpbmFsU3RhdGVzIiwiYmxvY2tSZXN1bHQiLCJmaW5hbFN0YXRlVG9Vc2UiLCJmaW5hbFdvcmRBcnJheSIsImxpYiIsIldvcmRBcnJheSIsImNyZWF0ZSIsIlVpbnQ4QXJyYXkiLCJmaW5hbENpcGhlcnRleHRCYXNlNjQiLCJCYXNlNjQiLCJzdHJpbmdpZnkiLCJmaW5hbENpcGhlcnRleHRIZXgiLCJIZXgiLCJmaW5hbENpcGhlcnRleHRCaW5hcnkiLCJmaW5hbENpcGhlcnRleHQiLCJiYXNlNjQiLCJoZXgiLCJiaW5hcnkiLCJnZXRLZXlFeHBhbnNpb25TdGVwcyIsImN1cnJlbnRLZXkiLCJzYm94V29yZCIsInJjb25WYWx1ZSIsInRyYW5zZm9ybWVkV29yZCIsImZpcnN0V29yZFByZXYiLCJ4b3JSZXN1bHQiLCJpbmRleCIsImIiLCJoaWdobGlnaHRlZENlbGxzIiwiZ2V0S2V5U2NoZWR1bGVEZXRhaWxlZFN0ZXBzIiwic3RlcHNQZXJSb3VuZCIsInN0ZXBEZXRhaWxzIiwic3RlcCIsImlucHV0Iiwib3V0cHV0IiwicmNvbldvcmQiLCJyY29uIiwiaW5wdXRzIiwid29yZEluZGV4IiwicmVhbEFlc0VuY3J5cHQiLCJvdXRwdXRGb3JtYXQiLCJpdlN0cmluZyIsImtleUhleCIsInJlcXVpcmVkSGV4Q2hhcnMiLCJwYWRFbmQiLCJzdWJzdHJpbmciLCJrZXlXb3JkQXJyYXkiLCJwYWRkaW5nT3B0aW9uIiwicGFkIiwiQW5zaVg5MjMiLCJOb1BhZGRpbmciLCJtb2RlT3B0aW9uIiwiQ0JDIiwiQ1RSIiwiRUNCIiwiZW5jcnlwdGVkIiwiQUVTIiwiZW5jcnlwdCIsImJhc2U2NE91dHB1dCIsImNpcGhlclBhcmFtcyIsIkNpcGhlclBhcmFtcyIsImNpcGhlcnRleHQiLCJoZXhPdXRwdXQiLCJmb3JtYXQiLCJoZXhCeXRlcyIsIm1hdGNoIiwiYmluYXJ5T3V0cHV0IiwicHJpbWFyeU91dHB1dCIsImZvcm1hdHMiLCJyZWFsQWVzRGVjcnlwdCIsImlucHV0Rm9ybWF0IiwiY2lwaGVydGV4dFdvcmRBcnJheSIsImhleEZyb21CaW5hcnkiLCJiaW4iLCJlcnJvciIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJtZXNzYWdlIiwidGVzdFNwZWNpZmljQ2FzZSIsImNyeXB0b1Jlc3VsdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/aes.ts\n"));

/***/ })

});