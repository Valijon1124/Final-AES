"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/aes.ts":
/*!**************************!*\
  !*** ./src/utils/aes.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AesMode: () => (/* binding */ AesMode),\n/* harmony export */   GALOIS_MUL_2: () => (/* binding */ GALOIS_MUL_2),\n/* harmony export */   GALOIS_MUL_3: () => (/* binding */ GALOIS_MUL_3),\n/* harmony export */   KeyLength: () => (/* binding */ KeyLength),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   PaddingType: () => (/* binding */ PaddingType),\n/* harmony export */   RCON: () => (/* binding */ RCON),\n/* harmony export */   SBOX: () => (/* binding */ SBOX),\n/* harmony export */   addRoundKey: () => (/* binding */ addRoundKey),\n/* harmony export */   aesEncrypt: () => (/* binding */ aesEncrypt),\n/* harmony export */   aesRound: () => (/* binding */ aesRound),\n/* harmony export */   applyAnsiX923Padding: () => (/* binding */ applyAnsiX923Padding),\n/* harmony export */   applyPKCS7Padding: () => (/* binding */ applyPKCS7Padding),\n/* harmony export */   bytesToBinary: () => (/* binding */ bytesToBinary),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   generateIV: () => (/* binding */ generateIV),\n/* harmony export */   generateRandomKey: () => (/* binding */ generateRandomKey),\n/* harmony export */   getAesSteps: () => (/* binding */ getAesSteps),\n/* harmony export */   getAesStepsForBlock: () => (/* binding */ getAesStepsForBlock),\n/* harmony export */   getKeyExpansionSteps: () => (/* binding */ getKeyExpansionSteps),\n/* harmony export */   getKeyScheduleDetailedSteps: () => (/* binding */ getKeyScheduleDetailedSteps),\n/* harmony export */   keyExpansion: () => (/* binding */ keyExpansion),\n/* harmony export */   keyToBytes: () => (/* binding */ keyToBytes),\n/* harmony export */   mixColumns: () => (/* binding */ mixColumns),\n/* harmony export */   realAesDecrypt: () => (/* binding */ realAesDecrypt),\n/* harmony export */   realAesEncrypt: () => (/* binding */ realAesEncrypt),\n/* harmony export */   removeAnsiX923Padding: () => (/* binding */ removeAnsiX923Padding),\n/* harmony export */   shiftRows: () => (/* binding */ shiftRows),\n/* harmony export */   subBytes: () => (/* binding */ subBytes),\n/* harmony export */   testSpecificCase: () => (/* binding */ testSpecificCase),\n/* harmony export */   textToBlocks: () => (/* binding */ textToBlocks),\n/* harmony export */   textToState: () => (/* binding */ textToState)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"(pages-dir-browser)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// AES mode enum\nvar AesMode = /*#__PURE__*/ function(AesMode) {\n    AesMode[\"ECB\"] = \"ECB\";\n    AesMode[\"CBC\"] = \"CBC\";\n    AesMode[\"CTR\"] = \"CTR\";\n    return AesMode;\n}({});\n// Padding enum\nvar PaddingType = /*#__PURE__*/ function(PaddingType) {\n    PaddingType[\"PKCS7\"] = \"PKCS7\";\n    PaddingType[\"ANSI_X923\"] = \"ANSI X.923\";\n    PaddingType[\"NONE\"] = \"None\";\n    return PaddingType;\n}({});\n// Output format enum\nvar OutputFormat = /*#__PURE__*/ function(OutputFormat) {\n    OutputFormat[\"BASE64\"] = \"Base64\";\n    OutputFormat[\"HEX\"] = \"Hex\";\n    OutputFormat[\"BINARY\"] = \"Binary\";\n    return OutputFormat;\n}({});\n// Key length enum\nvar KeyLength = /*#__PURE__*/ function(KeyLength) {\n    KeyLength[KeyLength[\"AES_128\"] = 128] = \"AES_128\";\n    KeyLength[KeyLength[\"AES_192\"] = 192] = \"AES_192\";\n    KeyLength[KeyLength[\"AES_256\"] = 256] = \"AES_256\";\n    return KeyLength;\n}({});\nconst getNumRounds = (keyLength)=>keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\nconst getKeyByteLength = (keyLength)=>keyLength / 8;\n// AES S-Box (Standard Rijndael S-box)\nconst SBOX = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\n// AES Rcon (Round Constants)\nconst RCON = [\n    0x00,\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a\n];\n// Used in MixColumns\nconst GALOIS_MUL_2 = [\n    0x00,\n    0x02,\n    0x04,\n    0x06,\n    0x08,\n    0x0a,\n    0x0c,\n    0x0e,\n    0x10,\n    0x12,\n    0x14,\n    0x16,\n    0x18,\n    0x1a,\n    0x1c,\n    0x1e,\n    0x20,\n    0x22,\n    0x24,\n    0x26,\n    0x28,\n    0x2a,\n    0x2c,\n    0x2e,\n    0x30,\n    0x32,\n    0x34,\n    0x36,\n    0x38,\n    0x3a,\n    0x3c,\n    0x3e,\n    0x40,\n    0x42,\n    0x44,\n    0x46,\n    0x48,\n    0x4a,\n    0x4c,\n    0x4e,\n    0x50,\n    0x52,\n    0x54,\n    0x56,\n    0x58,\n    0x5a,\n    0x5c,\n    0x5e,\n    0x60,\n    0x62,\n    0x64,\n    0x66,\n    0x68,\n    0x6a,\n    0x6c,\n    0x6e,\n    0x70,\n    0x72,\n    0x74,\n    0x76,\n    0x78,\n    0x7a,\n    0x7c,\n    0x7e,\n    0x80,\n    0x82,\n    0x84,\n    0x86,\n    0x88,\n    0x8a,\n    0x8c,\n    0x8e,\n    0x90,\n    0x92,\n    0x94,\n    0x96,\n    0x98,\n    0x9a,\n    0x9c,\n    0x9e,\n    0xa0,\n    0xa2,\n    0xa4,\n    0xa6,\n    0xa8,\n    0xaa,\n    0xac,\n    0xae,\n    0xb0,\n    0xb2,\n    0xb4,\n    0xb6,\n    0xb8,\n    0xba,\n    0xbc,\n    0xbe,\n    0xc0,\n    0xc2,\n    0xc4,\n    0xc6,\n    0xc8,\n    0xca,\n    0xcc,\n    0xce,\n    0xd0,\n    0xd2,\n    0xd4,\n    0xd6,\n    0xd8,\n    0xda,\n    0xdc,\n    0xde,\n    0xe0,\n    0xe2,\n    0xe4,\n    0xe6,\n    0xe8,\n    0xea,\n    0xec,\n    0xee,\n    0xf0,\n    0xf2,\n    0xf4,\n    0xf6,\n    0xf8,\n    0xfa,\n    0xfc,\n    0xfe,\n    0x1b,\n    0x19,\n    0x1f,\n    0x1d,\n    0x13,\n    0x11,\n    0x17,\n    0x15,\n    0x0b,\n    0x09,\n    0x0f,\n    0x0d,\n    0x03,\n    0x01,\n    0x07,\n    0x05,\n    0x3b,\n    0x39,\n    0x3f,\n    0x3d,\n    0x33,\n    0x31,\n    0x37,\n    0x35,\n    0x2b,\n    0x29,\n    0x2f,\n    0x2d,\n    0x23,\n    0x21,\n    0x27,\n    0x25,\n    0x5b,\n    0x59,\n    0x5f,\n    0x5d,\n    0x53,\n    0x51,\n    0x57,\n    0x55,\n    0x4b,\n    0x49,\n    0x4f,\n    0x4d,\n    0x43,\n    0x41,\n    0x47,\n    0x45,\n    0x7b,\n    0x79,\n    0x7f,\n    0x7d,\n    0x73,\n    0x71,\n    0x77,\n    0x75,\n    0x6b,\n    0x69,\n    0x6f,\n    0x6d,\n    0x63,\n    0x61,\n    0x67,\n    0x65,\n    0x9b,\n    0x99,\n    0x9f,\n    0x9d,\n    0x93,\n    0x91,\n    0x97,\n    0x95,\n    0x8b,\n    0x89,\n    0x8f,\n    0x8d,\n    0x83,\n    0x81,\n    0x87,\n    0x85,\n    0xbb,\n    0xb9,\n    0xbf,\n    0xbd,\n    0xb3,\n    0xb1,\n    0xb7,\n    0xb5,\n    0xab,\n    0xa9,\n    0xaf,\n    0xad,\n    0xa3,\n    0xa1,\n    0xa7,\n    0xa5,\n    0xdb,\n    0xd9,\n    0xdf,\n    0xdd,\n    0xd3,\n    0xd1,\n    0xd7,\n    0xd5,\n    0xcb,\n    0xc9,\n    0xcf,\n    0xcd,\n    0xc3,\n    0xc1,\n    0xc7,\n    0xc5,\n    0xfb,\n    0xf9,\n    0xff,\n    0xfd,\n    0xf3,\n    0xf1,\n    0xf7,\n    0xf5,\n    0xeb,\n    0xe9,\n    0xef,\n    0xed,\n    0xe3,\n    0xe1,\n    0xe7,\n    0xe5\n];\nconst GALOIS_MUL_3 = [\n    0x00,\n    0x03,\n    0x06,\n    0x05,\n    0x0c,\n    0x0f,\n    0x0a,\n    0x09,\n    0x18,\n    0x1b,\n    0x1e,\n    0x1d,\n    0x14,\n    0x17,\n    0x12,\n    0x11,\n    0x30,\n    0x33,\n    0x36,\n    0x35,\n    0x3c,\n    0x3f,\n    0x3a,\n    0x39,\n    0x28,\n    0x2b,\n    0x2e,\n    0x2d,\n    0x24,\n    0x27,\n    0x22,\n    0x21,\n    0x60,\n    0x63,\n    0x66,\n    0x65,\n    0x6c,\n    0x6f,\n    0x6a,\n    0x69,\n    0x78,\n    0x7b,\n    0x7e,\n    0x7d,\n    0x74,\n    0x77,\n    0x72,\n    0x71,\n    0x50,\n    0x53,\n    0x56,\n    0x55,\n    0x5c,\n    0x5f,\n    0x5a,\n    0x59,\n    0x48,\n    0x4b,\n    0x4e,\n    0x4d,\n    0x44,\n    0x47,\n    0x42,\n    0x41,\n    0xc0,\n    0xc3,\n    0xc6,\n    0xc5,\n    0xcc,\n    0xcf,\n    0xca,\n    0xc9,\n    0xd8,\n    0xdb,\n    0xde,\n    0xdd,\n    0xd4,\n    0xd7,\n    0xd2,\n    0xd1,\n    0xf0,\n    0xf3,\n    0xf6,\n    0xf5,\n    0xfc,\n    0xff,\n    0xfa,\n    0xf9,\n    0xe8,\n    0xeb,\n    0xee,\n    0xed,\n    0xe4,\n    0xe7,\n    0xe2,\n    0xe1,\n    0xa0,\n    0xa3,\n    0xa6,\n    0xa5,\n    0xac,\n    0xaf,\n    0xaa,\n    0xa9,\n    0xb8,\n    0xbb,\n    0xbe,\n    0xbd,\n    0xb4,\n    0xb7,\n    0xb2,\n    0xb1,\n    0x90,\n    0x93,\n    0x96,\n    0x95,\n    0x9c,\n    0x9f,\n    0x9a,\n    0x99,\n    0x88,\n    0x8b,\n    0x8e,\n    0x8d,\n    0x84,\n    0x87,\n    0x82,\n    0x81,\n    0x9b,\n    0x98,\n    0x9d,\n    0x9e,\n    0x97,\n    0x94,\n    0x91,\n    0x92,\n    0x83,\n    0x80,\n    0x85,\n    0x86,\n    0x8f,\n    0x8c,\n    0x89,\n    0x8a,\n    0xab,\n    0xa8,\n    0xad,\n    0xae,\n    0xa7,\n    0xa4,\n    0xa1,\n    0xa2,\n    0xb3,\n    0xb0,\n    0xb5,\n    0xb6,\n    0xbf,\n    0xbc,\n    0xb9,\n    0xba,\n    0xfb,\n    0xf8,\n    0xfd,\n    0xfe,\n    0xf7,\n    0xf4,\n    0xf1,\n    0xf2,\n    0xe3,\n    0xe0,\n    0xe5,\n    0xe6,\n    0xef,\n    0xec,\n    0xe9,\n    0xea,\n    0xcb,\n    0xc8,\n    0xcd,\n    0xce,\n    0xc7,\n    0xc4,\n    0xc1,\n    0xc2,\n    0xd3,\n    0xd0,\n    0xd5,\n    0xd6,\n    0xdf,\n    0xdc,\n    0xd9,\n    0xda,\n    0x5b,\n    0x58,\n    0x5d,\n    0x5e,\n    0x57,\n    0x54,\n    0x51,\n    0x52,\n    0x43,\n    0x40,\n    0x45,\n    0x46,\n    0x4f,\n    0x4c,\n    0x49,\n    0x4a,\n    0x6b,\n    0x68,\n    0x6d,\n    0x6e,\n    0x67,\n    0x64,\n    0x61,\n    0x62,\n    0x73,\n    0x70,\n    0x75,\n    0x76,\n    0x7f,\n    0x7c,\n    0x79,\n    0x7a,\n    0x3b,\n    0x38,\n    0x3d,\n    0x3e,\n    0x37,\n    0x34,\n    0x31,\n    0x32,\n    0x23,\n    0x20,\n    0x25,\n    0x26,\n    0x2f,\n    0x2c,\n    0x29,\n    0x2a,\n    0x0b,\n    0x08,\n    0x0d,\n    0x0e,\n    0x07,\n    0x04,\n    0x01,\n    0x02,\n    0x13,\n    0x10,\n    0x15,\n    0x16,\n    0x1f,\n    0x1c,\n    0x19,\n    0x1a\n];\n// Convert text to a state matrix - returns array of bytes\nconst textToState = (text)=>{\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Pad to 16 bytes if needed\n    while(bytes.length < 16){\n        bytes.push(0);\n    }\n    const block = bytes.slice(0, 16);\n    // AES state is column-major: state[r + 4*c] = input[4*c + r]\n    return block;\n};\n// Convert a key string to bytes using selected key length\nconst keyToBytes = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const requiredHexLength = requiredBytes * 2;\n    // Remove spaces and convert to lowercase\n    const cleanKey = key.replace(/\\s/g, '').toLowerCase();\n    // If it's a hex string, convert it\n    if (/^[0-9a-f]+$/.test(cleanKey)) {\n        const bytes = [];\n        for(let i = 0; i < Math.min(cleanKey.length, requiredHexLength); i += 2){\n            bytes.push(parseInt(cleanKey.substr(i, 2), 16));\n        }\n        while(bytes.length < requiredBytes){\n            bytes.push(0);\n        }\n        return bytes.slice(0, requiredBytes);\n    }\n    // Otherwise, treat as UTF-8 text and normalize to selected key size\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(key);\n    const bytes = [];\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    while(bytes.length < requiredBytes){\n        bytes.push(0);\n    }\n    return bytes.slice(0, requiredBytes);\n};\n// Generate a random key as byte array based on key length\nconst generateRandomKey = function() {\n    let keyLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;\n    const keyBytes = getKeyByteLength(keyLength);\n    const bytes = [];\n    for(let i = 0; i < keyBytes; i++){\n        bytes.push(Math.floor(Math.random() * 256));\n    }\n    return bytes;\n};\n// Format bytes as hex\nconst bytesToHex = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(16).padStart(2, '0')).join(joinChar);\n};\n// Format bytes as binary\nconst bytesToBinary = function(bytes) {\n    let joinChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ' ';\n    return bytes.map((byte)=>byte.toString(2).padStart(8, '0')).join(joinChar);\n};\n// SubBytes operation - substitute each byte with its S-box value\nconst subBytes = (state)=>{\n    return state.map((byte)=>SBOX[byte]);\n};\n// ShiftRows operation - rotate rows of the state matrix\nconst shiftRows = (state)=>{\n    const result = [\n        ...state\n    ];\n    // Column-major state index helper: idx(row, col) = row + 4*col\n    const idx = (row, col)=>row + 4 * col;\n    for(let row = 1; row < 4; row++){\n        const rowValues = [\n            state[idx(row, 0)],\n            state[idx(row, 1)],\n            state[idx(row, 2)],\n            state[idx(row, 3)]\n        ];\n        const shifted = rowValues.slice(row).concat(rowValues.slice(0, row));\n        for(let col = 0; col < 4; col++){\n            result[idx(row, col)] = shifted[col];\n        }\n    }\n    return result;\n};\n// MixColumns operation - mix data within columns\nconst mixColumns = (state)=>{\n    const result = [\n        ...state\n    ];\n    const idx = (row, col)=>row + 4 * col;\n    for(let i = 0; i < 4; i++){\n        const s0 = state[idx(0, i)];\n        const s1 = state[idx(1, i)];\n        const s2 = state[idx(2, i)];\n        const s3 = state[idx(3, i)];\n        result[idx(0, i)] = GALOIS_MUL_2[s0] ^ GALOIS_MUL_3[s1] ^ s2 ^ s3;\n        result[idx(1, i)] = s0 ^ GALOIS_MUL_2[s1] ^ GALOIS_MUL_3[s2] ^ s3;\n        result[idx(2, i)] = s0 ^ s1 ^ GALOIS_MUL_2[s2] ^ GALOIS_MUL_3[s3];\n        result[idx(3, i)] = GALOIS_MUL_3[s0] ^ s1 ^ s2 ^ GALOIS_MUL_2[s3];\n    }\n    return result;\n};\n// AddRoundKey operation - XOR state with round key\nconst addRoundKey = (state, roundKey)=>{\n    return state.map((byte, i)=>byte ^ roundKey[i]);\n};\n// Kalitni kengaytirish — raund kalitlarini generatsiya qilish\nconst keyExpansion = function(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const requiredBytes = getKeyByteLength(keyLength);\n    const normalizedKey = key.slice(0, requiredBytes);\n    while(normalizedKey.length < requiredBytes){\n        normalizedKey.push(0);\n    }\n    const keyWords = normalizedKey.length / 4;\n    const numRounds = getNumRounds(keyLength);\n    const roundKeys = [\n        normalizedKey.slice()\n    ]; // 1-raund kaliti boshlang‘ich kalitning o‘zi hisoblanadi\n    for(let round = 1; round <= numRounds; round++){\n        const prevKey = roundKeys[round - 1];\n        const newKey = prevKey.slice();\n        // Oxirgi word ni aylantirib, S-box ni qo‘llang\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const subWord = rotWord.map((byte)=>SBOX[byte]);\n        // Birinchi baytni Rcon bilan XOR qilinadi\n        subWord[0] ^= RCON[round];\n        // Yangi kalitning birinchi word i generatsiya qilinadi\n        newKey[0] = prevKey[0] ^ subWord[0];\n        newKey[1] = prevKey[1] ^ subWord[1];\n        newKey[2] = prevKey[2] ^ subWord[2];\n        newKey[3] = prevKey[3] ^ subWord[3];\n        // Qolgan word lar hosil qilinadi\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            // AES-256 holatida har to‘rtinchi word ga qo‘shimcha S-box (SubWord) qo‘llanadi\n            if (keyLength === 256 && i === 4) {\n                const tempWord = [\n                    newKey[offset - 4],\n                    newKey[offset - 3],\n                    newKey[offset - 2],\n                    newKey[offset - 1]\n                ];\n                const subTempWord = tempWord.map((byte)=>SBOX[byte]);\n                newKey[offset] = prevKey[offset] ^ subTempWord[0];\n                newKey[offset + 1] = prevKey[offset + 1] ^ subTempWord[1];\n                newKey[offset + 2] = prevKey[offset + 2] ^ subTempWord[2];\n                newKey[offset + 3] = prevKey[offset + 3] ^ subTempWord[3];\n            } else {\n                newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n                newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n                newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n                newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            }\n        }\n        roundKeys.push(newKey);\n    }\n    return roundKeys;\n};\n// Perform one round of AES\nconst aesRound = (state, roundKey, isLastRound)=>{\n    let newState = subBytes(state);\n    newState = shiftRows(newState);\n    if (!isLastRound) {\n        newState = mixColumns(newState);\n    }\n    newState = addRoundKey(newState, roundKey);\n    return newState;\n};\n// Complete AES encryption\nconst aesEncrypt = function(plaintext, key) {\n    let keyLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 128;\n    // Initial state\n    const state = textToState(plaintext);\n    // Key expansion\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    // Initial round - just AddRoundKey\n    let currentState = addRoundKey(state, roundKeys[0]);\n    // Main rounds\n    for(let round = 1; round <= numRounds; round++){\n        currentState = aesRound(currentState, roundKeys[round], round === numRounds);\n    }\n    return currentState;\n};\n// Convert full text to array of 16-byte blocks\nconst textToBlocks = function(text) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"PKCS7\";\n    const wordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8.parse(text);\n    const bytes = [];\n    // Convert CryptoJS WordArray to byte array, respecting sigBytes\n    const sigBytes = wordArray.sigBytes;\n    for(let i = 0; i < wordArray.words.length; i++){\n        const word = wordArray.words[i];\n        const bytesInThisWord = Math.min(4, sigBytes - i * 4);\n        if (bytesInThisWord >= 1) bytes.push(word >>> 24 & 0xff);\n        if (bytesInThisWord >= 2) bytes.push(word >>> 16 & 0xff);\n        if (bytesInThisWord >= 3) bytes.push(word >>> 8 & 0xff);\n        if (bytesInThisWord >= 4) bytes.push(word & 0xff);\n    }\n    // Apply padding\n    let paddedBytes;\n    if (padding === \"PKCS7\") {\n        paddedBytes = applyPKCS7Padding(bytes);\n    } else if (padding === \"ANSI X.923\") {\n        paddedBytes = applyAnsiX923Padding(bytes);\n    } else {\n        paddedBytes = [\n            ...bytes\n        ];\n        // For NONE padding, must be multiple of 16\n        while(paddedBytes.length % 16 !== 0){\n            paddedBytes.push(0);\n        }\n    }\n    // Split into 16-byte blocks\n    const blocks = [];\n    for(let i = 0; i < paddedBytes.length; i += 16){\n        blocks.push(paddedBytes.slice(i, i + 16));\n    }\n    return blocks;\n};\n// Apply PKCS7 padding\nconst applyPKCS7Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    for(let i = 0; i < paddingLength; i++){\n        padded.push(paddingLength);\n    }\n    return padded;\n};\n// Apply ANSI X.923 padding\nconst applyAnsiX923Padding = (data)=>{\n    const padded = [\n        ...data\n    ];\n    const paddingLength = 16 - data.length % 16;\n    // Add padding bytes (0x00) except the last byte\n    for(let i = 0; i < paddingLength - 1; i++){\n        padded.push(0x00);\n    }\n    // Add the padding length as the last byte\n    padded.push(paddingLength);\n    return padded;\n};\n// Remove ANSI X.923 padding\nconst removeAnsiX923Padding = (data)=>{\n    const paddingLength = data[data.length - 1];\n    return data.slice(0, data.length - paddingLength);\n};\n// Get IV for CBC mode\nconst generateIV = ()=>{\n    const iv = [];\n    for(let i = 0; i < 16; i++){\n        iv.push(Math.floor(Math.random() * 256));\n    }\n    return iv;\n};\n// Get AES steps for a single block (16 bytes)\nconst getAesStepsForBlock = function(block, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", blockIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, previousCiphertextBlock = arguments.length > 4 ? arguments[4] : void 0, iv = arguments.length > 5 ? arguments[5] : void 0, keyLength = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 128;\n    const steps = [];\n    // Ensure block is exactly 16 bytes\n    const plaintextBytes = [\n        ...block\n    ];\n    while(plaintextBytes.length < 16){\n        plaintextBytes.push(0);\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Asl ochiq matn\"),\n        state: plaintextBytes,\n        explanation: \"Blok \".concat(blockIndex + 1, \" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.\")\n    });\n    const initialState = plaintextBytes;\n    const roundKeys = keyExpansion(key, keyLength);\n    const numRounds = getNumRounds(keyLength);\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (blockIndex === 0 && iv) {\n                currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — IV bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: iv,\n                    explanation: \"CBC: birinchi blok IV bilan XOR qilinadi.\"\n                });\n            } else if (previousCiphertextBlock) {\n                currentState = initialState.map((byte, i)=>byte ^ previousCiphertextBlock[i]);\n                steps.push({\n                    description: \"Blok \".concat(blockIndex + 1, \" — Oldingi ciphertext bilan XOR\"),\n                    state: currentState,\n                    activeIndices: Array.from(Array(16).keys()),\n                    previousState: initialState,\n                    roundKey: previousCiphertextBlock,\n                    explanation: \"CBC: keyingi bloklar oldingi ciphertext bloki bilan XOR qilinadi.\"\n                });\n            } else {\n                currentState = initialState;\n            }\n            break;\n        case \"CTR\":\n            if (!iv) {\n                return {\n                    steps: [],\n                    finalState: plaintextBytes\n                };\n            }\n            const counterBlock = [\n                ...iv\n            ];\n            let counterValue = blockIndex;\n            for(let i = 15; i >= 0 && counterValue > 0; i--){\n                const sum = counterBlock[i] + (counterValue & 0xff);\n                counterBlock[i] = sum & 0xff;\n                counterValue = (counterValue >> 8) + (sum >> 8);\n            }\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter\"),\n                state: counterBlock,\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter.\")\n            });\n            currentState = counterBlock;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Boshlang'ich\"),\n                state: currentState,\n                explanation: \"ECB: blok \".concat(blockIndex + 1, \" mustaqil shifrlanadi.\")\n            });\n            break;\n    }\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — 0-bosqich — AddRoundKey\"),\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    for(let round = 1; round <= numRounds; round++){\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState\n        });\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes\n        });\n        let previousStateForAddRoundKey;\n        if (round < numRounds) {\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows\n            });\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"Blok \".concat(blockIndex + 1, \" — \").concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: \"Blok \".concat(blockIndex + 1, \" — Counter XOR\"),\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: \"CTR: blok \".concat(blockIndex + 1, \" uchun counter XOR.\"),\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: \"Blok \".concat(blockIndex + 1, \" — Yakuniy\"),\n        state: finalState,\n        explanation: \"Blok \".concat(blockIndex + 1, \" uchun yakuniy shifrlangan natija.\")\n    });\n    return {\n        steps,\n        finalState\n    };\n};\nconst getAesSteps = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", providedIv = arguments.length > 4 ? arguments[4] : void 0;\n    const steps = [];\n    let iv = providedIv ? [\n        ...providedIv\n    ] : undefined;\n    // Convert full text to blocks\n    const blocks = textToBlocks(plaintext, padding);\n    const allBlocks = [];\n    // Convert plaintext to bytes (for first block visualization)\n    let plaintextBytes = blocks[0] || textToState(plaintext);\n    steps.push({\n        description: 'Asl ochiq matn',\n        state: plaintextBytes,\n        explanation: 'Ochiq matn \"'.concat(plaintext, '\" baytga aylantiriladi va 4\\xd74 matritsa shaklida ifodalanadi.')\n    });\n    // Apply padding if needed\n    if (padding === \"ANSI X.923\") {\n        plaintextBytes = applyAnsiX923Padding(plaintextBytes);\n        steps.push({\n            description: 'ANSI X.923 to‘ldirishdan keyin',\n            state: plaintextBytes,\n            explanation: 'ANSI X.923 to‘ldirish nollar bilan to‘ldiradi va oxirgi byte ga to‘ldirish uzunligini qo‘yadi.'\n        });\n    }\n    // Generate IV for CBC/CTR mode only if not provided\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n        if (blocks.length === 1) {\n            // Only show IV step if single block (for backward compatibility)\n            const ivDescription = mode === \"CBC\" ? 'Boshlang\\'ich vektor (Initialization Vector, IV)' : 'Counter (Nonce)';\n            const ivExplanation = \"\".concat(mode === \"CBC\" ? 'CBC' : 'CTR', \" rejimi uchun 16-bayt tasodifiy \").concat(mode === \"CBC\" ? 'IV' : 'Nonce', \" yaratiladi.\");\n            steps.push({\n                description: ivDescription,\n                state: iv,\n                explanation: ivExplanation\n            });\n        }\n    }\n    // Start encryption process (for first block visualization)\n    const initialState = plaintextBytes;\n    // Key expansion\n    const roundKeys = keyExpansion(key);\n    // Initial setup based on mode\n    let currentState;\n    switch(mode){\n        case \"CBC\":\n            if (!iv) iv = generateIV(); // Failsafe\n            // XOR plaintext with IV\n            currentState = initialState.map((byte, i)=>byte ^ iv[i]);\n            steps.push({\n                description: 'Boshlang\\'ich holatni IV bilan XOR qilish',\n                state: currentState,\n                activeIndices: Array.from(Array(16).keys()),\n                previousState: initialState,\n                roundKey: iv,\n                explanation: \"CBC rejimida shifrlash boshlanishidan oldin ochiq matn IV bilan XOR qilinadi. Bu jarayon CBC rejimining asosiy xususiyatidir - har bir ochiq matn bloki avvalgi shifrlangan matn bloki (yoki birinchi blok uchun IV) bilan XOR qilinadi, keyin shifrlanadi. Bu bir xil ochiq matn bloklarini turli shifrlangan matn bloklarga aylantiradi va shifrlangan matndagi naqshlarni yashirishga yordam beradi.\"\n            });\n            break;\n        case \"CTR\":\n            // In CTR mode, we encrypt a counter value instead of the plaintext\n            const counter = iv || generateIV();\n            if (!iv) iv = counter;\n            steps.push({\n                description: 'Counter qiymati',\n                state: counter,\n                explanation: 'CTR rejimida ochiq matn o‘rniga counter qiymati shifrlanadi.'\n            });\n            currentState = counter;\n            break;\n        default:\n            currentState = initialState;\n            steps.push({\n                description: 'Boshlang‘ich holat (ochiq matn)',\n                state: currentState,\n                explanation: 'ECB rejimida ochiq matn bloklari mustaqil ravishda shifrlanadi.'\n            });\n            break;\n    }\n    // Initial round - just AddRoundKey (Round 0)\n    const afterInitialRound = addRoundKey(currentState, roundKeys[0]);\n    steps.push({\n        description: '0-bosqich — Boshlang\\'ich AddRoundKey',\n        state: afterInitialRound,\n        activeIndices: Array.from(Array(16).keys()),\n        explanation: '',\n        roundKey: roundKeys[0],\n        previousState: currentState\n    });\n    currentState = afterInitialRound;\n    // Main rounds\n    for(let round = 1; round <= 10; round++){\n        // SubBytes\n        const afterSubBytes = subBytes(currentState);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — SubBytes\"),\n            state: afterSubBytes,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            previousState: currentState // Add previous state for S-box lookup\n        });\n        // ShiftRows\n        const afterShiftRows = shiftRows(afterSubBytes);\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — ShiftRows\"),\n            state: afterShiftRows,\n            activeIndices: [\n                1,\n                2,\n                3,\n                5,\n                6,\n                7,\n                9,\n                10,\n                11,\n                13,\n                14,\n                15\n            ],\n            explanation: '',\n            previousState: afterSubBytes // Add previous state for comparison\n        });\n        let previousStateForAddRoundKey;\n        if (round < 10) {\n            // MixColumns (not in final round)\n            const afterMixColumns = mixColumns(afterShiftRows);\n            steps.push({\n                description: \"\".concat(round, \"-bosqich — MixColumns\"),\n                state: afterMixColumns,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: '',\n                previousState: afterShiftRows // Add previous state for MixColumns comparison\n            });\n            // AddRoundKey\n            currentState = addRoundKey(afterMixColumns, roundKeys[round]);\n            previousStateForAddRoundKey = afterMixColumns;\n        } else {\n            // Final round has no MixColumns\n            currentState = addRoundKey(afterShiftRows, roundKeys[round]);\n            previousStateForAddRoundKey = afterShiftRows;\n        }\n        steps.push({\n            description: \"\".concat(round, \"-bosqich — AddRoundKey\"),\n            state: currentState,\n            activeIndices: Array.from(Array(16).keys()),\n            explanation: '',\n            roundKey: roundKeys[round],\n            previousState: previousStateForAddRoundKey\n        });\n    }\n    // Final output based on mode\n    let finalState;\n    switch(mode){\n        case \"CBC\":\n            // Output is the current state (already completed encryption)\n            finalState = currentState;\n            break;\n        case \"CTR\":\n            // XOR the encrypted counter with plaintext\n            finalState = currentState.map((byte, i)=>byte ^ initialState[i]);\n            steps.push({\n                description: 'Ochiq matn shifrlangan hisoblagich bilan XOR amaliyotida birlashtiriladi.',\n                state: finalState,\n                activeIndices: Array.from(Array(16).keys()),\n                explanation: 'CTR rejimida, yakuniy bosqichda shifrlangan hisoblagich ochiq matn bilan XOR amaliyoti orqali birlashtiriladi va natijada shifrlangan matn hosil bo‘ladi.',\n                previousState: initialState,\n                roundKey: currentState\n            });\n            break;\n        default:\n            finalState = currentState;\n            break;\n    }\n    steps.push({\n        description: 'Yakuniy shifrlangan matn',\n        state: finalState,\n        explanation: \"\".concat(mode, \" rejimida AES-128 yordamida olingan yakuniy shifrlangan natija.\")\n    });\n    // Process all blocks for multi-block support\n    let previousCiphertextBlock;\n    const combinedFinalStates = [];\n    // Generate IV if needed\n    if ((mode === \"CBC\" || mode === \"CTR\") && !iv) {\n        iv = generateIV();\n    }\n    for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++){\n        const blockResult = getAesStepsForBlock(blocks[blockIndex], key, mode, blockIndex, previousCiphertextBlock, iv);\n        allBlocks.push({\n            blockIndex,\n            steps: blockResult.steps,\n            finalState: blockResult.finalState\n        });\n        combinedFinalStates.push(...blockResult.finalState);\n        // For CBC mode, use current ciphertext as previous for next block\n        if (mode === \"CBC\") {\n            previousCiphertextBlock = blockResult.finalState;\n        }\n    }\n    // Use combined final states if we have multiple blocks, otherwise use single block result\n    const finalStateToUse = blocks.length > 1 ? combinedFinalStates : finalState;\n    // Convert the final state to the requested output format\n    const finalWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create(new Uint8Array(finalStateToUse));\n    const finalCiphertextBase64 = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.stringify(finalWordArray);\n    const finalCiphertextHex = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(finalWordArray);\n    const finalCiphertextBinary = bytesToBinary(finalStateToUse, '');\n    return {\n        steps,\n        finalCiphertext: {\n            base64: finalCiphertextBase64,\n            hex: finalCiphertextHex,\n            binary: finalCiphertextBinary\n        },\n        iv,\n        allBlocks: allBlocks.length > 1 ? allBlocks : undefined\n    };\n};\n// Get key expansion steps with detailed explanations\nconst getKeyExpansionSteps = (key)=>{\n    const roundKeys = keyExpansion(key);\n    const steps = [];\n    steps.push({\n        description: 'Boshlang‘ich kalit',\n        key: roundKeys[0],\n        explanation: 'Bu foydalanuvchi tomonidan berilgan asl 128-bitli kalitdir.'\n    });\n    for(let round = 1; round <= 10; round++){\n        const prevKey = roundKeys[round - 1];\n        const currentKey = roundKeys[round];\n        // Calculate the transformations for a more detailed explanation\n        const lastWord = [\n            prevKey[12],\n            prevKey[13],\n            prevKey[14],\n            prevKey[15]\n        ];\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        const rconValue = RCON[round];\n        const transformedWord = [\n            ...sboxWord\n        ];\n        transformedWord[0] ^= rconValue;\n        // Calculate the first word of the previous key and its XOR with the transformed word\n        const firstWordPrev = [\n            prevKey[0],\n            prevKey[1],\n            prevKey[2],\n            prevKey[3]\n        ];\n        const xorResult = firstWordPrev.map((byte, index)=>byte ^ transformedWord[index]);\n        // Show the key with highlighted cells for the new word\n        steps.push({\n            description: \"Raund kaliti \".concat(round),\n            key: currentKey,\n            explanation: \"\\n        \".concat(round, \"-raund uchun kalitni kengaytirish jarayoni:\\n        1. Oldingi kalitning oxirgi word qismini oling: [\").concat(lastWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        2. Wordni aylantiring: [\").concat(rotWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        3. Aylantirilgan word ga S-box ni qo‘llang: [\").concat(sboxWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        4. Birinchi baytga RCON (Round Constant \").concat(rconValue.toString(16), \") ni qo‘llang:\\n          Natija: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"]\\n        5. Oldingi kalitning birinchi word i: [\").concat(firstWordPrev.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] ni o‘zgartirilgan word bilan XOR qiling: [\").concat(transformedWord.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"], natijada: [\").concat(xorResult.map((b)=>b.toString(16).padStart(2, '0')).join(', '), \"] hosil bo‘ladi. So‘ngra qolgan word lar shu tarzda hosil qilinadi.\\n      \"),\n            highlightedCells: [\n                0,\n                1,\n                2,\n                3\n            ] // Highlight the first word that's directly transformed\n        });\n    }\n    return steps;\n};\n// Return intermediate steps for each word expansion for visualization\nfunction getKeyScheduleDetailedSteps(key) {\n    let keyLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 128;\n    const keyWords = key.length / 4;\n    const numRounds = keyLength === 128 ? 10 : keyLength === 192 ? 12 : 14;\n    // Flatten byte array -> words\n    let prevKey = key.slice();\n    let roundKeys = [\n        prevKey.slice()\n    ];\n    // For result visualization: each step for each round\n    let stepsPerRound = [];\n    for(let round = 1; round <= numRounds; round++){\n        let stepDetails = [];\n        let newKey = prevKey.slice();\n        const lastIndex = prevKey.length - 4;\n        const lastWord = [\n            prevKey[lastIndex],\n            prevKey[lastIndex + 1],\n            prevKey[lastIndex + 2],\n            prevKey[lastIndex + 3]\n        ];\n        // Step 1: RotWord\n        const rotWord = [\n            lastWord[1],\n            lastWord[2],\n            lastWord[3],\n            lastWord[0]\n        ];\n        stepDetails.push({\n            step: 'RotWord',\n            input: lastWord.slice(),\n            output: rotWord.slice()\n        });\n        // Step 2: SubBytes (S-box)\n        const sboxWord = rotWord.map((byte)=>SBOX[byte]);\n        stepDetails.push({\n            step: 'SubBytes',\n            input: rotWord.slice(),\n            output: sboxWord.slice()\n        });\n        // Step 3: Rcon to first byte\n        const rconValue = RCON[round];\n        const rconWord = sboxWord.slice();\n        rconWord[0] ^= rconValue;\n        stepDetails.push({\n            step: 'Apply Rcon',\n            input: sboxWord.slice(),\n            rcon: rconValue,\n            output: rconWord.slice()\n        });\n        // Step 4: XOR with previous (first word)\n        const xorResult = [\n            prevKey[0] ^ rconWord[0],\n            prevKey[1] ^ rconWord[1],\n            prevKey[2] ^ rconWord[2],\n            prevKey[3] ^ rconWord[3]\n        ];\n        stepDetails.push({\n            step: 'XOR with previous',\n            inputs: [\n                prevKey.slice(0, 4),\n                rconWord.slice()\n            ],\n            output: xorResult.slice()\n        });\n        // Save and update newKey\n        newKey[0] = xorResult[0];\n        newKey[1] = xorResult[1];\n        newKey[2] = xorResult[2];\n        newKey[3] = xorResult[3];\n        // Other words (only simple xor)\n        for(let i = 1; i < keyWords; i++){\n            const offset = i * 4;\n            newKey[offset] = newKey[offset - 4] ^ prevKey[offset];\n            newKey[offset + 1] = newKey[offset - 3] ^ prevKey[offset + 1];\n            newKey[offset + 2] = newKey[offset - 2] ^ prevKey[offset + 2];\n            newKey[offset + 3] = newKey[offset - 1] ^ prevKey[offset + 3];\n            stepDetails.push({\n                step: 'XOR chain',\n                inputs: [\n                    newKey.slice(offset - 4, offset),\n                    prevKey.slice(offset, offset + 4)\n                ],\n                output: newKey.slice(offset, offset + 4),\n                wordIndex: i\n            });\n        }\n        stepsPerRound.push({\n            round,\n            stepDetails,\n            roundKey: newKey.slice()\n        });\n        prevKey = newKey.slice();\n        roundKeys.push(prevKey);\n    }\n    return stepsPerRound;\n}\n// Real AES encryption using CryptoJS for verification\nconst realAesEncrypt = function(plaintext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", outputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    // Handle case where key is shorter than required by keyLength\n    const cleanKey = key.replace(/\\s/g, '');\n    let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n    // Ensure key is of correct length for the selected key length\n    const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n    if (keyHex.length < requiredHexChars) {\n        // Pad key if too short\n        keyHex = keyHex.padEnd(requiredHexChars, '0');\n    } else if (keyHex.length > requiredHexChars) {\n        // Truncate key if too long\n        keyHex = keyHex.substring(0, requiredHexChars);\n    }\n    const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n    let paddingOption;\n    switch(padding){\n        case \"ANSI X.923\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n            };\n            break;\n        case \"None\":\n            paddingOption = {\n                padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n            };\n            break;\n        default:\n            paddingOption = {}; // default is PKCS7\n    }\n    let modeOption;\n    let iv;\n    switch(mode){\n        case \"CBC\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                iv: iv,\n                ...paddingOption\n            };\n            break;\n        case \"CTR\":\n            if (ivString) {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n            } else {\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.random(16);\n            }\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                iv: iv,\n                counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                    0,\n                    0,\n                    0,\n                    0\n                ], 16),\n                ...paddingOption\n            };\n            break;\n        default:\n            modeOption = {\n                mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                ...paddingOption\n            };\n            break;\n    }\n    const encrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(plaintext, keyWordArray, modeOption);\n    // Get all output formats\n    const base64Output = encrypted.toString();\n    const cipherParams = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.CipherParams.create({\n        ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(base64Output)\n    });\n    const hexOutput = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().format.Hex.stringify(cipherParams);\n    // For binary, we need to convert the hex to binary\n    const hexBytes = hexOutput.match(/.{2}/g).map((hex)=>parseInt(hex, 16));\n    const binaryOutput = bytesToBinary(hexBytes, '');\n    // Select the requested format for primary output\n    let primaryOutput;\n    switch(outputFormat){\n        case \"Hex\":\n            primaryOutput = hexOutput;\n            break;\n        case \"Binary\":\n            primaryOutput = binaryOutput;\n            break;\n        default:\n            primaryOutput = base64Output;\n            break;\n    }\n    return {\n        ciphertext: primaryOutput,\n        iv: iv ? crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.stringify(iv) : undefined,\n        formats: {\n            base64: base64Output,\n            hex: hexOutput,\n            binary: binaryOutput\n        }\n    };\n};\n// Real AES decryption using CryptoJS\nconst realAesDecrypt = function(ciphertext, key) {\n    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ECB\", padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"PKCS7\", inputFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"Base64\", keyLength = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 128, ivString = arguments.length > 6 ? arguments[6] : void 0;\n    try {\n        // Handle case where key is shorter than required by keyLength\n        const cleanKey = key.replace(/\\s/g, '');\n        let keyHex = cleanKey.length % 2 === 1 ? cleanKey + '0' : cleanKey;\n        // Ensure key is of correct length for the selected key length\n        const requiredHexChars = keyLength / 4; // Each hex char is 4 bits\n        if (keyHex.length < requiredHexChars) {\n            // Pad key if too short\n            keyHex = keyHex.padEnd(requiredHexChars, '0');\n        } else if (keyHex.length > requiredHexChars) {\n            // Truncate key if too long\n            keyHex = keyHex.substring(0, requiredHexChars);\n        }\n        const keyWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(keyHex);\n        // Parse ciphertext based on input format\n        let ciphertextWordArray;\n        switch(inputFormat){\n            case \"Hex\":\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ciphertext.replace(/\\s/g, ''));\n                break;\n            case \"Binary\":\n                var _ciphertext_replace_match;\n                // Convert binary string to hex first\n                const hexFromBinary = ((_ciphertext_replace_match = ciphertext.replace(/\\s/g, '').match(/.{8}/g)) === null || _ciphertext_replace_match === void 0 ? void 0 : _ciphertext_replace_match.map((bin)=>parseInt(bin, 2).toString(16).padStart(2, '0')).join('')) || '';\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(hexFromBinary);\n                break;\n            default:\n                ciphertextWordArray = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(ciphertext);\n                break;\n        }\n        let paddingOption;\n        switch(padding){\n            case \"ANSI X.923\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).AnsiX923\n                };\n                break;\n            case \"None\":\n                paddingOption = {\n                    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().pad).NoPadding\n                };\n                break;\n            default:\n                paddingOption = {}; // default is PKCS7\n        }\n        let modeOption;\n        let iv;\n        switch(mode){\n            case \"CBC\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CBC rejimi uchun IV kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CBC,\n                    iv: iv,\n                    ...paddingOption\n                };\n                break;\n            case \"CTR\":\n                if (!ivString) {\n                    return {\n                        plaintext: '',\n                        error: 'CTR rejimi uchun IV (Nonce) kerak'\n                    };\n                }\n                iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(ivString.replace(/\\s/g, ''));\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).CTR,\n                    iv: iv,\n                    counter: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().lib.WordArray.create([\n                        0,\n                        0,\n                        0,\n                        0\n                    ], 16),\n                    ...paddingOption\n                };\n                break;\n            default:\n                modeOption = {\n                    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_0___default().mode).ECB,\n                    ...paddingOption\n                };\n                break;\n        }\n        const decrypted = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt({\n            ciphertext: ciphertextWordArray\n        }, keyWordArray, modeOption);\n        const plaintext = decrypted.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8);\n        if (!plaintext) {\n            return {\n                plaintext: '',\n                error: 'Deshifrlash muvaffaqiyatsiz. Kalit yoki shifrlangan matn noto\\'g\\'ri.'\n            };\n        }\n        return {\n            plaintext\n        };\n    } catch (error) {\n        return {\n            plaintext: '',\n            error: error.message || 'Deshifrlashda xatolik yuz berdi'\n        };\n    }\n};\n// Test specific case for \"Salom, AES!\" with key \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\"\nconst testSpecificCase = ()=>{\n    const plaintext = \"Salom, AES!\";\n    const key = \"cc 0e c1 70 24 24 01 8d 4e fd 5e f3 8d 15 2f 63\";\n    // Create key and input as byte arrays\n    const keyBytes = [];\n    for(let i = 0; i < key.length; i += 2){\n        keyBytes.push(parseInt(key.substr(i, 2), 16));\n    }\n    // Use our implementation\n    const { finalCiphertext } = getAesSteps(plaintext, keyBytes, \"ECB\", \"PKCS7\");\n    // Use CryptoJS implementation\n    const cryptoResult = realAesEncrypt(plaintext, key, \"ECB\", \"PKCS7\", \"Hex\");\n    return \"\\n    Bizning implementatsiyamiz (HEX): \".concat(finalCiphertext.hex, \"\\n    CryptoJS implementatsiyasi (HEX): \").concat(cryptoResult.formats.hex, \"\\n    Kutilayotgan natija: 30484B8F8C6BB09CA3F94C6F84F0305E\\n  \");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9hZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUVqQyxnQkFBZ0I7QUFDVCxxQ0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELGVBQWU7QUFDUix5Q0FBS0M7Ozs7V0FBQUE7TUFJWDtBQUVELHFCQUFxQjtBQUNkLDBDQUFLQzs7OztXQUFBQTtNQUlYO0FBRUQsa0JBQWtCO0FBQ1gsdUNBQUtDOzs7O1dBQUFBO01BSVg7QUFFRCxNQUFNQyxlQUFlLENBQUNDLFlBQ3BCQSxvQkFBa0MsS0FDbENBLG9CQUFrQyxLQUFLO0FBR3pDLE1BQU1DLG1CQUFtQixDQUFDRCxZQUFpQ0EsWUFBWTtBQUV2RSxzQ0FBc0M7QUFDL0IsTUFBTUUsT0FBTztJQUNsQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRixDQUFDO0FBRUYsNkJBQTZCO0FBQ3RCLE1BQU1DLE9BQU87SUFDbEI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLHFCQUFxQjtBQUNkLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVLLE1BQU1DLGVBQWU7SUFDMUI7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDM0YsQ0FBQztBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxjQUFjLENBQUNDO0lBQzFCLE1BQU1DLFlBQVlkLG9EQUFZLENBQUNnQixJQUFJLENBQUNDLEtBQUssQ0FBQ0o7SUFDMUMsTUFBTUssUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxXQUFXTCxVQUFVSyxRQUFRO0lBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixVQUFVTyxLQUFLLENBQUNDLE1BQU0sRUFBRUYsSUFBSztRQUMvQyxNQUFNRyxPQUFPVCxVQUFVTyxLQUFLLENBQUNELEVBQUU7UUFDL0IsTUFBTUksa0JBQWtCQyxLQUFLQyxHQUFHLENBQUMsR0FBR1AsV0FBV0MsSUFBSTtRQUNuRCxJQUFJSSxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsSUFBSztRQUNwRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDSixPQUFPO0lBQzlDO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU9MLE1BQU1JLE1BQU0sR0FBRyxHQUFJO1FBQ3hCSixNQUFNUyxJQUFJLENBQUM7SUFDYjtJQUVBLE1BQU1DLFFBQVFWLE1BQU1XLEtBQUssQ0FBQyxHQUFHO0lBQzdCLDZEQUE2RDtJQUM3RCxPQUFPRDtBQUNULEVBQUU7QUFFRiwwREFBMEQ7QUFDbkQsTUFBTUUsYUFBYSxTQUN4QkM7UUFDQXpCO0lBRUEsTUFBTTBCLGdCQUFnQnpCLGlCQUFpQkQ7SUFDdkMsTUFBTTJCLG9CQUFvQkQsZ0JBQWdCO0lBRTFDLHlDQUF5QztJQUN6QyxNQUFNRSxXQUFXSCxJQUFJSSxPQUFPLENBQUMsT0FBTyxJQUFJQyxXQUFXO0lBRW5ELG1DQUFtQztJQUNuQyxJQUFJLGNBQWNDLElBQUksQ0FBQ0gsV0FBVztRQUNoQyxNQUFNaEIsUUFBa0IsRUFBRTtRQUMxQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUssS0FBS0MsR0FBRyxDQUFDUSxTQUFTWixNQUFNLEVBQUVXLG9CQUFvQmIsS0FBSyxFQUFHO1lBQ3hFRixNQUFNUyxJQUFJLENBQUNXLFNBQVNKLFNBQVNLLE1BQU0sQ0FBQ25CLEdBQUcsSUFBSTtRQUM3QztRQUNBLE1BQU9GLE1BQU1JLE1BQU0sR0FBR1UsY0FBZTtZQUNuQ2QsTUFBTVMsSUFBSSxDQUFDO1FBQ2I7UUFDQSxPQUFPVCxNQUFNVyxLQUFLLENBQUMsR0FBR0c7SUFDeEI7SUFFQSxvRUFBb0U7SUFDcEUsTUFBTWxCLFlBQVlkLG9EQUFZLENBQUNnQixJQUFJLENBQUNDLEtBQUssQ0FBQ2M7SUFDMUMsTUFBTWIsUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxXQUFXTCxVQUFVSyxRQUFRO0lBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixVQUFVTyxLQUFLLENBQUNDLE1BQU0sRUFBRUYsSUFBSztRQUMvQyxNQUFNRyxPQUFPVCxVQUFVTyxLQUFLLENBQUNELEVBQUU7UUFDL0IsTUFBTUksa0JBQWtCQyxLQUFLQyxHQUFHLENBQUMsR0FBR1AsV0FBV0MsSUFBSTtRQUNuRCxJQUFJSSxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsS0FBTTtRQUNyRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDLFNBQVUsSUFBSztRQUNwRCxJQUFJSCxtQkFBbUIsR0FBR04sTUFBTVMsSUFBSSxDQUFDSixPQUFPO0lBQzlDO0lBQ0EsTUFBT0wsTUFBTUksTUFBTSxHQUFHVSxjQUFlO1FBQ25DZCxNQUFNUyxJQUFJLENBQUM7SUFDYjtJQUNBLE9BQU9ULE1BQU1XLEtBQUssQ0FBQyxHQUFHRztBQUN4QixFQUFFO0FBRUYsMERBQTBEO0FBQ25ELE1BQU1RLG9CQUFvQjtRQUFDbEM7SUFDaEMsTUFBTW1DLFdBQVdsQyxpQkFBaUJEO0lBQ2xDLE1BQU1ZLFFBQVEsRUFBRTtJQUNoQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXFCLFVBQVVyQixJQUFLO1FBQ2pDRixNQUFNUyxJQUFJLENBQUNGLEtBQUtpQixLQUFLLENBQUNqQixLQUFLa0IsTUFBTSxLQUFLO0lBQ3hDO0lBQ0EsT0FBT3pCO0FBQ1QsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU0wQixhQUFhLFNBQUMxQjtRQUFpQjJCLDRFQUFtQjtJQUM3RCxPQUFPM0IsTUFBTTRCLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQ0w7QUFDcEUsRUFBRTtBQUVGLHlCQUF5QjtBQUNsQixNQUFNTSxnQkFBZ0IsU0FBQ2pDO1FBQWlCMkIsNEVBQW1CO0lBQ2hFLE9BQU8zQixNQUFNNEIsR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxRQUFRLENBQUMsR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDTDtBQUNuRSxFQUFFO0FBRUYsaUVBQWlFO0FBQzFELE1BQU1PLFdBQVcsQ0FBQ0M7SUFDdkIsT0FBT0EsTUFBTVAsR0FBRyxDQUFDQyxDQUFBQSxPQUFRdkMsSUFBSSxDQUFDdUMsS0FBSztBQUNyQyxFQUFFO0FBRUYsd0RBQXdEO0FBQ2pELE1BQU1PLFlBQVksQ0FBQ0Q7SUFDeEIsTUFBTUUsU0FBUztXQUFJRjtLQUFNO0lBRXpCLCtEQUErRDtJQUMvRCxNQUFNRyxNQUFNLENBQUNDLEtBQWFDLE1BQWdCRCxNQUFNLElBQUlDO0lBRXBELElBQUssSUFBSUQsTUFBTSxHQUFHQSxNQUFNLEdBQUdBLE1BQU87UUFDaEMsTUFBTUUsWUFBWTtZQUFDTixLQUFLLENBQUNHLElBQUlDLEtBQUssR0FBRztZQUFFSixLQUFLLENBQUNHLElBQUlDLEtBQUssR0FBRztZQUFFSixLQUFLLENBQUNHLElBQUlDLEtBQUssR0FBRztZQUFFSixLQUFLLENBQUNHLElBQUlDLEtBQUssR0FBRztTQUFDO1FBQ2xHLE1BQU1HLFVBQVVELFVBQVU5QixLQUFLLENBQUM0QixLQUFLSSxNQUFNLENBQUNGLFVBQVU5QixLQUFLLENBQUMsR0FBRzRCO1FBQy9ELElBQUssSUFBSUMsTUFBTSxHQUFHQSxNQUFNLEdBQUdBLE1BQU87WUFDaENILE1BQU0sQ0FBQ0MsSUFBSUMsS0FBS0MsS0FBSyxHQUFHRSxPQUFPLENBQUNGLElBQUk7UUFDdEM7SUFDRjtJQUVBLE9BQU9IO0FBQ1QsRUFBRTtBQUVGLGlEQUFpRDtBQUMxQyxNQUFNTyxhQUFhLENBQUNUO0lBQ3pCLE1BQU1FLFNBQVM7V0FBSUY7S0FBTTtJQUN6QixNQUFNRyxNQUFNLENBQUNDLEtBQWFDLE1BQWdCRCxNQUFNLElBQUlDO0lBQ3BELElBQUssSUFBSXRDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQzFCLE1BQU0yQyxLQUFLVixLQUFLLENBQUNHLElBQUksR0FBR3BDLEdBQUc7UUFDM0IsTUFBTTRDLEtBQUtYLEtBQUssQ0FBQ0csSUFBSSxHQUFHcEMsR0FBRztRQUMzQixNQUFNNkMsS0FBS1osS0FBSyxDQUFDRyxJQUFJLEdBQUdwQyxHQUFHO1FBQzNCLE1BQU04QyxLQUFLYixLQUFLLENBQUNHLElBQUksR0FBR3BDLEdBQUc7UUFFM0JtQyxNQUFNLENBQUNDLElBQUksR0FBR3BDLEdBQUcsR0FBR1YsWUFBWSxDQUFDcUQsR0FBRyxHQUFHcEQsWUFBWSxDQUFDcUQsR0FBRyxHQUFHQyxLQUFLQztRQUMvRFgsTUFBTSxDQUFDQyxJQUFJLEdBQUdwQyxHQUFHLEdBQUcyQyxLQUFLckQsWUFBWSxDQUFDc0QsR0FBRyxHQUFHckQsWUFBWSxDQUFDc0QsR0FBRyxHQUFHQztRQUMvRFgsTUFBTSxDQUFDQyxJQUFJLEdBQUdwQyxHQUFHLEdBQUcyQyxLQUFLQyxLQUFLdEQsWUFBWSxDQUFDdUQsR0FBRyxHQUFHdEQsWUFBWSxDQUFDdUQsR0FBRztRQUNqRVgsTUFBTSxDQUFDQyxJQUFJLEdBQUdwQyxHQUFHLEdBQUdULFlBQVksQ0FBQ29ELEdBQUcsR0FBR0MsS0FBS0MsS0FBS3ZELFlBQVksQ0FBQ3dELEdBQUc7SUFDbkU7SUFDQSxPQUFPWDtBQUNULEVBQUU7QUFFRixtREFBbUQ7QUFDNUMsTUFBTVksY0FBYyxDQUFDZCxPQUFpQmU7SUFDM0MsT0FBT2YsTUFBTVAsR0FBRyxDQUFDLENBQUNDLE1BQU0zQixJQUFNMkIsT0FBT3FCLFFBQVEsQ0FBQ2hELEVBQUU7QUFDbEQsRUFBRTtBQUVGLDhEQUE4RDtBQUN2RCxNQUFNaUQsZUFBZSxTQUFDdEM7UUFBZXpCO0lBQzFDLE1BQU0wQixnQkFBZ0J6QixpQkFBaUJEO0lBQ3ZDLE1BQU1nRSxnQkFBZ0J2QyxJQUFJRixLQUFLLENBQUMsR0FBR0c7SUFDbkMsTUFBT3NDLGNBQWNoRCxNQUFNLEdBQUdVLGNBQWU7UUFDM0NzQyxjQUFjM0MsSUFBSSxDQUFDO0lBQ3JCO0lBRUEsTUFBTTRDLFdBQVdELGNBQWNoRCxNQUFNLEdBQUc7SUFDeEMsTUFBTWtELFlBQVluRSxhQUFhQztJQUUvQixNQUFNbUUsWUFBd0I7UUFBQ0gsY0FBY3pDLEtBQUs7S0FBRyxFQUFFLHlEQUF5RDtJQUVoSCxJQUFLLElBQUk2QyxRQUFRLEdBQUdBLFNBQVNGLFdBQVdFLFFBQVM7UUFDL0MsTUFBTUMsVUFBVUYsU0FBUyxDQUFDQyxRQUFRLEVBQUU7UUFDcEMsTUFBTUUsU0FBU0QsUUFBUTlDLEtBQUs7UUFFNUIsK0NBQStDO1FBQy9DLE1BQU1nRCxZQUFZRixRQUFRckQsTUFBTSxHQUFHO1FBQ25DLE1BQU13RCxXQUFXO1lBQUNILE9BQU8sQ0FBQ0UsVUFBVTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtTQUFDO1FBQzdHLE1BQU1FLFVBQVU7WUFBQ0QsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7U0FBQztRQUNwRSxNQUFNRSxVQUFVRCxRQUFRakMsR0FBRyxDQUFDQyxDQUFBQSxPQUFRdkMsSUFBSSxDQUFDdUMsS0FBSztRQUU5QywwQ0FBMEM7UUFDMUNpQyxPQUFPLENBQUMsRUFBRSxJQUFJdkUsSUFBSSxDQUFDaUUsTUFBTTtRQUV6Qix1REFBdUQ7UUFDdkRFLE1BQU0sQ0FBQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxFQUFFLEdBQUdLLE9BQU8sQ0FBQyxFQUFFO1FBQ25DSixNQUFNLENBQUMsRUFBRSxHQUFHRCxPQUFPLENBQUMsRUFBRSxHQUFHSyxPQUFPLENBQUMsRUFBRTtRQUNuQ0osTUFBTSxDQUFDLEVBQUUsR0FBR0QsT0FBTyxDQUFDLEVBQUUsR0FBR0ssT0FBTyxDQUFDLEVBQUU7UUFDbkNKLE1BQU0sQ0FBQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxFQUFFLEdBQUdLLE9BQU8sQ0FBQyxFQUFFO1FBRW5DLGlDQUFpQztRQUNqQyxJQUFLLElBQUk1RCxJQUFJLEdBQUdBLElBQUltRCxVQUFVbkQsSUFBSztZQUNqQyxNQUFNNkQsU0FBUzdELElBQUk7WUFDbkIsZ0ZBQWdGO1lBQ2hGLElBQUlkLHFCQUFtQ2MsTUFBTSxHQUFHO2dCQUM5QyxNQUFNOEQsV0FBVztvQkFBQ04sTUFBTSxDQUFDSyxTQUFTLEVBQUU7b0JBQUVMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFO29CQUFFTCxNQUFNLENBQUNLLFNBQVMsRUFBRTtvQkFBRUwsTUFBTSxDQUFDSyxTQUFTLEVBQUU7aUJBQUM7Z0JBQ2pHLE1BQU1FLGNBQWNELFNBQVNwQyxHQUFHLENBQUNDLENBQUFBLE9BQVF2QyxJQUFJLENBQUN1QyxLQUFLO2dCQUVuRDZCLE1BQU0sQ0FBQ0ssT0FBTyxHQUFHTixPQUFPLENBQUNNLE9BQU8sR0FBR0UsV0FBVyxDQUFDLEVBQUU7Z0JBQ2pEUCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRSxHQUFHRSxXQUFXLENBQUMsRUFBRTtnQkFDekRQLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFLEdBQUdFLFdBQVcsQ0FBQyxFQUFFO2dCQUN6RFAsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUUsR0FBR0UsV0FBVyxDQUFDLEVBQUU7WUFDM0QsT0FBTztnQkFDTFAsTUFBTSxDQUFDSyxPQUFPLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sT0FBTztnQkFDckRMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFO2dCQUM3REwsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR0wsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUU7Z0JBQzdETCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRTtZQUMvRDtRQUNGO1FBRUFSLFVBQVU5QyxJQUFJLENBQUNpRDtJQUNqQjtJQUVBLE9BQU9IO0FBQ1QsRUFBRTtBQUVGLDJCQUEyQjtBQUNwQixNQUFNVyxXQUFXLENBQUMvQixPQUFpQmUsVUFBb0JpQjtJQUM1RCxJQUFJQyxXQUFXbEMsU0FBU0M7SUFDeEJpQyxXQUFXaEMsVUFBVWdDO0lBQ3JCLElBQUksQ0FBQ0QsYUFBYTtRQUNoQkMsV0FBV3hCLFdBQVd3QjtJQUN4QjtJQUNBQSxXQUFXbkIsWUFBWW1CLFVBQVVsQjtJQUNqQyxPQUFPa0I7QUFDVCxFQUFFO0FBRUYsMEJBQTBCO0FBQ25CLE1BQU1DLGFBQWEsU0FDeEJDLFdBQ0F6RDtRQUNBekI7SUFFQSxnQkFBZ0I7SUFDaEIsTUFBTStDLFFBQVF6QyxZQUFZNEU7SUFFMUIsZ0JBQWdCO0lBQ2hCLE1BQU1mLFlBQVlKLGFBQWF0QyxLQUFLekI7SUFDcEMsTUFBTWtFLFlBQVluRSxhQUFhQztJQUUvQixtQ0FBbUM7SUFDbkMsSUFBSW1GLGVBQWV0QixZQUFZZCxPQUFPb0IsU0FBUyxDQUFDLEVBQUU7SUFFbEQsY0FBYztJQUNkLElBQUssSUFBSUMsUUFBUSxHQUFHQSxTQUFTRixXQUFXRSxRQUFTO1FBQy9DZSxlQUFlTCxTQUFTSyxjQUFjaEIsU0FBUyxDQUFDQyxNQUFNLEVBQUVBLFVBQVVGO0lBQ3BFO0lBRUEsT0FBT2lCO0FBQ1QsRUFBRTtBQUVGLCtDQUErQztBQUN4QyxNQUFNQyxlQUFlLFNBQUM3RTtRQUFjOEU7SUFDekMsTUFBTTdFLFlBQVlkLG9EQUFZLENBQUNnQixJQUFJLENBQUNDLEtBQUssQ0FBQ0o7SUFDMUMsTUFBTUssUUFBa0IsRUFBRTtJQUUxQixnRUFBZ0U7SUFDaEUsTUFBTUMsV0FBV0wsVUFBVUssUUFBUTtJQUNuQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sVUFBVU8sS0FBSyxDQUFDQyxNQUFNLEVBQUVGLElBQUs7UUFDL0MsTUFBTUcsT0FBT1QsVUFBVU8sS0FBSyxDQUFDRCxFQUFFO1FBQy9CLE1BQU1JLGtCQUFrQkMsS0FBS0MsR0FBRyxDQUFDLEdBQUdQLFdBQVdDLElBQUk7UUFFbkQsSUFBSUksbUJBQW1CLEdBQUdOLE1BQU1TLElBQUksQ0FBQyxTQUFVLEtBQU07UUFDckQsSUFBSUgsbUJBQW1CLEdBQUdOLE1BQU1TLElBQUksQ0FBQyxTQUFVLEtBQU07UUFDckQsSUFBSUgsbUJBQW1CLEdBQUdOLE1BQU1TLElBQUksQ0FBQyxTQUFVLElBQUs7UUFDcEQsSUFBSUgsbUJBQW1CLEdBQUdOLE1BQU1TLElBQUksQ0FBQ0osT0FBTztJQUM5QztJQUVBLGdCQUFnQjtJQUNoQixJQUFJcUU7SUFDSixJQUFJRCxxQkFBK0I7UUFDakNDLGNBQWNDLGtCQUFrQjNFO0lBQ2xDLE9BQU8sSUFBSXlFLDBCQUFtQztRQUM1Q0MsY0FBY0UscUJBQXFCNUU7SUFDckMsT0FBTztRQUNMMEUsY0FBYztlQUFJMUU7U0FBTTtRQUN4QiwyQ0FBMkM7UUFDM0MsTUFBTzBFLFlBQVl0RSxNQUFNLEdBQUcsT0FBTyxFQUFHO1lBQ3BDc0UsWUFBWWpFLElBQUksQ0FBQztRQUNuQjtJQUNGO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1vRSxTQUFxQixFQUFFO0lBQzdCLElBQUssSUFBSTNFLElBQUksR0FBR0EsSUFBSXdFLFlBQVl0RSxNQUFNLEVBQUVGLEtBQUssR0FBSTtRQUMvQzJFLE9BQU9wRSxJQUFJLENBQUNpRSxZQUFZL0QsS0FBSyxDQUFDVCxHQUFHQSxJQUFJO0lBQ3ZDO0lBRUEsT0FBTzJFO0FBQ1QsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU1GLG9CQUFvQixDQUFDRztJQUNoQyxNQUFNQyxTQUFTO1dBQUlEO0tBQUs7SUFDeEIsTUFBTUUsZ0JBQWdCLEtBQU1GLEtBQUsxRSxNQUFNLEdBQUc7SUFFMUMsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUk4RSxlQUFlOUUsSUFBSztRQUN0QzZFLE9BQU90RSxJQUFJLENBQUN1RTtJQUNkO0lBRUEsT0FBT0Q7QUFDVCxFQUFFO0FBRUYsMkJBQTJCO0FBQ3BCLE1BQU1ILHVCQUF1QixDQUFDRTtJQUNuQyxNQUFNQyxTQUFTO1dBQUlEO0tBQUs7SUFDeEIsTUFBTUUsZ0JBQWdCLEtBQU1GLEtBQUsxRSxNQUFNLEdBQUc7SUFFMUMsZ0RBQWdEO0lBQ2hELElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJOEUsZ0JBQWdCLEdBQUc5RSxJQUFLO1FBQzFDNkUsT0FBT3RFLElBQUksQ0FBQztJQUNkO0lBRUEsMENBQTBDO0lBQzFDc0UsT0FBT3RFLElBQUksQ0FBQ3VFO0lBRVosT0FBT0Q7QUFDVCxFQUFFO0FBRUYsNEJBQTRCO0FBQ3JCLE1BQU1FLHdCQUF3QixDQUFDSDtJQUNwQyxNQUFNRSxnQkFBZ0JGLElBQUksQ0FBQ0EsS0FBSzFFLE1BQU0sR0FBRyxFQUFFO0lBQzNDLE9BQU8wRSxLQUFLbkUsS0FBSyxDQUFDLEdBQUdtRSxLQUFLMUUsTUFBTSxHQUFHNEU7QUFDckMsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU1FLGFBQWE7SUFDeEIsTUFBTUMsS0FBSyxFQUFFO0lBQ2IsSUFBSyxJQUFJakYsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7UUFDM0JpRixHQUFHMUUsSUFBSSxDQUFDRixLQUFLaUIsS0FBSyxDQUFDakIsS0FBS2tCLE1BQU0sS0FBSztJQUNyQztJQUNBLE9BQU8wRDtBQUNULEVBQUU7QUFZRiw4Q0FBOEM7QUFDdkMsTUFBTUMsc0JBQXNCLFNBQ2pDMUUsT0FDQUc7UUFDQXdFLCtFQUNBQyw4RUFBcUIsR0FDckJDLHdFQUNBSixtREFDQS9GO0lBS0EsTUFBTW9HLFFBQW1CLEVBQUU7SUFFM0IsbUNBQW1DO0lBQ25DLE1BQU1DLGlCQUFpQjtXQUFJL0U7S0FBTTtJQUNqQyxNQUFPK0UsZUFBZXJGLE1BQU0sR0FBRyxHQUFJO1FBQ2pDcUYsZUFBZWhGLElBQUksQ0FBQztJQUN0QjtJQUVBK0UsTUFBTS9FLElBQUksQ0FBQztRQUNUaUYsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7UUFDcENuRCxPQUFPc0Q7UUFDUEUsYUFBYSxRQUF1QixPQUFmTCxhQUFhLEdBQUU7SUFDdEM7SUFFQSxNQUFNTSxlQUFlSDtJQUNyQixNQUFNbEMsWUFBWUosYUFBYXRDLEtBQUt6QjtJQUNwQyxNQUFNa0UsWUFBWW5FLGFBQWFDO0lBRS9CLElBQUltRjtJQUVKLE9BQVFjO1FBQ047WUFDRSxJQUFJQyxlQUFlLEtBQUtILElBQUk7Z0JBQzFCWixlQUFlcUIsYUFBYWhFLEdBQUcsQ0FBQyxDQUFDQyxNQUFNM0IsSUFBTTJCLE9BQU9zRCxFQUFFLENBQUNqRixFQUFFO2dCQUN6RHNGLE1BQU0vRSxJQUFJLENBQUM7b0JBQ1RpRixhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtvQkFDcENuRCxPQUFPb0M7b0JBQ1BzQixlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtvQkFDeENDLGVBQWVMO29CQUNmMUMsVUFBVWlDO29CQUNWUSxhQUFjO2dCQUNoQjtZQUNGLE9BQU8sSUFBSUoseUJBQXlCO2dCQUNsQ2hCLGVBQWVxQixhQUFhaEUsR0FBRyxDQUFDLENBQUNDLE1BQU0zQixJQUFNMkIsT0FBTzBELHVCQUF1QixDQUFDckYsRUFBRTtnQkFDOUVzRixNQUFNL0UsSUFBSSxDQUFDO29CQUNUaUYsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7b0JBQ3BDbkQsT0FBT29DO29CQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7b0JBQ3hDQyxlQUFlTDtvQkFDZjFDLFVBQVVxQztvQkFDVkksYUFBYztnQkFDaEI7WUFDRixPQUFPO2dCQUNMcEIsZUFBZXFCO1lBQ2pCO1lBQ0E7UUFDRjtZQUNFLElBQUksQ0FBQ1QsSUFBSTtnQkFDUCxPQUFPO29CQUFFSyxPQUFPLEVBQUU7b0JBQUVVLFlBQVlUO2dCQUFlO1lBQ2pEO1lBQ0EsTUFBTVUsZUFBZTttQkFBSWhCO2FBQUc7WUFDNUIsSUFBSWlCLGVBQWVkO1lBQ25CLElBQUssSUFBSXBGLElBQUksSUFBSUEsS0FBSyxLQUFLa0csZUFBZSxHQUFHbEcsSUFBSztnQkFDaEQsTUFBTW1HLE1BQU1GLFlBQVksQ0FBQ2pHLEVBQUUsR0FBSWtHLENBQUFBLGVBQWUsSUFBRztnQkFDakRELFlBQVksQ0FBQ2pHLEVBQUUsR0FBR21HLE1BQU07Z0JBQ3hCRCxlQUFlLENBQUNBLGdCQUFnQixLQUFNQyxDQUFBQSxPQUFPO1lBQy9DO1lBQ0FiLE1BQU0vRSxJQUFJLENBQUM7Z0JBQ1RpRixhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtnQkFDcENuRCxPQUFPZ0U7Z0JBQ1BSLGFBQWEsYUFBNEIsT0FBZkwsYUFBYSxHQUFFO1lBQzNDO1lBQ0FmLGVBQWU0QjtZQUNmO1FBQ0Y7WUFDRTVCLGVBQWVxQjtZQUNmSixNQUFNL0UsSUFBSSxDQUFDO2dCQUNUaUYsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7Z0JBQ3BDbkQsT0FBT29DO2dCQUNQb0IsYUFBYSxhQUE0QixPQUFmTCxhQUFhLEdBQUU7WUFDM0M7WUFDQTtJQUNKO0lBRUEsTUFBTWdCLG9CQUFvQnJELFlBQVlzQixjQUFjaEIsU0FBUyxDQUFDLEVBQUU7SUFDaEVpQyxNQUFNL0UsSUFBSSxDQUFDO1FBQ1RpRixhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtRQUNwQ25ELE9BQU9tRTtRQUNQVCxlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtRQUN4Q0wsYUFBYTtRQUNiekMsVUFBVUssU0FBUyxDQUFDLEVBQUU7UUFDdEIwQyxlQUFlMUI7SUFDakI7SUFFQUEsZUFBZStCO0lBRWYsSUFBSyxJQUFJOUMsUUFBUSxHQUFHQSxTQUFTRixXQUFXRSxRQUFTO1FBQy9DLE1BQU0rQyxnQkFBZ0JyRSxTQUFTcUM7UUFDL0JpQixNQUFNL0UsSUFBSSxDQUFDO1lBQ1RpRixhQUFhLFFBQTRCbEMsT0FBcEI4QixhQUFhLEdBQUUsT0FBVyxPQUFOOUIsT0FBTTtZQUMvQ3JCLE9BQU9vRTtZQUNQVixlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtZQUN4Q0wsYUFBYTtZQUNiTSxlQUFlMUI7UUFDakI7UUFFQSxNQUFNaUMsaUJBQWlCcEUsVUFBVW1FO1FBQ2pDZixNQUFNL0UsSUFBSSxDQUFDO1lBQ1RpRixhQUFhLFFBQTRCbEMsT0FBcEI4QixhQUFhLEdBQUUsT0FBVyxPQUFOOUIsT0FBTTtZQUMvQ3JCLE9BQU9xRTtZQUNQWCxlQUFlO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFJO2dCQUFJO2dCQUFJO2dCQUFJO2FBQUc7WUFDeERGLGFBQWE7WUFDYk0sZUFBZU07UUFDakI7UUFFQSxJQUFJRTtRQUVKLElBQUlqRCxRQUFRRixXQUFXO1lBQ3JCLE1BQU1vRCxrQkFBa0I5RCxXQUFXNEQ7WUFDbkNoQixNQUFNL0UsSUFBSSxDQUFDO2dCQUNUaUYsYUFBYSxRQUE0QmxDLE9BQXBCOEIsYUFBYSxHQUFFLE9BQVcsT0FBTjlCLE9BQU07Z0JBQy9DckIsT0FBT3VFO2dCQUNQYixlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtnQkFDeENMLGFBQWE7Z0JBQ2JNLGVBQWVPO1lBQ2pCO1lBRUFqQyxlQUFldEIsWUFBWXlELGlCQUFpQm5ELFNBQVMsQ0FBQ0MsTUFBTTtZQUM1RGlELDhCQUE4QkM7UUFDaEMsT0FBTztZQUNMbkMsZUFBZXRCLFlBQVl1RCxnQkFBZ0JqRCxTQUFTLENBQUNDLE1BQU07WUFDM0RpRCw4QkFBOEJEO1FBQ2hDO1FBRUFoQixNQUFNL0UsSUFBSSxDQUFDO1lBQ1RpRixhQUFhLFFBQTRCbEMsT0FBcEI4QixhQUFhLEdBQUUsT0FBVyxPQUFOOUIsT0FBTTtZQUMvQ3JCLE9BQU9vQztZQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7WUFDeENMLGFBQWE7WUFDYnpDLFVBQVVLLFNBQVMsQ0FBQ0MsTUFBTTtZQUMxQnlDLGVBQWVRO1FBQ2pCO0lBQ0Y7SUFFQSxJQUFJUDtJQUVKLE9BQVFiO1FBQ047WUFDRWEsYUFBYTNCO1lBQ2I7UUFDRjtZQUNFMkIsYUFBYTNCLGFBQWEzQyxHQUFHLENBQUMsQ0FBQ0MsTUFBTTNCLElBQU0yQixPQUFPK0QsWUFBWSxDQUFDMUYsRUFBRTtZQUNqRXNGLE1BQU0vRSxJQUFJLENBQUM7Z0JBQ1RpRixhQUFhLFFBQXVCLE9BQWZKLGFBQWEsR0FBRTtnQkFDcENuRCxPQUFPK0Q7Z0JBQ1BMLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO2dCQUN4Q0wsYUFBYSxhQUE0QixPQUFmTCxhQUFhLEdBQUU7Z0JBQ3pDVyxlQUFlTDtnQkFDZjFDLFVBQVVxQjtZQUNaO1lBQ0E7UUFDRjtZQUNFMkIsYUFBYTNCO1lBQ2I7SUFDSjtJQUVBaUIsTUFBTS9FLElBQUksQ0FBQztRQUNUaUYsYUFBYSxRQUF1QixPQUFmSixhQUFhLEdBQUU7UUFDcENuRCxPQUFPK0Q7UUFDUFAsYUFBYSxRQUF1QixPQUFmTCxhQUFhLEdBQUU7SUFDdEM7SUFFQSxPQUFPO1FBQUVFO1FBQU9VO0lBQVc7QUFDN0IsRUFBRTtBQUVLLE1BQU1TLGNBQWMsU0FDekJyQyxXQUNBekQ7UUFDQXdFLCtFQUNBWixvRkFDQW1DO0lBV0EsTUFBTXBCLFFBQW1CLEVBQUU7SUFDM0IsSUFBSUwsS0FBMkJ5QixhQUFhO1dBQUlBO0tBQVcsR0FBR0M7SUFFOUQsOEJBQThCO0lBQzlCLE1BQU1oQyxTQUFTTCxhQUFhRixXQUFXRztJQUN2QyxNQUFNcUMsWUFBOEUsRUFBRTtJQUV0Riw2REFBNkQ7SUFDN0QsSUFBSXJCLGlCQUFpQlosTUFBTSxDQUFDLEVBQUUsSUFBSW5GLFlBQVk0RTtJQUM5Q2tCLE1BQU0vRSxJQUFJLENBQUM7UUFDVGlGLGFBQWE7UUFDYnZELE9BQU9zRDtRQUNQRSxhQUFhLGVBQXlCLE9BQVZyQixXQUFVO0lBQ3hDO0lBRUEsMEJBQTBCO0lBQzFCLElBQUlHLDBCQUFtQztRQUNyQ2dCLGlCQUFpQmIscUJBQXFCYTtRQUN0Q0QsTUFBTS9FLElBQUksQ0FBQztZQUNUaUYsYUFBYTtZQUNidkQsT0FBT3NEO1lBQ1BFLGFBQWE7UUFDZjtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ04sa0JBQXdCQSxjQUFtQixLQUFNLENBQUNGLElBQUk7UUFDekRBLEtBQUtEO1FBQ0wsSUFBSUwsT0FBT3pFLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCLGlFQUFpRTtZQUNqRSxNQUFNMkcsZ0JBQWdCMUIsaUJBQ2xCLHFEQUNBO1lBQ0osTUFBTTJCLGdCQUFnQixHQUEwRTNCLE9BQXZFQSxpQkFBdUIsUUFBUSxPQUFNLG9DQUF3RSxPQUF0Q0EsaUJBQXVCLE9BQU8sU0FBUTtZQUN0SUcsTUFBTS9FLElBQUksQ0FBQztnQkFDVGlGLGFBQWFxQjtnQkFDYjVFLE9BQU9nRDtnQkFDUFEsYUFBYXFCO1lBQ2Y7UUFDRjtJQUNGO0lBRUEsMkRBQTJEO0lBQzNELE1BQU1wQixlQUFlSDtJQUVyQixnQkFBZ0I7SUFDaEIsTUFBTWxDLFlBQVlKLGFBQWF0QztJQUUvQiw4QkFBOEI7SUFDOUIsSUFBSTBEO0lBRUosT0FBUWM7UUFDTjtZQUNFLElBQUksQ0FBQ0YsSUFBSUEsS0FBS0QsY0FBYyxXQUFXO1lBQ3ZDLHdCQUF3QjtZQUN4QlgsZUFBZXFCLGFBQWFoRSxHQUFHLENBQUMsQ0FBQ0MsTUFBTTNCLElBQU0yQixPQUFPc0QsRUFBRyxDQUFDakYsRUFBRTtZQUUxRHNGLE1BQU0vRSxJQUFJLENBQUM7Z0JBQ1RpRixhQUFhO2dCQUNidkQsT0FBT29DO2dCQUNQc0IsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDQyxlQUFlTDtnQkFDZjFDLFVBQVVpQztnQkFDVlEsYUFBYztZQUNoQjtZQUNBO1FBQ0Y7WUFDRSxtRUFBbUU7WUFDbkUsTUFBTXNCLFVBQVU5QixNQUFNRDtZQUN0QixJQUFJLENBQUNDLElBQUlBLEtBQUs4QjtZQUVkekIsTUFBTS9FLElBQUksQ0FBQztnQkFDVGlGLGFBQWE7Z0JBQ2J2RCxPQUFPOEU7Z0JBQ1B0QixhQUFhO1lBQ2Y7WUFFQXBCLGVBQWUwQztZQUNmO1FBQ0Y7WUFDRTFDLGVBQWVxQjtZQUNmSixNQUFNL0UsSUFBSSxDQUFDO2dCQUNUaUYsYUFBYTtnQkFDYnZELE9BQU9vQztnQkFDUG9CLGFBQWE7WUFDZjtZQUNBO0lBQ0o7SUFFQSw2Q0FBNkM7SUFDN0MsTUFBTVcsb0JBQW9CckQsWUFBWXNCLGNBQWNoQixTQUFTLENBQUMsRUFBRTtJQUNoRWlDLE1BQU0vRSxJQUFJLENBQUM7UUFDVGlGLGFBQWE7UUFDYnZELE9BQU9tRTtRQUNQVCxlQUFlQyxNQUFNQyxJQUFJLENBQUNELE1BQU0sSUFBSUUsSUFBSTtRQUN4Q0wsYUFBYTtRQUNiekMsVUFBVUssU0FBUyxDQUFDLEVBQUU7UUFDdEIwQyxlQUFlMUI7SUFDakI7SUFFQUEsZUFBZStCO0lBRWYsY0FBYztJQUNkLElBQUssSUFBSTlDLFFBQVEsR0FBR0EsU0FBUyxJQUFJQSxRQUFTO1FBQ3hDLFdBQVc7UUFDWCxNQUFNK0MsZ0JBQWdCckUsU0FBU3FDO1FBQy9CaUIsTUFBTS9FLElBQUksQ0FBQztZQUNUaUYsYUFBYSxHQUFTLE9BQU5sQyxPQUFNO1lBQ3RCckIsT0FBT29FO1lBQ1BWLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO1lBQ3hDTCxhQUFhO1lBQ2JNLGVBQWUxQixhQUFhLHNDQUFzQztRQUNwRTtRQUVBLFlBQVk7UUFDWixNQUFNaUMsaUJBQWlCcEUsVUFBVW1FO1FBQ2pDZixNQUFNL0UsSUFBSSxDQUFDO1lBQ1RpRixhQUFhLEdBQVMsT0FBTmxDLE9BQU07WUFDdEJyQixPQUFPcUU7WUFDUFgsZUFBZTtnQkFBQztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBSTtnQkFBSTtnQkFBSTtnQkFBSTthQUFHO1lBQ3hERixhQUFhO1lBQ2JNLGVBQWVNLGNBQWMsb0NBQW9DO1FBQ25FO1FBRUEsSUFBSUU7UUFFSixJQUFJakQsUUFBUSxJQUFJO1lBQ2Qsa0NBQWtDO1lBQ2xDLE1BQU1rRCxrQkFBa0I5RCxXQUFXNEQ7WUFDbkNoQixNQUFNL0UsSUFBSSxDQUFDO2dCQUNUaUYsYUFBYSxHQUFTLE9BQU5sQyxPQUFNO2dCQUN0QnJCLE9BQU91RTtnQkFDUGIsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDTCxhQUFhO2dCQUNiTSxlQUFlTyxlQUFlLCtDQUErQztZQUMvRTtZQUVBLGNBQWM7WUFDZGpDLGVBQWV0QixZQUFZeUQsaUJBQWlCbkQsU0FBUyxDQUFDQyxNQUFNO1lBQzVEaUQsOEJBQThCQztRQUNoQyxPQUFPO1lBQ0wsZ0NBQWdDO1lBQ2hDbkMsZUFBZXRCLFlBQVl1RCxnQkFBZ0JqRCxTQUFTLENBQUNDLE1BQU07WUFDM0RpRCw4QkFBOEJEO1FBQ2hDO1FBRUFoQixNQUFNL0UsSUFBSSxDQUFDO1lBQ1RpRixhQUFhLEdBQVMsT0FBTmxDLE9BQU07WUFDdEJyQixPQUFPb0M7WUFDUHNCLGVBQWVDLE1BQU1DLElBQUksQ0FBQ0QsTUFBTSxJQUFJRSxJQUFJO1lBQ3hDTCxhQUFhO1lBQ2J6QyxVQUFVSyxTQUFTLENBQUNDLE1BQU07WUFDMUJ5QyxlQUFlUTtRQUNqQjtJQUNGO0lBRUEsNkJBQTZCO0lBQzdCLElBQUlQO0lBRUosT0FBUWI7UUFDTjtZQUNFLDZEQUE2RDtZQUM3RGEsYUFBYTNCO1lBQ2I7UUFDRjtZQUNFLDJDQUEyQztZQUMzQzJCLGFBQWEzQixhQUFhM0MsR0FBRyxDQUFDLENBQUNDLE1BQU0zQixJQUFNMkIsT0FBTytELFlBQVksQ0FBQzFGLEVBQUU7WUFDakVzRixNQUFNL0UsSUFBSSxDQUFDO2dCQUNUaUYsYUFBYTtnQkFDYnZELE9BQU8rRDtnQkFDUEwsZUFBZUMsTUFBTUMsSUFBSSxDQUFDRCxNQUFNLElBQUlFLElBQUk7Z0JBQ3hDTCxhQUFhO2dCQUNiTSxlQUFlTDtnQkFDZjFDLFVBQVVxQjtZQUNaO1lBQ0E7UUFDRjtZQUNFMkIsYUFBYTNCO1lBQ2I7SUFDSjtJQUVBaUIsTUFBTS9FLElBQUksQ0FBQztRQUNUaUYsYUFBYTtRQUNidkQsT0FBTytEO1FBQ1BQLGFBQWEsR0FBUSxPQUFMTixNQUFLO0lBQ3ZCO0lBRUEsNkNBQTZDO0lBQzdDLElBQUlFO0lBQ0osTUFBTTJCLHNCQUFnQyxFQUFFO0lBRXhDLHdCQUF3QjtJQUN4QixJQUFJLENBQUM3QixrQkFBd0JBLGNBQW1CLEtBQU0sQ0FBQ0YsSUFBSTtRQUN6REEsS0FBS0Q7SUFDUDtJQUVBLElBQUssSUFBSUksYUFBYSxHQUFHQSxhQUFhVCxPQUFPekUsTUFBTSxFQUFFa0YsYUFBYztRQUNqRSxNQUFNNkIsY0FBYy9CLG9CQUNsQlAsTUFBTSxDQUFDUyxXQUFXLEVBQ2xCekUsS0FDQXdFLE1BQ0FDLFlBQ0FDLHlCQUNBSjtRQUdGMkIsVUFBVXJHLElBQUksQ0FBQztZQUNiNkU7WUFDQUUsT0FBTzJCLFlBQVkzQixLQUFLO1lBQ3hCVSxZQUFZaUIsWUFBWWpCLFVBQVU7UUFDcEM7UUFFQWdCLG9CQUFvQnpHLElBQUksSUFBSTBHLFlBQVlqQixVQUFVO1FBRWxELGtFQUFrRTtRQUNsRSxJQUFJYixnQkFBc0I7WUFDeEJFLDBCQUEwQjRCLFlBQVlqQixVQUFVO1FBQ2xEO0lBQ0Y7SUFFQSwwRkFBMEY7SUFDMUYsTUFBTWtCLGtCQUFrQnZDLE9BQU96RSxNQUFNLEdBQUcsSUFBSThHLHNCQUFzQmhCO0lBRWxFLHlEQUF5RDtJQUN6RCxNQUFNbUIsaUJBQWlCdkksb0RBQVksQ0FBQ3lJLFNBQVMsQ0FBQ0MsTUFBTSxDQUNsRCxJQUFJQyxXQUFXTDtJQUdqQixNQUFNTSx3QkFBd0I1SSxvREFBWSxDQUFDNkksTUFBTSxDQUFDQyxTQUFTLENBQUNQO0lBQzVELE1BQU1RLHFCQUFxQi9JLG9EQUFZLENBQUNnSixHQUFHLENBQUNGLFNBQVMsQ0FBQ1A7SUFDdEQsTUFBTVUsd0JBQXdCOUYsY0FBY21GLGlCQUFpQjtJQUU3RCxPQUFPO1FBQ0w1QjtRQUNBd0MsaUJBQWlCO1lBQ2ZDLFFBQVFQO1lBQ1JRLEtBQUtMO1lBQ0xNLFFBQVFKO1FBQ1Y7UUFDQTVDO1FBQ0EyQixXQUFXQSxVQUFVMUcsTUFBTSxHQUFHLElBQUkwRyxZQUFZRDtJQUNoRDtBQUNGLEVBQUU7QUFFRixxREFBcUQ7QUFDOUMsTUFBTXVCLHVCQUF1QixDQUFDdkg7SUFNbkMsTUFBTTBDLFlBQVlKLGFBQWF0QztJQUMvQixNQUFNMkUsUUFBUSxFQUFFO0lBRWhCQSxNQUFNL0UsSUFBSSxDQUFDO1FBQ1RpRixhQUFhO1FBQ2I3RSxLQUFLMEMsU0FBUyxDQUFDLEVBQUU7UUFDakJvQyxhQUFhO0lBQ2Y7SUFFQSxJQUFLLElBQUluQyxRQUFRLEdBQUdBLFNBQVMsSUFBSUEsUUFBUztRQUN4QyxNQUFNQyxVQUFVRixTQUFTLENBQUNDLFFBQVEsRUFBRTtRQUNwQyxNQUFNNkUsYUFBYTlFLFNBQVMsQ0FBQ0MsTUFBTTtRQUVuQyxnRUFBZ0U7UUFDaEUsTUFBTUksV0FBVztZQUFDSCxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztZQUFFQSxPQUFPLENBQUMsR0FBRztTQUFDO1FBQ3JFLE1BQU1JLFVBQVU7WUFBQ0QsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7WUFBRUEsUUFBUSxDQUFDLEVBQUU7U0FBQztRQUNwRSxNQUFNMEUsV0FBV3pFLFFBQVFqQyxHQUFHLENBQUNDLENBQUFBLE9BQVF2QyxJQUFJLENBQUN1QyxLQUFLO1FBQy9DLE1BQU0wRyxZQUFZaEosSUFBSSxDQUFDaUUsTUFBTTtRQUM3QixNQUFNZ0Ysa0JBQWtCO2VBQUlGO1NBQVM7UUFDckNFLGVBQWUsQ0FBQyxFQUFFLElBQUlEO1FBQ3RCLHFGQUFxRjtRQUNyRixNQUFNRSxnQkFBZ0I7WUFBQ2hGLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1NBQUM7UUFDdEUsTUFBTWlGLFlBQVlELGNBQWM3RyxHQUFHLENBQUMsQ0FBQ0MsTUFBTThHLFFBQVU5RyxPQUFPMkcsZUFBZSxDQUFDRyxNQUFNO1FBR2xGLHVEQUF1RDtRQUN2RG5ELE1BQU0vRSxJQUFJLENBQUM7WUFDVGlGLGFBQWEsZ0JBQXNCLE9BQU5sQztZQUM3QjNDLEtBQUt3SDtZQUNMMUMsYUFBYSxhQUV3Qy9CLE9BRGpESixPQUFNLDBHQUVrQkssT0FEeUJELFNBQVNoQyxHQUFHLENBQUNnSCxDQUFBQSxJQUFLQSxFQUFFOUcsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQyxPQUFNLHVDQUVsRXNHLE9BRHJCekUsUUFBUWpDLEdBQUcsQ0FBQ2dILENBQUFBLElBQUtBLEVBQUU5RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sNERBRTdDdUcsT0FES0QsU0FBUzFHLEdBQUcsQ0FBQ2dILENBQUFBLElBQUtBLEVBQUU5RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sdURBRWhHd0csT0FENkJELFVBQVV6RyxRQUFRLENBQUMsS0FBSSx1Q0FFeEIyRyxPQUQ1QkQsZ0JBQWdCNUcsR0FBRyxDQUFDZ0gsQ0FBQUEsSUFBS0EsRUFBRTlHLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUMsT0FBTSxzREFDd0V3RyxPQUFqSEMsY0FBYzdHLEdBQUcsQ0FBQ2dILENBQUFBLElBQUtBLEVBQUU5RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sZ0RBQW1JMEcsT0FBckZGLGdCQUFnQjVHLEdBQUcsQ0FBQ2dILENBQUFBLElBQUtBLEVBQUU5RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU0sa0JBQStFLE9BQS9EMEcsVUFBVTlHLEdBQUcsQ0FBQ2dILENBQUFBLElBQUtBLEVBQUU5RyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDLE9BQU07WUFFaFQ2RyxrQkFBa0I7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRSxDQUFDLHVEQUF1RDtRQUN4RjtJQUNGO0lBRUEsT0FBT3JEO0FBQ1QsRUFBRTtBQUVGLHNFQUFzRTtBQUMvRCxTQUFTc0QsNEJBQTRCakksR0FBYTtRQUFFekIsWUFBQUE7SUFDekQsTUFBTWlFLFdBQVd4QyxJQUFJVCxNQUFNLEdBQUc7SUFDOUIsTUFBTWtELFlBQVlsRSxvQkFBa0MsS0FBS0Esb0JBQWtDLEtBQUs7SUFFaEcsOEJBQThCO0lBQzlCLElBQUlxRSxVQUFVNUMsSUFBSUYsS0FBSztJQUN2QixJQUFJNEMsWUFBWTtRQUFDRSxRQUFROUMsS0FBSztLQUFHO0lBRWpDLHFEQUFxRDtJQUNyRCxJQUFJb0ksZ0JBQWdCLEVBQUU7SUFFdEIsSUFBSyxJQUFJdkYsUUFBUSxHQUFHQSxTQUFTRixXQUFXRSxRQUFTO1FBQy9DLElBQUl3RixjQUFjLEVBQUU7UUFDcEIsSUFBSXRGLFNBQVNELFFBQVE5QyxLQUFLO1FBQzFCLE1BQU1nRCxZQUFZRixRQUFRckQsTUFBTSxHQUFHO1FBQ25DLE1BQU13RCxXQUFXO1lBQUNILE9BQU8sQ0FBQ0UsVUFBVTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtZQUFFRixPQUFPLENBQUNFLFlBQVksRUFBRTtTQUFDO1FBRTdHLGtCQUFrQjtRQUNsQixNQUFNRSxVQUFVO1lBQUNELFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1NBQUM7UUFDcEVvRixZQUFZdkksSUFBSSxDQUFDO1lBQ2Z3SSxNQUFNO1lBQVdDLE9BQU90RixTQUFTakQsS0FBSztZQUFJd0ksUUFBUXRGLFFBQVFsRCxLQUFLO1FBQ2pFO1FBQ0EsMkJBQTJCO1FBQzNCLE1BQU0ySCxXQUFXekUsUUFBUWpDLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUXZDLElBQUksQ0FBQ3VDLEtBQUs7UUFDL0NtSCxZQUFZdkksSUFBSSxDQUFDO1lBQ2Z3SSxNQUFNO1lBQVlDLE9BQU9yRixRQUFRbEQsS0FBSztZQUFJd0ksUUFBUWIsU0FBUzNILEtBQUs7UUFDbEU7UUFDQSw2QkFBNkI7UUFDN0IsTUFBTTRILFlBQVloSixJQUFJLENBQUNpRSxNQUFNO1FBQzdCLE1BQU00RixXQUFXZCxTQUFTM0gsS0FBSztRQUMvQnlJLFFBQVEsQ0FBQyxFQUFFLElBQUliO1FBQ2ZTLFlBQVl2SSxJQUFJLENBQUM7WUFDZndJLE1BQU07WUFBY0MsT0FBT1osU0FBUzNILEtBQUs7WUFBSTBJLE1BQU1kO1lBQVdZLFFBQVFDLFNBQVN6SSxLQUFLO1FBQ3RGO1FBQ0EseUNBQXlDO1FBQ3pDLE1BQU0rSCxZQUFZO1lBQ2hCakYsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1lBQ3hCM0YsT0FBTyxDQUFDLEVBQUUsR0FBRzJGLFFBQVEsQ0FBQyxFQUFFO1NBQ3pCO1FBQ0RKLFlBQVl2SSxJQUFJLENBQUM7WUFDZndJLE1BQU07WUFBcUJLLFFBQVE7Z0JBQUM3RixRQUFROUMsS0FBSyxDQUFDLEdBQUU7Z0JBQUl5SSxTQUFTekksS0FBSzthQUFHO1lBQUV3SSxRQUFRVCxVQUFVL0gsS0FBSztRQUNwRztRQUNBLHlCQUF5QjtRQUN6QitDLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QmhGLE1BQU0sQ0FBQyxFQUFFLEdBQUdnRixTQUFTLENBQUMsRUFBRTtRQUN4QixnQ0FBZ0M7UUFDaEMsSUFBSyxJQUFJeEksSUFBSSxHQUFHQSxJQUFJbUQsVUFBVW5ELElBQUs7WUFDakMsTUFBTTZELFNBQVM3RCxJQUFJO1lBQ25Cd0QsTUFBTSxDQUFDSyxPQUFPLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sT0FBTztZQUNyREwsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR0wsTUFBTSxDQUFDSyxTQUFTLEVBQUUsR0FBR04sT0FBTyxDQUFDTSxTQUFTLEVBQUU7WUFDN0RMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdMLE1BQU0sQ0FBQ0ssU0FBUyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ00sU0FBUyxFQUFFO1lBQzdETCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTCxNQUFNLENBQUNLLFNBQVMsRUFBRSxHQUFHTixPQUFPLENBQUNNLFNBQVMsRUFBRTtZQUM3RGlGLFlBQVl2SSxJQUFJLENBQUM7Z0JBQ2Z3SSxNQUFNO2dCQUFhSyxRQUFRO29CQUN6QjVGLE9BQU8vQyxLQUFLLENBQUNvRCxTQUFTLEdBQUdBO29CQUN6Qk4sUUFBUTlDLEtBQUssQ0FBQ29ELFFBQVFBLFNBQVM7aUJBQ2hDO2dCQUFFb0YsUUFBUXpGLE9BQU8vQyxLQUFLLENBQUNvRCxRQUFRQSxTQUFTO2dCQUFJd0YsV0FBV3JKO1lBQzFEO1FBQ0Y7UUFDQTZJLGNBQWN0SSxJQUFJLENBQUM7WUFBRStDO1lBQU93RjtZQUFhOUYsVUFBVVEsT0FBTy9DLEtBQUs7UUFBRztRQUNsRThDLFVBQVVDLE9BQU8vQyxLQUFLO1FBQ3RCNEMsVUFBVTlDLElBQUksQ0FBQ2dEO0lBQ2pCO0lBQ0EsT0FBT3NGO0FBQ1Q7QUFFQSxzREFBc0Q7QUFDL0MsTUFBTVMsaUJBQWlCLFNBQzVCbEYsV0FDQXpEO1FBQ0F3RSwrRUFDQVosb0ZBQ0FnRiwwRkFDQXJLLGtGQUNBc0s7SUFFQSw4REFBOEQ7SUFDOUQsTUFBTTFJLFdBQVdILElBQUlJLE9BQU8sQ0FBQyxPQUFPO0lBQ3BDLElBQUkwSSxTQUFTM0ksU0FBU1osTUFBTSxHQUFHLE1BQU0sSUFBSVksV0FBVyxNQUFNQTtJQUUxRCw4REFBOEQ7SUFDOUQsTUFBTTRJLG1CQUFtQnhLLFlBQVksR0FBRywwQkFBMEI7SUFDbEUsSUFBSXVLLE9BQU92SixNQUFNLEdBQUd3SixrQkFBa0I7UUFDcEMsdUJBQXVCO1FBQ3ZCRCxTQUFTQSxPQUFPRSxNQUFNLENBQUNELGtCQUFrQjtJQUMzQyxPQUFPLElBQUlELE9BQU92SixNQUFNLEdBQUd3SixrQkFBa0I7UUFDM0MsMkJBQTJCO1FBQzNCRCxTQUFTQSxPQUFPRyxTQUFTLENBQUMsR0FBR0Y7SUFDL0I7SUFFQSxNQUFNRyxlQUFlakwsb0RBQVksQ0FBQ2dKLEdBQUcsQ0FBQy9ILEtBQUssQ0FBQzRKO0lBRTVDLElBQUlLO0lBQ0osT0FBUXZGO1FBQ047WUFDRXVGLGdCQUFnQjtnQkFBRXZGLFNBQVMzRixzREFBWSxDQUFDb0wsUUFBUTtZQUFDO1lBQ2pEO1FBQ0Y7WUFDRUYsZ0JBQWdCO2dCQUFFdkYsU0FBUzNGLHNEQUFZLENBQUNxTCxTQUFTO1lBQUM7WUFDbEQ7UUFDRjtZQUNFSCxnQkFBZ0IsQ0FBQyxHQUFHLG1CQUFtQjtJQUMzQztJQUVBLElBQUlJO0lBQ0osSUFBSWpGO0lBRUosT0FBUUU7UUFDTjtZQUNFLElBQUlxRSxVQUFVO2dCQUNadkUsS0FBS3JHLG9EQUFZLENBQUNnSixHQUFHLENBQUMvSCxLQUFLLENBQUMySixTQUFTekksT0FBTyxDQUFDLE9BQU87WUFDdEQsT0FBTztnQkFDTGtFLEtBQUtyRyxvREFBWSxDQUFDeUksU0FBUyxDQUFDOUYsTUFBTSxDQUFDO1lBQ3JDO1lBQ0EySSxhQUFhO2dCQUNYL0UsTUFBTXZHLHVEQUFhLENBQUN1TCxHQUFHO2dCQUN2QmxGLElBQUlBO2dCQUNKLEdBQUc2RSxhQUFhO1lBQ2xCO1lBQ0E7UUFDRjtZQUNFLElBQUlOLFVBQVU7Z0JBQ1p2RSxLQUFLckcsb0RBQVksQ0FBQ2dKLEdBQUcsQ0FBQy9ILEtBQUssQ0FBQzJKLFNBQVN6SSxPQUFPLENBQUMsT0FBTztZQUN0RCxPQUFPO2dCQUNMa0UsS0FBS3JHLG9EQUFZLENBQUN5SSxTQUFTLENBQUM5RixNQUFNLENBQUM7WUFDckM7WUFDQTJJLGFBQWE7Z0JBQ1gvRSxNQUFNdkcsdURBQWEsQ0FBQ3dMLEdBQUc7Z0JBQ3ZCbkYsSUFBSUE7Z0JBQ0o4QixTQUFTbkksb0RBQVksQ0FBQ3lJLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDO29CQUFDO29CQUFHO29CQUFHO29CQUFHO2lCQUFFLEVBQUU7Z0JBQ3JELEdBQUd3QyxhQUFhO1lBQ2xCO1lBQ0E7UUFDRjtZQUNFSSxhQUFhO2dCQUNYL0UsTUFBTXZHLHVEQUFhLENBQUN5TCxHQUFHO2dCQUN2QixHQUFHUCxhQUFhO1lBQ2xCO1lBQ0E7SUFDSjtJQUVBLE1BQU1RLFlBQVkxTCxvREFBWSxDQUFDNEwsT0FBTyxDQUFDcEcsV0FBV3lGLGNBQWNLO0lBRWhFLHlCQUF5QjtJQUN6QixNQUFNTyxlQUFlSCxVQUFVMUksUUFBUTtJQUN2QyxNQUFNOEksZUFBZTlMLG9EQUFZLENBQUMrTCxZQUFZLENBQUNyRCxNQUFNLENBQUM7UUFDcERzRCxZQUFZaE0sb0RBQVksQ0FBQzZJLE1BQU0sQ0FBQzVILEtBQUssQ0FBQzRLO0lBQ3hDO0lBQ0EsTUFBTUksWUFBWWpNLHVEQUFlLENBQUNnSixHQUFHLENBQUNGLFNBQVMsQ0FBQ2dEO0lBRWhELG1EQUFtRDtJQUNuRCxNQUFNSyxXQUFXRixVQUFVRyxLQUFLLENBQUMsU0FBVXRKLEdBQUcsQ0FBQ3NHLENBQUFBLE1BQU85RyxTQUFTOEcsS0FBSztJQUNwRSxNQUFNaUQsZUFBZWxKLGNBQWNnSixVQUFVO0lBRTdDLGlEQUFpRDtJQUNqRCxJQUFJRztJQUNKLE9BQVEzQjtRQUNOO1lBQ0UyQixnQkFBZ0JMO1lBQ2hCO1FBQ0Y7WUFDRUssZ0JBQWdCRDtZQUNoQjtRQUNGO1lBQ0VDLGdCQUFnQlQ7WUFDaEI7SUFDSjtJQUVBLE9BQU87UUFDTEcsWUFBWU07UUFDWmpHLElBQUlBLEtBQUtyRyxvREFBWSxDQUFDZ0osR0FBRyxDQUFDRixTQUFTLENBQUN6QyxNQUFNMEI7UUFDMUN3RSxTQUFTO1lBQ1BwRCxRQUFRMEM7WUFDUnpDLEtBQUs2QztZQUNMNUMsUUFBUWdEO1FBQ1Y7SUFDRjtBQUNGLEVBQUU7QUFFRixxQ0FBcUM7QUFDOUIsTUFBTUcsaUJBQWlCLFNBQzVCUixZQUNBaks7UUFDQXdFLCtFQUNBWixvRkFDQThHLHlGQUNBbk0sa0ZBQ0FzSztJQUVBLElBQUk7UUFDRiw4REFBOEQ7UUFDOUQsTUFBTTFJLFdBQVdILElBQUlJLE9BQU8sQ0FBQyxPQUFPO1FBQ3BDLElBQUkwSSxTQUFTM0ksU0FBU1osTUFBTSxHQUFHLE1BQU0sSUFBSVksV0FBVyxNQUFNQTtRQUUxRCw4REFBOEQ7UUFDOUQsTUFBTTRJLG1CQUFtQnhLLFlBQVksR0FBRywwQkFBMEI7UUFDbEUsSUFBSXVLLE9BQU92SixNQUFNLEdBQUd3SixrQkFBa0I7WUFDcEMsdUJBQXVCO1lBQ3ZCRCxTQUFTQSxPQUFPRSxNQUFNLENBQUNELGtCQUFrQjtRQUMzQyxPQUFPLElBQUlELE9BQU92SixNQUFNLEdBQUd3SixrQkFBa0I7WUFDM0MsMkJBQTJCO1lBQzNCRCxTQUFTQSxPQUFPRyxTQUFTLENBQUMsR0FBR0Y7UUFDL0I7UUFFQSxNQUFNRyxlQUFlakwsb0RBQVksQ0FBQ2dKLEdBQUcsQ0FBQy9ILEtBQUssQ0FBQzRKO1FBRTVDLHlDQUF5QztRQUN6QyxJQUFJNkI7UUFDSixPQUFRRDtZQUNOO2dCQUNFQyxzQkFBc0IxTSxvREFBWSxDQUFDZ0osR0FBRyxDQUFDL0gsS0FBSyxDQUFDK0ssV0FBVzdKLE9BQU8sQ0FBQyxPQUFPO2dCQUN2RTtZQUNGO29CQUV3QjZKO2dCQUR0QixxQ0FBcUM7Z0JBQ3JDLE1BQU1XLGdCQUFnQlgsRUFBQUEsNEJBQUFBLFdBQVc3SixPQUFPLENBQUMsT0FBTyxJQUFJaUssS0FBSyxDQUFDLHNCQUFwQ0osZ0RBQUFBLDBCQUE4Q2xKLEdBQUcsQ0FBQzhKLENBQUFBLE1BQU90SyxTQUFTc0ssS0FBSyxHQUFHNUosUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQyxRQUFPO2dCQUMzSXdKLHNCQUFzQjFNLG9EQUFZLENBQUNnSixHQUFHLENBQUMvSCxLQUFLLENBQUMwTDtnQkFDN0M7WUFDRjtnQkFDRUQsc0JBQXNCMU0sb0RBQVksQ0FBQzZJLE1BQU0sQ0FBQzVILEtBQUssQ0FBQytLO2dCQUNoRDtRQUNKO1FBRUEsSUFBSWQ7UUFDSixPQUFRdkY7WUFDTjtnQkFDRXVGLGdCQUFnQjtvQkFBRXZGLFNBQVMzRixzREFBWSxDQUFDb0wsUUFBUTtnQkFBQztnQkFDakQ7WUFDRjtnQkFDRUYsZ0JBQWdCO29CQUFFdkYsU0FBUzNGLHNEQUFZLENBQUNxTCxTQUFTO2dCQUFDO2dCQUNsRDtZQUNGO2dCQUNFSCxnQkFBZ0IsQ0FBQyxHQUFHLG1CQUFtQjtRQUMzQztRQUVBLElBQUlJO1FBQ0osSUFBSWpGO1FBRUosT0FBUUU7WUFDTjtnQkFDRSxJQUFJLENBQUNxRSxVQUFVO29CQUNiLE9BQU87d0JBQUVwRixXQUFXO3dCQUFJcUgsT0FBTztvQkFBNEI7Z0JBQzdEO2dCQUNBeEcsS0FBS3JHLG9EQUFZLENBQUNnSixHQUFHLENBQUMvSCxLQUFLLENBQUMySixTQUFTekksT0FBTyxDQUFDLE9BQU87Z0JBQ3BEbUosYUFBYTtvQkFDWC9FLE1BQU12Ryx1REFBYSxDQUFDdUwsR0FBRztvQkFDdkJsRixJQUFJQTtvQkFDSixHQUFHNkUsYUFBYTtnQkFDbEI7Z0JBQ0E7WUFDRjtnQkFDRSxJQUFJLENBQUNOLFVBQVU7b0JBQ2IsT0FBTzt3QkFBRXBGLFdBQVc7d0JBQUlxSCxPQUFPO29CQUFvQztnQkFDckU7Z0JBQ0F4RyxLQUFLckcsb0RBQVksQ0FBQ2dKLEdBQUcsQ0FBQy9ILEtBQUssQ0FBQzJKLFNBQVN6SSxPQUFPLENBQUMsT0FBTztnQkFDcERtSixhQUFhO29CQUNYL0UsTUFBTXZHLHVEQUFhLENBQUN3TCxHQUFHO29CQUN2Qm5GLElBQUlBO29CQUNKOEIsU0FBU25JLG9EQUFZLENBQUN5SSxTQUFTLENBQUNDLE1BQU0sQ0FBQzt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRSxFQUFFO29CQUNyRCxHQUFHd0MsYUFBYTtnQkFDbEI7Z0JBQ0E7WUFDRjtnQkFDRUksYUFBYTtvQkFDWC9FLE1BQU12Ryx1REFBYSxDQUFDeUwsR0FBRztvQkFDdkIsR0FBR1AsYUFBYTtnQkFDbEI7Z0JBQ0E7UUFDSjtRQUVBLE1BQU00QixZQUFZOU0sb0RBQVksQ0FBQytNLE9BQU8sQ0FDcEM7WUFBRWYsWUFBWVU7UUFBb0IsR0FDbEN6QixjQUNBSztRQUdGLE1BQU05RixZQUFZc0gsVUFBVTlKLFFBQVEsQ0FBQ2hELHNEQUFZLENBQUNnQixJQUFJO1FBRXRELElBQUksQ0FBQ3dFLFdBQVc7WUFDZCxPQUFPO2dCQUFFQSxXQUFXO2dCQUFJcUgsT0FBTztZQUF3RTtRQUN6RztRQUVBLE9BQU87WUFBRXJIO1FBQVU7SUFDckIsRUFBRSxPQUFPcUgsT0FBWTtRQUNuQixPQUFPO1lBQUVySCxXQUFXO1lBQUlxSCxPQUFPQSxNQUFNRyxPQUFPLElBQUk7UUFBa0M7SUFDcEY7QUFDRixFQUFFO0FBRUYsa0dBQWtHO0FBQzNGLE1BQU1DLG1CQUFtQjtJQUM5QixNQUFNekgsWUFBWTtJQUNsQixNQUFNekQsTUFBTTtJQUVaLHNDQUFzQztJQUN0QyxNQUFNVSxXQUFXLEVBQUU7SUFDbkIsSUFBSyxJQUFJckIsSUFBSSxHQUFHQSxJQUFJVyxJQUFJVCxNQUFNLEVBQUVGLEtBQUssRUFBRztRQUN0Q3FCLFNBQVNkLElBQUksQ0FBQ1csU0FBU1AsSUFBSVEsTUFBTSxDQUFDbkIsR0FBRyxJQUFJO0lBQzNDO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU0sRUFBRThILGVBQWUsRUFBRSxHQUFHckIsWUFBWXJDLFdBQVcvQztJQUVuRCw4QkFBOEI7SUFDOUIsTUFBTXlLLGVBQWV4QyxlQUFlbEYsV0FBV3pEO0lBRS9DLE9BQU8sMkNBRStCbUwsT0FEQWhFLGdCQUFnQkUsR0FBRyxFQUFDLDRDQUNLLE9BQXpCOEQsYUFBYVgsT0FBTyxDQUFDbkQsR0FBRyxFQUFDO0FBR2pFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdmljdHVzXFxEZXNrdG9wXFxhZXNcXEZpbmFsIEFFU1xcYWVzXFxzcmNcXHV0aWxzXFxhZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5cbi8vIEFFUyBtb2RlIGVudW1cbmV4cG9ydCBlbnVtIEFlc01vZGUge1xuICBFQ0IgPSAnRUNCJyxcbiAgQ0JDID0gJ0NCQycsXG4gIENUUiA9ICdDVFInXG59XG5cbi8vIFBhZGRpbmcgZW51bVxuZXhwb3J0IGVudW0gUGFkZGluZ1R5cGUge1xuICBQS0NTNyA9ICdQS0NTNycsXG4gIEFOU0lfWDkyMyA9ICdBTlNJIFguOTIzJyxcbiAgTk9ORSA9ICdOb25lJ1xufVxuXG4vLyBPdXRwdXQgZm9ybWF0IGVudW1cbmV4cG9ydCBlbnVtIE91dHB1dEZvcm1hdCB7XG4gIEJBU0U2NCA9ICdCYXNlNjQnLFxuICBIRVggPSAnSGV4JyxcbiAgQklOQVJZID0gJ0JpbmFyeSdcbn1cblxuLy8gS2V5IGxlbmd0aCBlbnVtXG5leHBvcnQgZW51bSBLZXlMZW5ndGgge1xuICBBRVNfMTI4ID0gMTI4LFxuICBBRVNfMTkyID0gMTkyLFxuICBBRVNfMjU2ID0gMjU2XG59XG5cbmNvbnN0IGdldE51bVJvdW5kcyA9IChrZXlMZW5ndGg6IEtleUxlbmd0aCk6IG51bWJlciA9PiAoXG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xMjggPyAxMCA6XG4gIGtleUxlbmd0aCA9PT0gS2V5TGVuZ3RoLkFFU18xOTIgPyAxMiA6IDE0XG4pO1xuXG5jb25zdCBnZXRLZXlCeXRlTGVuZ3RoID0gKGtleUxlbmd0aDogS2V5TGVuZ3RoKTogbnVtYmVyID0+IGtleUxlbmd0aCAvIDg7XG5cbi8vIEFFUyBTLUJveCAoU3RhbmRhcmQgUmlqbmRhZWwgUy1ib3gpXG5leHBvcnQgY29uc3QgU0JPWCA9IFtcbiAgMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NixcbiAgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCxcbiAgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSxcbiAgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSxcbiAgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCxcbiAgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZixcbiAgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCxcbiAgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMixcbiAgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MyxcbiAgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYixcbiAgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSxcbiAgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCxcbiAgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSxcbiAgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSxcbiAgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZixcbiAgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNixcbl07XG5cbi8vIEFFUyBSY29uIChSb3VuZCBDb25zdGFudHMpXG5leHBvcnQgY29uc3QgUkNPTiA9IFtcbiAgMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSxcbl07XG5cbi8vIFVzZWQgaW4gTWl4Q29sdW1uc1xuZXhwb3J0IGNvbnN0IEdBTE9JU19NVUxfMiA9IFtcbiAgMHgwMCwgMHgwMiwgMHgwNCwgMHgwNiwgMHgwOCwgMHgwYSwgMHgwYywgMHgwZSwgMHgxMCwgMHgxMiwgMHgxNCwgMHgxNiwgMHgxOCwgMHgxYSwgMHgxYywgMHgxZSxcbiAgMHgyMCwgMHgyMiwgMHgyNCwgMHgyNiwgMHgyOCwgMHgyYSwgMHgyYywgMHgyZSwgMHgzMCwgMHgzMiwgMHgzNCwgMHgzNiwgMHgzOCwgMHgzYSwgMHgzYywgMHgzZSxcbiAgMHg0MCwgMHg0MiwgMHg0NCwgMHg0NiwgMHg0OCwgMHg0YSwgMHg0YywgMHg0ZSwgMHg1MCwgMHg1MiwgMHg1NCwgMHg1NiwgMHg1OCwgMHg1YSwgMHg1YywgMHg1ZSxcbiAgMHg2MCwgMHg2MiwgMHg2NCwgMHg2NiwgMHg2OCwgMHg2YSwgMHg2YywgMHg2ZSwgMHg3MCwgMHg3MiwgMHg3NCwgMHg3NiwgMHg3OCwgMHg3YSwgMHg3YywgMHg3ZSxcbiAgMHg4MCwgMHg4MiwgMHg4NCwgMHg4NiwgMHg4OCwgMHg4YSwgMHg4YywgMHg4ZSwgMHg5MCwgMHg5MiwgMHg5NCwgMHg5NiwgMHg5OCwgMHg5YSwgMHg5YywgMHg5ZSxcbiAgMHhhMCwgMHhhMiwgMHhhNCwgMHhhNiwgMHhhOCwgMHhhYSwgMHhhYywgMHhhZSwgMHhiMCwgMHhiMiwgMHhiNCwgMHhiNiwgMHhiOCwgMHhiYSwgMHhiYywgMHhiZSxcbiAgMHhjMCwgMHhjMiwgMHhjNCwgMHhjNiwgMHhjOCwgMHhjYSwgMHhjYywgMHhjZSwgMHhkMCwgMHhkMiwgMHhkNCwgMHhkNiwgMHhkOCwgMHhkYSwgMHhkYywgMHhkZSxcbiAgMHhlMCwgMHhlMiwgMHhlNCwgMHhlNiwgMHhlOCwgMHhlYSwgMHhlYywgMHhlZSwgMHhmMCwgMHhmMiwgMHhmNCwgMHhmNiwgMHhmOCwgMHhmYSwgMHhmYywgMHhmZSxcbiAgMHgxYiwgMHgxOSwgMHgxZiwgMHgxZCwgMHgxMywgMHgxMSwgMHgxNywgMHgxNSwgMHgwYiwgMHgwOSwgMHgwZiwgMHgwZCwgMHgwMywgMHgwMSwgMHgwNywgMHgwNSxcbiAgMHgzYiwgMHgzOSwgMHgzZiwgMHgzZCwgMHgzMywgMHgzMSwgMHgzNywgMHgzNSwgMHgyYiwgMHgyOSwgMHgyZiwgMHgyZCwgMHgyMywgMHgyMSwgMHgyNywgMHgyNSxcbiAgMHg1YiwgMHg1OSwgMHg1ZiwgMHg1ZCwgMHg1MywgMHg1MSwgMHg1NywgMHg1NSwgMHg0YiwgMHg0OSwgMHg0ZiwgMHg0ZCwgMHg0MywgMHg0MSwgMHg0NywgMHg0NSxcbiAgMHg3YiwgMHg3OSwgMHg3ZiwgMHg3ZCwgMHg3MywgMHg3MSwgMHg3NywgMHg3NSwgMHg2YiwgMHg2OSwgMHg2ZiwgMHg2ZCwgMHg2MywgMHg2MSwgMHg2NywgMHg2NSxcbiAgMHg5YiwgMHg5OSwgMHg5ZiwgMHg5ZCwgMHg5MywgMHg5MSwgMHg5NywgMHg5NSwgMHg4YiwgMHg4OSwgMHg4ZiwgMHg4ZCwgMHg4MywgMHg4MSwgMHg4NywgMHg4NSxcbiAgMHhiYiwgMHhiOSwgMHhiZiwgMHhiZCwgMHhiMywgMHhiMSwgMHhiNywgMHhiNSwgMHhhYiwgMHhhOSwgMHhhZiwgMHhhZCwgMHhhMywgMHhhMSwgMHhhNywgMHhhNSxcbiAgMHhkYiwgMHhkOSwgMHhkZiwgMHhkZCwgMHhkMywgMHhkMSwgMHhkNywgMHhkNSwgMHhjYiwgMHhjOSwgMHhjZiwgMHhjZCwgMHhjMywgMHhjMSwgMHhjNywgMHhjNSxcbiAgMHhmYiwgMHhmOSwgMHhmZiwgMHhmZCwgMHhmMywgMHhmMSwgMHhmNywgMHhmNSwgMHhlYiwgMHhlOSwgMHhlZiwgMHhlZCwgMHhlMywgMHhlMSwgMHhlNywgMHhlNSxcbl07XG5cbmV4cG9ydCBjb25zdCBHQUxPSVNfTVVMXzMgPSBbXG4gIDB4MDAsIDB4MDMsIDB4MDYsIDB4MDUsIDB4MGMsIDB4MGYsIDB4MGEsIDB4MDksIDB4MTgsIDB4MWIsIDB4MWUsIDB4MWQsIDB4MTQsIDB4MTcsIDB4MTIsIDB4MTEsXG4gIDB4MzAsIDB4MzMsIDB4MzYsIDB4MzUsIDB4M2MsIDB4M2YsIDB4M2EsIDB4MzksIDB4MjgsIDB4MmIsIDB4MmUsIDB4MmQsIDB4MjQsIDB4MjcsIDB4MjIsIDB4MjEsXG4gIDB4NjAsIDB4NjMsIDB4NjYsIDB4NjUsIDB4NmMsIDB4NmYsIDB4NmEsIDB4NjksIDB4NzgsIDB4N2IsIDB4N2UsIDB4N2QsIDB4NzQsIDB4NzcsIDB4NzIsIDB4NzEsXG4gIDB4NTAsIDB4NTMsIDB4NTYsIDB4NTUsIDB4NWMsIDB4NWYsIDB4NWEsIDB4NTksIDB4NDgsIDB4NGIsIDB4NGUsIDB4NGQsIDB4NDQsIDB4NDcsIDB4NDIsIDB4NDEsXG4gIDB4YzAsIDB4YzMsIDB4YzYsIDB4YzUsIDB4Y2MsIDB4Y2YsIDB4Y2EsIDB4YzksIDB4ZDgsIDB4ZGIsIDB4ZGUsIDB4ZGQsIDB4ZDQsIDB4ZDcsIDB4ZDIsIDB4ZDEsXG4gIDB4ZjAsIDB4ZjMsIDB4ZjYsIDB4ZjUsIDB4ZmMsIDB4ZmYsIDB4ZmEsIDB4ZjksIDB4ZTgsIDB4ZWIsIDB4ZWUsIDB4ZWQsIDB4ZTQsIDB4ZTcsIDB4ZTIsIDB4ZTEsXG4gIDB4YTAsIDB4YTMsIDB4YTYsIDB4YTUsIDB4YWMsIDB4YWYsIDB4YWEsIDB4YTksIDB4YjgsIDB4YmIsIDB4YmUsIDB4YmQsIDB4YjQsIDB4YjcsIDB4YjIsIDB4YjEsXG4gIDB4OTAsIDB4OTMsIDB4OTYsIDB4OTUsIDB4OWMsIDB4OWYsIDB4OWEsIDB4OTksIDB4ODgsIDB4OGIsIDB4OGUsIDB4OGQsIDB4ODQsIDB4ODcsIDB4ODIsIDB4ODEsXG4gIDB4OWIsIDB4OTgsIDB4OWQsIDB4OWUsIDB4OTcsIDB4OTQsIDB4OTEsIDB4OTIsIDB4ODMsIDB4ODAsIDB4ODUsIDB4ODYsIDB4OGYsIDB4OGMsIDB4ODksIDB4OGEsXG4gIDB4YWIsIDB4YTgsIDB4YWQsIDB4YWUsIDB4YTcsIDB4YTQsIDB4YTEsIDB4YTIsIDB4YjMsIDB4YjAsIDB4YjUsIDB4YjYsIDB4YmYsIDB4YmMsIDB4YjksIDB4YmEsXG4gIDB4ZmIsIDB4ZjgsIDB4ZmQsIDB4ZmUsIDB4ZjcsIDB4ZjQsIDB4ZjEsIDB4ZjIsIDB4ZTMsIDB4ZTAsIDB4ZTUsIDB4ZTYsIDB4ZWYsIDB4ZWMsIDB4ZTksIDB4ZWEsXG4gIDB4Y2IsIDB4YzgsIDB4Y2QsIDB4Y2UsIDB4YzcsIDB4YzQsIDB4YzEsIDB4YzIsIDB4ZDMsIDB4ZDAsIDB4ZDUsIDB4ZDYsIDB4ZGYsIDB4ZGMsIDB4ZDksIDB4ZGEsXG4gIDB4NWIsIDB4NTgsIDB4NWQsIDB4NWUsIDB4NTcsIDB4NTQsIDB4NTEsIDB4NTIsIDB4NDMsIDB4NDAsIDB4NDUsIDB4NDYsIDB4NGYsIDB4NGMsIDB4NDksIDB4NGEsXG4gIDB4NmIsIDB4NjgsIDB4NmQsIDB4NmUsIDB4NjcsIDB4NjQsIDB4NjEsIDB4NjIsIDB4NzMsIDB4NzAsIDB4NzUsIDB4NzYsIDB4N2YsIDB4N2MsIDB4NzksIDB4N2EsXG4gIDB4M2IsIDB4MzgsIDB4M2QsIDB4M2UsIDB4MzcsIDB4MzQsIDB4MzEsIDB4MzIsIDB4MjMsIDB4MjAsIDB4MjUsIDB4MjYsIDB4MmYsIDB4MmMsIDB4MjksIDB4MmEsXG4gIDB4MGIsIDB4MDgsIDB4MGQsIDB4MGUsIDB4MDcsIDB4MDQsIDB4MDEsIDB4MDIsIDB4MTMsIDB4MTAsIDB4MTUsIDB4MTYsIDB4MWYsIDB4MWMsIDB4MTksIDB4MWEsXG5dO1xuXG4vLyBDb252ZXJ0IHRleHQgdG8gYSBzdGF0ZSBtYXRyaXggLSByZXR1cm5zIGFycmF5IG9mIGJ5dGVzXG5leHBvcnQgY29uc3QgdGV4dFRvU3RhdGUgPSAodGV4dDogc3RyaW5nKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh0ZXh0KTtcbiAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRBcnJheS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHdvcmQgPSB3b3JkQXJyYXkud29yZHNbaV07XG4gICAgY29uc3QgYnl0ZXNJblRoaXNXb3JkID0gTWF0aC5taW4oNCwgc2lnQnl0ZXMgLSBpICogNCk7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAxKSBieXRlcy5wdXNoKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDIpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDE2KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMykgYnl0ZXMucHVzaCgod29yZCA+Pj4gOCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDQpIGJ5dGVzLnB1c2god29yZCAmIDB4ZmYpO1xuICB9XG4gIFxuICAvLyBQYWQgdG8gMTYgYnl0ZXMgaWYgbmVlZGVkXG4gIHdoaWxlIChieXRlcy5sZW5ndGggPCAxNikge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIGNvbnN0IGJsb2NrID0gYnl0ZXMuc2xpY2UoMCwgMTYpO1xuICAvLyBBRVMgc3RhdGUgaXMgY29sdW1uLW1ham9yOiBzdGF0ZVtyICsgNCpjXSA9IGlucHV0WzQqYyArIHJdXG4gIHJldHVybiBibG9jaztcbn07XG5cbi8vIENvbnZlcnQgYSBrZXkgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIHNlbGVjdGVkIGtleSBsZW5ndGhcbmV4cG9ydCBjb25zdCBrZXlUb0J5dGVzID0gKFxuICBrZXk6IHN0cmluZyxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXF1aXJlZEJ5dGVzID0gZ2V0S2V5Qnl0ZUxlbmd0aChrZXlMZW5ndGgpO1xuICBjb25zdCByZXF1aXJlZEhleExlbmd0aCA9IHJlcXVpcmVkQnl0ZXMgKiAyO1xuXG4gIC8vIFJlbW92ZSBzcGFjZXMgYW5kIGNvbnZlcnQgdG8gbG93ZXJjYXNlXG4gIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIElmIGl0J3MgYSBoZXggc3RyaW5nLCBjb252ZXJ0IGl0XG4gIGlmICgvXlswLTlhLWZdKyQvLnRlc3QoY2xlYW5LZXkpKSB7XG4gICAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihjbGVhbktleS5sZW5ndGgsIHJlcXVpcmVkSGV4TGVuZ3RoKTsgaSArPSAyKSB7XG4gICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGNsZWFuS2V5LnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgICB9XG4gICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCA8IHJlcXVpcmVkQnl0ZXMpIHtcbiAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5zbGljZSgwLCByZXF1aXJlZEJ5dGVzKTtcbiAgfVxuICBcbiAgLy8gT3RoZXJ3aXNlLCB0cmVhdCBhcyBVVEYtOCB0ZXh0IGFuZCBub3JtYWxpemUgdG8gc2VsZWN0ZWQga2V5IHNpemVcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2Uoa2V5KTtcbiAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRBcnJheS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHdvcmQgPSB3b3JkQXJyYXkud29yZHNbaV07XG4gICAgY29uc3QgYnl0ZXNJblRoaXNXb3JkID0gTWF0aC5taW4oNCwgc2lnQnl0ZXMgLSBpICogNCk7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAxKSBieXRlcy5wdXNoKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDIpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDE2KSAmIDB4ZmYpO1xuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMykgYnl0ZXMucHVzaCgod29yZCA+Pj4gOCkgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDQpIGJ5dGVzLnB1c2god29yZCAmIDB4ZmYpO1xuICB9XG4gIHdoaWxlIChieXRlcy5sZW5ndGggPCByZXF1aXJlZEJ5dGVzKSB7XG4gICAgYnl0ZXMucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgcmVxdWlyZWRCeXRlcyk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHJhbmRvbSBrZXkgYXMgYnl0ZSBhcnJheSBiYXNlZCBvbiBrZXkgbGVuZ3RoXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21LZXkgPSAoa2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOCk6IG51bWJlcltdID0+IHtcbiAgY29uc3Qga2V5Qnl0ZXMgPSBnZXRLZXlCeXRlTGVuZ3RoKGtleUxlbmd0aCk7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Qnl0ZXM7IGkrKykge1xuICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gRm9ybWF0IGJ5dGVzIGFzIGhleFxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9IZXggPSAoYnl0ZXM6IG51bWJlcltdLCBqb2luQ2hhcjogc3RyaW5nID0gJyAnKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGJ5dGVzLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oam9pbkNoYXIpO1xufTtcblxuLy8gRm9ybWF0IGJ5dGVzIGFzIGJpbmFyeVxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9CaW5hcnkgPSAoYnl0ZXM6IG51bWJlcltdLCBqb2luQ2hhcjogc3RyaW5nID0gJyAnKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGJ5dGVzLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgJzAnKSkuam9pbihqb2luQ2hhcik7XG59O1xuXG4vLyBTdWJCeXRlcyBvcGVyYXRpb24gLSBzdWJzdGl0dXRlIGVhY2ggYnl0ZSB3aXRoIGl0cyBTLWJveCB2YWx1ZVxuZXhwb3J0IGNvbnN0IHN1YkJ5dGVzID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgcmV0dXJuIHN0YXRlLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xufTtcblxuLy8gU2hpZnRSb3dzIG9wZXJhdGlvbiAtIHJvdGF0ZSByb3dzIG9mIHRoZSBzdGF0ZSBtYXRyaXhcbmV4cG9ydCBjb25zdCBzaGlmdFJvd3MgPSAoc3RhdGU6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXN1bHQgPSBbLi4uc3RhdGVdO1xuICBcbiAgLy8gQ29sdW1uLW1ham9yIHN0YXRlIGluZGV4IGhlbHBlcjogaWR4KHJvdywgY29sKSA9IHJvdyArIDQqY29sXG4gIGNvbnN0IGlkeCA9IChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpID0+IHJvdyArIDQgKiBjb2w7XG5cbiAgZm9yIChsZXQgcm93ID0gMTsgcm93IDwgNDsgcm93KyspIHtcbiAgICBjb25zdCByb3dWYWx1ZXMgPSBbc3RhdGVbaWR4KHJvdywgMCldLCBzdGF0ZVtpZHgocm93LCAxKV0sIHN0YXRlW2lkeChyb3csIDIpXSwgc3RhdGVbaWR4KHJvdywgMyldXTtcbiAgICBjb25zdCBzaGlmdGVkID0gcm93VmFsdWVzLnNsaWNlKHJvdykuY29uY2F0KHJvd1ZhbHVlcy5zbGljZSgwLCByb3cpKTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA0OyBjb2wrKykge1xuICAgICAgcmVzdWx0W2lkeChyb3csIGNvbCldID0gc2hpZnRlZFtjb2xdO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIE1peENvbHVtbnMgb3BlcmF0aW9uIC0gbWl4IGRhdGEgd2l0aGluIGNvbHVtbnNcbmV4cG9ydCBjb25zdCBtaXhDb2x1bW5zID0gKHN0YXRlOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gWy4uLnN0YXRlXTtcbiAgY29uc3QgaWR4ID0gKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4gcm93ICsgNCAqIGNvbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBzMCA9IHN0YXRlW2lkeCgwLCBpKV07XG4gICAgY29uc3QgczEgPSBzdGF0ZVtpZHgoMSwgaSldO1xuICAgIGNvbnN0IHMyID0gc3RhdGVbaWR4KDIsIGkpXTtcbiAgICBjb25zdCBzMyA9IHN0YXRlW2lkeCgzLCBpKV07XG4gICAgXG4gICAgcmVzdWx0W2lkeCgwLCBpKV0gPSBHQUxPSVNfTVVMXzJbczBdIF4gR0FMT0lTX01VTF8zW3MxXSBeIHMyIF4gczM7XG4gICAgcmVzdWx0W2lkeCgxLCBpKV0gPSBzMCBeIEdBTE9JU19NVUxfMltzMV0gXiBHQUxPSVNfTVVMXzNbczJdIF4gczM7XG4gICAgcmVzdWx0W2lkeCgyLCBpKV0gPSBzMCBeIHMxIF4gR0FMT0lTX01VTF8yW3MyXSBeIEdBTE9JU19NVUxfM1tzM107XG4gICAgcmVzdWx0W2lkeCgzLCBpKV0gPSBHQUxPSVNfTVVMXzNbczBdIF4gczEgXiBzMiBeIEdBTE9JU19NVUxfMltzM107XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEFkZFJvdW5kS2V5IG9wZXJhdGlvbiAtIFhPUiBzdGF0ZSB3aXRoIHJvdW5kIGtleVxuZXhwb3J0IGNvbnN0IGFkZFJvdW5kS2V5ID0gKHN0YXRlOiBudW1iZXJbXSwgcm91bmRLZXk6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICByZXR1cm4gc3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gcm91bmRLZXlbaV0pO1xufTtcblxuLy8gS2FsaXRuaSBrZW5nYXl0aXJpc2gg4oCUIHJhdW5kIGthbGl0bGFyaW5pIGdlbmVyYXRzaXlhIHFpbGlzaFxuZXhwb3J0IGNvbnN0IGtleUV4cGFuc2lvbiA9IChrZXk6IG51bWJlcltdLCBrZXlMZW5ndGg6IEtleUxlbmd0aCA9IEtleUxlbmd0aC5BRVNfMTI4KTogbnVtYmVyW11bXSA9PiB7XG4gIGNvbnN0IHJlcXVpcmVkQnl0ZXMgPSBnZXRLZXlCeXRlTGVuZ3RoKGtleUxlbmd0aCk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc2xpY2UoMCwgcmVxdWlyZWRCeXRlcyk7XG4gIHdoaWxlIChub3JtYWxpemVkS2V5Lmxlbmd0aCA8IHJlcXVpcmVkQnl0ZXMpIHtcbiAgICBub3JtYWxpemVkS2V5LnB1c2goMCk7XG4gIH1cblxuICBjb25zdCBrZXlXb3JkcyA9IG5vcm1hbGl6ZWRLZXkubGVuZ3RoIC8gNDtcbiAgY29uc3QgbnVtUm91bmRzID0gZ2V0TnVtUm91bmRzKGtleUxlbmd0aCk7XG4gIFxuICBjb25zdCByb3VuZEtleXM6IG51bWJlcltdW10gPSBbbm9ybWFsaXplZEtleS5zbGljZSgpXTsgLy8gMS1yYXVuZCBrYWxpdGkgYm9zaGxhbmfigJhpY2gga2FsaXRuaW5nIG/igJh6aSBoaXNvYmxhbmFkaVxuICBcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICBjb25zdCBwcmV2S2V5ID0gcm91bmRLZXlzW3JvdW5kIC0gMV07XG4gICAgY29uc3QgbmV3S2V5ID0gcHJldktleS5zbGljZSgpO1xuICAgIFxuICAgIC8vIE94aXJnaSB3b3JkIG5pIGF5bGFudGlyaWIsIFMtYm94IG5pIHFv4oCYbGxhbmdcbiAgICBjb25zdCBsYXN0SW5kZXggPSBwcmV2S2V5Lmxlbmd0aCAtIDQ7XG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVtsYXN0SW5kZXhdLCBwcmV2S2V5W2xhc3RJbmRleCArIDFdLCBwcmV2S2V5W2xhc3RJbmRleCArIDJdLCBwcmV2S2V5W2xhc3RJbmRleCArIDNdXTtcbiAgICBjb25zdCByb3RXb3JkID0gW2xhc3RXb3JkWzFdLCBsYXN0V29yZFsyXSwgbGFzdFdvcmRbM10sIGxhc3RXb3JkWzBdXTtcbiAgICBjb25zdCBzdWJXb3JkID0gcm90V29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICBcbiAgICAvLyBCaXJpbmNoaSBiYXl0bmkgUmNvbiBiaWxhbiBYT1IgcWlsaW5hZGlcbiAgICBzdWJXb3JkWzBdIF49IFJDT05bcm91bmRdO1xuICAgIFxuICAgIC8vIFlhbmdpIGthbGl0bmluZyBiaXJpbmNoaSB3b3JkIGkgZ2VuZXJhdHNpeWEgcWlsaW5hZGlcbiAgICBuZXdLZXlbMF0gPSBwcmV2S2V5WzBdIF4gc3ViV29yZFswXTtcbiAgICBuZXdLZXlbMV0gPSBwcmV2S2V5WzFdIF4gc3ViV29yZFsxXTtcbiAgICBuZXdLZXlbMl0gPSBwcmV2S2V5WzJdIF4gc3ViV29yZFsyXTtcbiAgICBuZXdLZXlbM10gPSBwcmV2S2V5WzNdIF4gc3ViV29yZFszXTtcbiAgICBcbiAgICAvLyBRb2xnYW4gd29yZCBsYXIgaG9zaWwgcWlsaW5hZGlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleVdvcmRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuICAgICAgLy8gQUVTLTI1NiBob2xhdGlkYSBoYXIgdG/igJhydGluY2hpIHdvcmQgZ2EgcW/igJhzaGltY2hhIFMtYm94IChTdWJXb3JkKSBxb+KAmGxsYW5hZGlcbiAgICAgIGlmIChrZXlMZW5ndGggPT09IEtleUxlbmd0aC5BRVNfMjU2ICYmIGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgdGVtcFdvcmQgPSBbbmV3S2V5W29mZnNldCAtIDRdLCBuZXdLZXlbb2Zmc2V0IC0gM10sIG5ld0tleVtvZmZzZXQgLSAyXSwgbmV3S2V5W29mZnNldCAtIDFdXTtcbiAgICAgICAgY29uc3Qgc3ViVGVtcFdvcmQgPSB0ZW1wV29yZC5tYXAoYnl0ZSA9PiBTQk9YW2J5dGVdKTtcbiAgICAgICAgXG4gICAgICAgIG5ld0tleVtvZmZzZXRdID0gcHJldktleVtvZmZzZXRdIF4gc3ViVGVtcFdvcmRbMF07XG4gICAgICAgIG5ld0tleVtvZmZzZXQgKyAxXSA9IHByZXZLZXlbb2Zmc2V0ICsgMV0gXiBzdWJUZW1wV29yZFsxXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gcHJldktleVtvZmZzZXQgKyAyXSBeIHN1YlRlbXBXb3JkWzJdO1xuICAgICAgICBuZXdLZXlbb2Zmc2V0ICsgM10gPSBwcmV2S2V5W29mZnNldCArIDNdIF4gc3ViVGVtcFdvcmRbM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdLZXlbb2Zmc2V0XSA9IG5ld0tleVtvZmZzZXQgLSA0XSBeIHByZXZLZXlbb2Zmc2V0XTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDFdID0gbmV3S2V5W29mZnNldCAtIDNdIF4gcHJldktleVtvZmZzZXQgKyAxXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDJdID0gbmV3S2V5W29mZnNldCAtIDJdIF4gcHJldktleVtvZmZzZXQgKyAyXTtcbiAgICAgICAgbmV3S2V5W29mZnNldCArIDNdID0gbmV3S2V5W29mZnNldCAtIDFdIF4gcHJldktleVtvZmZzZXQgKyAzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcm91bmRLZXlzLnB1c2gobmV3S2V5KTtcbiAgfVxuICBcbiAgcmV0dXJuIHJvdW5kS2V5cztcbn07XG5cbi8vIFBlcmZvcm0gb25lIHJvdW5kIG9mIEFFU1xuZXhwb3J0IGNvbnN0IGFlc1JvdW5kID0gKHN0YXRlOiBudW1iZXJbXSwgcm91bmRLZXk6IG51bWJlcltdLCBpc0xhc3RSb3VuZDogYm9vbGVhbik6IG51bWJlcltdID0+IHtcbiAgbGV0IG5ld1N0YXRlID0gc3ViQnl0ZXMoc3RhdGUpO1xuICBuZXdTdGF0ZSA9IHNoaWZ0Um93cyhuZXdTdGF0ZSk7XG4gIGlmICghaXNMYXN0Um91bmQpIHtcbiAgICBuZXdTdGF0ZSA9IG1peENvbHVtbnMobmV3U3RhdGUpO1xuICB9XG4gIG5ld1N0YXRlID0gYWRkUm91bmRLZXkobmV3U3RhdGUsIHJvdW5kS2V5KTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLy8gQ29tcGxldGUgQUVTIGVuY3J5cHRpb25cbmV4cG9ydCBjb25zdCBhZXNFbmNyeXB0ID0gKFxuICBwbGFpbnRleHQ6IHN0cmluZyxcbiAga2V5OiBudW1iZXJbXSxcbiAga2V5TGVuZ3RoOiBLZXlMZW5ndGggPSBLZXlMZW5ndGguQUVTXzEyOFxuKTogbnVtYmVyW10gPT4ge1xuICAvLyBJbml0aWFsIHN0YXRlXG4gIGNvbnN0IHN0YXRlID0gdGV4dFRvU3RhdGUocGxhaW50ZXh0KTtcbiAgXG4gIC8vIEtleSBleHBhbnNpb25cbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSwga2V5TGVuZ3RoKTtcbiAgY29uc3QgbnVtUm91bmRzID0gZ2V0TnVtUm91bmRzKGtleUxlbmd0aCk7XG4gIFxuICAvLyBJbml0aWFsIHJvdW5kIC0ganVzdCBBZGRSb3VuZEtleVxuICBsZXQgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoc3RhdGUsIHJvdW5kS2V5c1swXSk7XG4gIFxuICAvLyBNYWluIHJvdW5kc1xuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IG51bVJvdW5kczsgcm91bmQrKykge1xuICAgIGN1cnJlbnRTdGF0ZSA9IGFlc1JvdW5kKGN1cnJlbnRTdGF0ZSwgcm91bmRLZXlzW3JvdW5kXSwgcm91bmQgPT09IG51bVJvdW5kcyk7XG4gIH1cbiAgXG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59O1xuXG4vLyBDb252ZXJ0IGZ1bGwgdGV4dCB0byBhcnJheSBvZiAxNi1ieXRlIGJsb2Nrc1xuZXhwb3J0IGNvbnN0IHRleHRUb0Jsb2NrcyA9ICh0ZXh0OiBzdHJpbmcsIHBhZGRpbmc6IFBhZGRpbmdUeXBlID0gUGFkZGluZ1R5cGUuUEtDUzcpOiBudW1iZXJbXVtdID0+IHtcbiAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodGV4dCk7XG4gIGNvbnN0IGJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuICBcbiAgLy8gQ29udmVydCBDcnlwdG9KUyBXb3JkQXJyYXkgdG8gYnl0ZSBhcnJheSwgcmVzcGVjdGluZyBzaWdCeXRlc1xuICBjb25zdCBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB3b3JkID0gd29yZEFycmF5LndvcmRzW2ldO1xuICAgIGNvbnN0IGJ5dGVzSW5UaGlzV29yZCA9IE1hdGgubWluKDQsIHNpZ0J5dGVzIC0gaSAqIDQpO1xuICAgIFxuICAgIGlmIChieXRlc0luVGhpc1dvcmQgPj0gMSkgYnl0ZXMucHVzaCgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSAyKSBieXRlcy5wdXNoKCh3b3JkID4+PiAxNikgJiAweGZmKTtcbiAgICBpZiAoYnl0ZXNJblRoaXNXb3JkID49IDMpIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDgpICYgMHhmZik7XG4gICAgaWYgKGJ5dGVzSW5UaGlzV29yZCA+PSA0KSBieXRlcy5wdXNoKHdvcmQgJiAweGZmKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgcGFkZGluZ1xuICBsZXQgcGFkZGVkQnl0ZXM6IG51bWJlcltdO1xuICBpZiAocGFkZGluZyA9PT0gUGFkZGluZ1R5cGUuUEtDUzcpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5UEtDUzdQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSBQYWRkaW5nVHlwZS5BTlNJX1g5MjMpIHtcbiAgICBwYWRkZWRCeXRlcyA9IGFwcGx5QW5zaVg5MjNQYWRkaW5nKGJ5dGVzKTtcbiAgfSBlbHNlIHsgLy8gTk9ORVxuICAgIHBhZGRlZEJ5dGVzID0gWy4uLmJ5dGVzXTtcbiAgICAvLyBGb3IgTk9ORSBwYWRkaW5nLCBtdXN0IGJlIG11bHRpcGxlIG9mIDE2XG4gICAgd2hpbGUgKHBhZGRlZEJ5dGVzLmxlbmd0aCAlIDE2ICE9PSAwKSB7XG4gICAgICBwYWRkZWRCeXRlcy5wdXNoKDApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3BsaXQgaW50byAxNi1ieXRlIGJsb2Nrc1xuICBjb25zdCBibG9ja3M6IG51bWJlcltdW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCeXRlcy5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBibG9ja3MucHVzaChwYWRkZWRCeXRlcy5zbGljZShpLCBpICsgMTYpKTtcbiAgfVxuICBcbiAgcmV0dXJuIGJsb2Nrcztcbn07XG5cbi8vIEFwcGx5IFBLQ1M3IHBhZGRpbmdcbmV4cG9ydCBjb25zdCBhcHBseVBLQ1M3UGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGVkID0gWy4uLmRhdGFdO1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmdMZW5ndGg7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKHBhZGRpbmdMZW5ndGgpO1xuICB9XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gQXBwbHkgQU5TSSBYLjkyMyBwYWRkaW5nXG5leHBvcnQgY29uc3QgYXBwbHlBbnNpWDkyM1BhZGRpbmcgPSAoZGF0YTogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHBhZGRlZCA9IFsuLi5kYXRhXTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICBcbiAgLy8gQWRkIHBhZGRpbmcgYnl0ZXMgKDB4MDApIGV4Y2VwdCB0aGUgbGFzdCBieXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGluZ0xlbmd0aCAtIDE7IGkrKykge1xuICAgIHBhZGRlZC5wdXNoKDB4MDApO1xuICB9XG4gIFxuICAvLyBBZGQgdGhlIHBhZGRpbmcgbGVuZ3RoIGFzIHRoZSBsYXN0IGJ5dGVcbiAgcGFkZGVkLnB1c2gocGFkZGluZ0xlbmd0aCk7XG4gIFxuICByZXR1cm4gcGFkZGVkO1xufTtcblxuLy8gUmVtb3ZlIEFOU0kgWC45MjMgcGFkZGluZ1xuZXhwb3J0IGNvbnN0IHJlbW92ZUFuc2lYOTIzUGFkZGluZyA9IChkYXRhOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBwYWRkaW5nTGVuZ3RoKTtcbn07XG5cbi8vIEdldCBJViBmb3IgQ0JDIG1vZGVcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUlWID0gKCk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaXYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgaXYucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgfVxuICByZXR1cm4gaXY7XG59O1xuXG4vLyBHZXQgYWxsIGludGVybWVkaWF0ZSBzdGF0ZXMgZm9yIHZpc3VhbGl6YXRpb25cbmV4cG9ydCB0eXBlIEFlc1N0ZXAgPSB7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHN0YXRlOiBudW1iZXJbXTtcbiAgYWN0aXZlSW5kaWNlcz86IG51bWJlcltdOyAgLy8gRm9yIGhpZ2hsaWdodGluZyBzcGVjaWZpYyBjZWxsc1xuICBleHBsYW5hdGlvbj86IHN0cmluZzsgICAgICAvLyBNb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uXG4gIHJvdW5kS2V5PzogbnVtYmVyW107XG4gIHByZXZpb3VzU3RhdGU/OiBudW1iZXJbXTsgIC8vIEZvciBzaG93aW5nIGJlZm9yZS9hZnRlciBjb21wYXJpc29uXG59O1xuXG4vLyBHZXQgQUVTIHN0ZXBzIGZvciBhIHNpbmdsZSBibG9jayAoMTYgYnl0ZXMpXG5leHBvcnQgY29uc3QgZ2V0QWVzU3RlcHNGb3JCbG9jayA9IChcbiAgYmxvY2s6IG51bWJlcltdLFxuICBrZXk6IG51bWJlcltdLFxuICBtb2RlOiBBZXNNb2RlID0gQWVzTW9kZS5FQ0IsXG4gIGJsb2NrSW5kZXg6IG51bWJlciA9IDAsXG4gIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrPzogbnVtYmVyW10sXG4gIGl2PzogbnVtYmVyW10sXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjhcbik6IHtcbiAgc3RlcHM6IEFlc1N0ZXBbXSxcbiAgZmluYWxTdGF0ZTogbnVtYmVyW11cbn0gPT4ge1xuICBjb25zdCBzdGVwczogQWVzU3RlcFtdID0gW107XG4gIFxuICAvLyBFbnN1cmUgYmxvY2sgaXMgZXhhY3RseSAxNiBieXRlc1xuICBjb25zdCBwbGFpbnRleHRCeXRlcyA9IFsuLi5ibG9ja107XG4gIHdoaWxlIChwbGFpbnRleHRCeXRlcy5sZW5ndGggPCAxNikge1xuICAgIHBsYWludGV4dEJ5dGVzLnB1c2goMCk7XG4gIH1cbiAgXG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIEFzbCBvY2hpcSBtYXRuYCwgXG4gICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSBiYXl0Z2EgYXlsYW50aXJpbGFkaSB2YSA0w5c0IG1hdHJpdHNhIHNoYWtsaWRhIGlmb2RhbGFuYWRpLmBcbiAgfSk7XG4gIFxuICBjb25zdCBpbml0aWFsU3RhdGUgPSBwbGFpbnRleHRCeXRlcztcbiAgY29uc3Qgcm91bmRLZXlzID0ga2V5RXhwYW5zaW9uKGtleSwga2V5TGVuZ3RoKTtcbiAgY29uc3QgbnVtUm91bmRzID0gZ2V0TnVtUm91bmRzKGtleUxlbmd0aCk7XG4gIFxuICBsZXQgY3VycmVudFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoYmxvY2tJbmRleCA9PT0gMCAmJiBpdikge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaXZbaV0pO1xuICAgICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCBJViBiaWxhbiBYT1JgLCBcbiAgICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHJvdW5kS2V5OiBpdixcbiAgICAgICAgICBleHBsYW5hdGlvbjogYENCQzogYmlyaW5jaGkgYmxvayBJViBiaWxhbiBYT1IgcWlsaW5hZGkuYFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2spIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrW2ldKTtcbiAgICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgT2xkaW5naSBjaXBoZXJ0ZXh0IGJpbGFuIFhPUmAsIFxuICAgICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgICAgcm91bmRLZXk6IHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ0JDOiBrZXlpbmdpIGJsb2tsYXIgb2xkaW5naSBjaXBoZXJ0ZXh0IGJsb2tpIGJpbGFuIFhPUiBxaWxpbmFkaS5gXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIGlmICghaXYpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcHM6IFtdLCBmaW5hbFN0YXRlOiBwbGFpbnRleHRCeXRlcyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY291bnRlckJsb2NrID0gWy4uLml2XTtcbiAgICAgIGxldCBjb3VudGVyVmFsdWUgPSBibG9ja0luZGV4O1xuICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDAgJiYgY291bnRlclZhbHVlID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJCbG9ja1tpXSArIChjb3VudGVyVmFsdWUgJiAweGZmKTtcbiAgICAgICAgY291bnRlckJsb2NrW2ldID0gc3VtICYgMHhmZjtcbiAgICAgICAgY291bnRlclZhbHVlID0gKGNvdW50ZXJWYWx1ZSA+PiA4KSArIChzdW0gPj4gOCk7XG4gICAgICB9XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQ291bnRlcmAsIFxuICAgICAgICBzdGF0ZTogY291bnRlckJsb2NrLFxuICAgICAgICBleHBsYW5hdGlvbjogYENUUjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSB1Y2h1biBjb3VudGVyLmBcbiAgICAgIH0pO1xuICAgICAgY3VycmVudFN0YXRlID0gY291bnRlckJsb2NrO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgQm9zaGxhbmcnaWNoYCwgXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBgRUNCOiBibG9rICR7YmxvY2tJbmRleCArIDF9IG11c3RhcWlsIHNoaWZybGFuYWRpLmBcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGNvbnN0IGFmdGVySW5pdGlhbFJvdW5kID0gYWRkUm91bmRLZXkoY3VycmVudFN0YXRlLCByb3VuZEtleXNbMF0pO1xuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAwLWJvc3FpY2gg4oCUIEFkZFJvdW5kS2V5YCwgXG4gICAgc3RhdGU6IGFmdGVySW5pdGlhbFJvdW5kLFxuICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgZXhwbGFuYXRpb246ICcnLFxuICAgIHJvdW5kS2V5OiByb3VuZEtleXNbMF0sXG4gICAgcHJldmlvdXNTdGF0ZTogY3VycmVudFN0YXRlLFxuICB9KTtcbiAgXG4gIGN1cnJlbnRTdGF0ZSA9IGFmdGVySW5pdGlhbFJvdW5kO1xuICBcbiAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8PSBudW1Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICBjb25zdCBhZnRlclN1YkJ5dGVzID0gc3ViQnl0ZXMoY3VycmVudFN0YXRlKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFN1YkJ5dGVzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTdWJCeXRlcyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGVcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBhZnRlclNoaWZ0Um93cyA9IHNoaWZ0Um93cyhhZnRlclN1YkJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUICR7cm91bmR9LWJvc3FpY2gg4oCUIFNoaWZ0Um93c2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU2hpZnRSb3dzLFxuICAgICAgYWN0aXZlSW5kaWNlczogWzEsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMSwgMTMsIDE0LCAxNV0sXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclN1YkJ5dGVzXG4gICAgfSk7XG4gICAgXG4gICAgbGV0IHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleTogbnVtYmVyW107XG4gICAgXG4gICAgaWYgKHJvdW5kIDwgbnVtUm91bmRzKSB7XG4gICAgICBjb25zdCBhZnRlck1peENvbHVtbnMgPSBtaXhDb2x1bW5zKGFmdGVyU2hpZnRSb3dzKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAke3JvdW5kfS1ib3NxaWNoIOKAlCBNaXhDb2x1bW5zYCwgXG4gICAgICAgIHN0YXRlOiBhZnRlck1peENvbHVtbnMsXG4gICAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogYWZ0ZXJTaGlmdFJvd3NcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShhZnRlck1peENvbHVtbnMsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJNaXhDb2x1bW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShhZnRlclNoaWZ0Um93cywgcm91bmRLZXlzW3JvdW5kXSk7XG4gICAgICBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXkgPSBhZnRlclNoaWZ0Um93cztcbiAgICB9XG4gICAgXG4gICAgc3RlcHMucHVzaCh7IFxuICAgICAgZGVzY3JpcHRpb246IGBCbG9rICR7YmxvY2tJbmRleCArIDF9IOKAlCAke3JvdW5kfS1ib3NxaWNoIOKAlCBBZGRSb3VuZEtleWAsIFxuICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICByb3VuZEtleTogcm91bmRLZXlzW3JvdW5kXSxcbiAgICAgIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSxcbiAgICB9KTtcbiAgfVxuICBcbiAgbGV0IGZpbmFsU3RhdGU6IG51bWJlcltdO1xuICBcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBBZXNNb2RlLkNCQzpcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBpbml0aWFsU3RhdGVbaV0pO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2sgJHtibG9ja0luZGV4ICsgMX0g4oCUIENvdW50ZXIgWE9SYCwgXG4gICAgICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogYENUUjogYmxvayAke2Jsb2NrSW5kZXggKyAxfSB1Y2h1biBjb3VudGVyIFhPUi5gLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgIHJvdW5kS2V5OiBjdXJyZW50U3RhdGVcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgc3RlcHMucHVzaCh7IFxuICAgIGRlc2NyaXB0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSDigJQgWWFrdW5peWAsIFxuICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgIGV4cGxhbmF0aW9uOiBgQmxvayAke2Jsb2NrSW5kZXggKyAxfSB1Y2h1biB5YWt1bml5IHNoaWZybGFuZ2FuIG5hdGlqYS5gXG4gIH0pO1xuICBcbiAgcmV0dXJuIHsgc3RlcHMsIGZpbmFsU3RhdGUgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBZXNTdGVwcyA9IChcbiAgcGxhaW50ZXh0OiBzdHJpbmcsIFxuICBrZXk6IG51bWJlcltdLCBcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3LFxuICBwcm92aWRlZEl2PzogbnVtYmVyW11cbik6IHtcbiAgc3RlcHM6IEFlc1N0ZXBbXSxcbiAgZmluYWxDaXBoZXJ0ZXh0OiB7XG4gICAgYmFzZTY0OiBzdHJpbmc7XG4gICAgaGV4OiBzdHJpbmc7XG4gICAgYmluYXJ5OiBzdHJpbmc7XG4gIH0sXG4gIGl2PzogbnVtYmVyW10sXG4gIGFsbEJsb2Nrcz86IHsgYmxvY2tJbmRleDogbnVtYmVyLCBzdGVwczogQWVzU3RlcFtdLCBmaW5hbFN0YXRlOiBudW1iZXJbXSB9W11cbn0gPT4ge1xuICBjb25zdCBzdGVwczogQWVzU3RlcFtdID0gW107XG4gIGxldCBpdjogbnVtYmVyW10gfCB1bmRlZmluZWQgPSBwcm92aWRlZEl2ID8gWy4uLnByb3ZpZGVkSXZdIDogdW5kZWZpbmVkO1xuICBcbiAgLy8gQ29udmVydCBmdWxsIHRleHQgdG8gYmxvY2tzXG4gIGNvbnN0IGJsb2NrcyA9IHRleHRUb0Jsb2NrcyhwbGFpbnRleHQsIHBhZGRpbmcpO1xuICBjb25zdCBhbGxCbG9ja3M6IHsgYmxvY2tJbmRleDogbnVtYmVyLCBzdGVwczogQWVzU3RlcFtdLCBmaW5hbFN0YXRlOiBudW1iZXJbXSB9W10gPSBbXTtcbiAgXG4gIC8vIENvbnZlcnQgcGxhaW50ZXh0IHRvIGJ5dGVzIChmb3IgZmlyc3QgYmxvY2sgdmlzdWFsaXphdGlvbilcbiAgbGV0IHBsYWludGV4dEJ5dGVzID0gYmxvY2tzWzBdIHx8IHRleHRUb1N0YXRlKHBsYWludGV4dCk7XG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogJ0FzbCBvY2hpcSBtYXRuJywgXG4gICAgc3RhdGU6IHBsYWludGV4dEJ5dGVzLFxuICAgIGV4cGxhbmF0aW9uOiBgT2NoaXEgbWF0biBcIiR7cGxhaW50ZXh0fVwiIGJheXRnYSBheWxhbnRpcmlsYWRpIHZhIDTDlzQgbWF0cml0c2Egc2hha2xpZGEgaWZvZGFsYW5hZGkuYFxuICB9KTtcbiAgXG4gIC8vIEFwcGx5IHBhZGRpbmcgaWYgbmVlZGVkXG4gIGlmIChwYWRkaW5nID09PSBQYWRkaW5nVHlwZS5BTlNJX1g5MjMpIHtcbiAgICBwbGFpbnRleHRCeXRlcyA9IGFwcGx5QW5zaVg5MjNQYWRkaW5nKHBsYWludGV4dEJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogJ0FOU0kgWC45MjMgdG/igJhsZGlyaXNoZGFuIGtleWluJywgXG4gICAgICBzdGF0ZTogcGxhaW50ZXh0Qnl0ZXMsXG4gICAgICBleHBsYW5hdGlvbjogJ0FOU0kgWC45MjMgdG/igJhsZGlyaXNoIG5vbGxhciBiaWxhbiB0b+KAmGxkaXJhZGkgdmEgb3hpcmdpIGJ5dGUgZ2EgdG/igJhsZGlyaXNoIHV6dW5saWdpbmkgcW/igJh5YWRpLidcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gR2VuZXJhdGUgSVYgZm9yIENCQy9DVFIgbW9kZSBvbmx5IGlmIG5vdCBwcm92aWRlZFxuICBpZiAoKG1vZGUgPT09IEFlc01vZGUuQ0JDIHx8IG1vZGUgPT09IEFlc01vZGUuQ1RSKSAmJiAhaXYpIHtcbiAgICBpdiA9IGdlbmVyYXRlSVYoKTtcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gT25seSBzaG93IElWIHN0ZXAgaWYgc2luZ2xlIGJsb2NrIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIGNvbnN0IGl2RGVzY3JpcHRpb24gPSBtb2RlID09PSBBZXNNb2RlLkNCQyBcbiAgICAgICAgPyAnQm9zaGxhbmdcXCdpY2ggdmVrdG9yIChJbml0aWFsaXphdGlvbiBWZWN0b3IsIElWKScgXG4gICAgICAgIDogJ0NvdW50ZXIgKE5vbmNlKSc7XG4gICAgICBjb25zdCBpdkV4cGxhbmF0aW9uID0gYCR7bW9kZSA9PT0gQWVzTW9kZS5DQkMgPyAnQ0JDJyA6ICdDVFInfSByZWppbWkgdWNodW4gMTYtYmF5dCB0YXNvZGlmaXkgJHttb2RlID09PSBBZXNNb2RlLkNCQyA/ICdJVicgOiAnTm9uY2UnfSB5YXJhdGlsYWRpLmA7XG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBpdkRlc2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogaXYsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBpdkV4cGxhbmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFN0YXJ0IGVuY3J5cHRpb24gcHJvY2VzcyAoZm9yIGZpcnN0IGJsb2NrIHZpc3VhbGl6YXRpb24pXG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHBsYWludGV4dEJ5dGVzO1xuICBcbiAgLy8gS2V5IGV4cGFuc2lvblxuICBjb25zdCByb3VuZEtleXMgPSBrZXlFeHBhbnNpb24oa2V5KTtcbiAgXG4gIC8vIEluaXRpYWwgc2V0dXAgYmFzZWQgb24gbW9kZVxuICBsZXQgY3VycmVudFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoIWl2KSBpdiA9IGdlbmVyYXRlSVYoKTsgLy8gRmFpbHNhZmVcbiAgICAgIC8vIFhPUiBwbGFpbnRleHQgd2l0aCBJVlxuICAgICAgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlLm1hcCgoYnl0ZSwgaSkgPT4gYnl0ZSBeIGl2IVtpXSlcblxuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Jvc2hsYW5nXFwnaWNoIGhvbGF0bmkgSVYgYmlsYW4gWE9SIHFpbGlzaCcsIFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgIHJvdW5kS2V5OiBpdiwgLy8gSVYgbmkgcm91bmRLZXkgc2lmYXRpZGEga28ncnNhdGlzaCB1Y2h1blxuICAgICAgICBleHBsYW5hdGlvbjogYENCQyByZWppbWlkYSBzaGlmcmxhc2ggYm9zaGxhbmlzaGlkYW4gb2xkaW4gb2NoaXEgbWF0biBJViBiaWxhbiBYT1IgcWlsaW5hZGkuIEJ1IGphcmF5b24gQ0JDIHJlamltaW5pbmcgYXNvc2l5IHh1c3VzaXlhdGlkaXIgLSBoYXIgYmlyIG9jaGlxIG1hdG4gYmxva2kgYXZ2YWxnaSBzaGlmcmxhbmdhbiBtYXRuIGJsb2tpICh5b2tpIGJpcmluY2hpIGJsb2sgdWNodW4gSVYpIGJpbGFuIFhPUiBxaWxpbmFkaSwga2V5aW4gc2hpZnJsYW5hZGkuIEJ1IGJpciB4aWwgb2NoaXEgbWF0biBibG9rbGFyaW5pIHR1cmxpIHNoaWZybGFuZ2FuIG1hdG4gYmxva2xhcmdhIGF5bGFudGlyYWRpIHZhIHNoaWZybGFuZ2FuIG1hdG5kYWdpIG5hcXNobGFybmkgeWFzaGlyaXNoZ2EgeW9yZGFtIGJlcmFkaS5gXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICAvLyBJbiBDVFIgbW9kZSwgd2UgZW5jcnlwdCBhIGNvdW50ZXIgdmFsdWUgaW5zdGVhZCBvZiB0aGUgcGxhaW50ZXh0XG4gICAgICBjb25zdCBjb3VudGVyID0gaXYgfHwgZ2VuZXJhdGVJVigpO1xuICAgICAgaWYgKCFpdikgaXYgPSBjb3VudGVyO1xuICAgICAgXG4gICAgICBzdGVwcy5wdXNoKHsgXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQ291bnRlciBxaXltYXRpJywgXG4gICAgICAgIHN0YXRlOiBjb3VudGVyLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0NUUiByZWppbWlkYSBvY2hpcSBtYXRuIG/igJhybmlnYSBjb3VudGVyIHFpeW1hdGkgc2hpZnJsYW5hZGkuJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGNvdW50ZXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBFQ0JcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ+KAmGljaCBob2xhdCAob2NoaXEgbWF0biknLCBcbiAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgZXhwbGFuYXRpb246ICdFQ0IgcmVqaW1pZGEgb2NoaXEgbWF0biBibG9rbGFyaSBtdXN0YXFpbCByYXZpc2hkYSBzaGlmcmxhbmFkaS4nXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICAvLyBJbml0aWFsIHJvdW5kIC0ganVzdCBBZGRSb3VuZEtleSAoUm91bmQgMClcbiAgY29uc3QgYWZ0ZXJJbml0aWFsUm91bmQgPSBhZGRSb3VuZEtleShjdXJyZW50U3RhdGUsIHJvdW5kS2V5c1swXSk7XG4gIHN0ZXBzLnB1c2goeyBcbiAgICBkZXNjcmlwdGlvbjogJzAtYm9zcWljaCDigJQgQm9zaGxhbmdcXCdpY2ggQWRkUm91bmRLZXknLCBcbiAgICBzdGF0ZTogYWZ0ZXJJbml0aWFsUm91bmQsXG4gICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICBleHBsYW5hdGlvbjogJycsXG4gICAgcm91bmRLZXk6IHJvdW5kS2V5c1swXSxcbiAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGUsXG4gIH0pO1xuICBcbiAgY3VycmVudFN0YXRlID0gYWZ0ZXJJbml0aWFsUm91bmQ7XG4gIFxuICAvLyBNYWluIHJvdW5kc1xuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IDEwOyByb3VuZCsrKSB7XG4gICAgLy8gU3ViQnl0ZXNcbiAgICBjb25zdCBhZnRlclN1YkJ5dGVzID0gc3ViQnl0ZXMoY3VycmVudFN0YXRlKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIFN1YkJ5dGVzYCwgXG4gICAgICBzdGF0ZTogYWZ0ZXJTdWJCeXRlcyxcbiAgICAgIGFjdGl2ZUluZGljZXM6IEFycmF5LmZyb20oQXJyYXkoMTYpLmtleXMoKSksXG4gICAgICBleHBsYW5hdGlvbjogJycsXG4gICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50U3RhdGUgLy8gQWRkIHByZXZpb3VzIHN0YXRlIGZvciBTLWJveCBsb29rdXBcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTaGlmdFJvd3NcbiAgICBjb25zdCBhZnRlclNoaWZ0Um93cyA9IHNoaWZ0Um93cyhhZnRlclN1YkJ5dGVzKTtcbiAgICBzdGVwcy5wdXNoKHsgXG4gICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIFNoaWZ0Um93c2AsIFxuICAgICAgc3RhdGU6IGFmdGVyU2hpZnRSb3dzLFxuICAgICAgYWN0aXZlSW5kaWNlczogWzEsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMSwgMTMsIDE0LCAxNV0sIC8vIFJvd3MgMSwgMiwgMyAobm90IFJvdyAwKSBpbiBjb2x1bW4tbWFqb3JcbiAgICAgIGV4cGxhbmF0aW9uOiAnJyxcbiAgICAgIHByZXZpb3VzU3RhdGU6IGFmdGVyU3ViQnl0ZXMgLy8gQWRkIHByZXZpb3VzIHN0YXRlIGZvciBjb21wYXJpc29uXG4gICAgfSk7XG4gICAgXG4gICAgbGV0IHByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleTogbnVtYmVyW107XG4gICAgXG4gICAgaWYgKHJvdW5kIDwgMTApIHtcbiAgICAgIC8vIE1peENvbHVtbnMgKG5vdCBpbiBmaW5hbCByb3VuZClcbiAgICAgIGNvbnN0IGFmdGVyTWl4Q29sdW1ucyA9IG1peENvbHVtbnMoYWZ0ZXJTaGlmdFJvd3MpO1xuICAgICAgc3RlcHMucHVzaCh7IFxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7cm91bmR9LWJvc3FpY2gg4oCUIE1peENvbHVtbnNgLCBcbiAgICAgICAgc3RhdGU6IGFmdGVyTWl4Q29sdW1ucyxcbiAgICAgICAgYWN0aXZlSW5kaWNlczogQXJyYXkuZnJvbShBcnJheSgxNikua2V5cygpKSxcbiAgICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBhZnRlclNoaWZ0Um93cyAvLyBBZGQgcHJldmlvdXMgc3RhdGUgZm9yIE1peENvbHVtbnMgY29tcGFyaXNvblxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZFJvdW5kS2V5XG4gICAgICBjdXJyZW50U3RhdGUgPSBhZGRSb3VuZEtleShhZnRlck1peENvbHVtbnMsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJNaXhDb2x1bW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5hbCByb3VuZCBoYXMgbm8gTWl4Q29sdW1uc1xuICAgICAgY3VycmVudFN0YXRlID0gYWRkUm91bmRLZXkoYWZ0ZXJTaGlmdFJvd3MsIHJvdW5kS2V5c1tyb3VuZF0pO1xuICAgICAgcHJldmlvdXNTdGF0ZUZvckFkZFJvdW5kS2V5ID0gYWZ0ZXJTaGlmdFJvd3M7XG4gICAgfVxuICAgIFxuICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtyb3VuZH0tYm9zcWljaCDigJQgQWRkUm91bmRLZXlgLCBcbiAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgcm91bmRLZXk6IHJvdW5kS2V5c1tyb3VuZF0sXG4gICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlRm9yQWRkUm91bmRLZXksXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEZpbmFsIG91dHB1dCBiYXNlZCBvbiBtb2RlXG4gIGxldCBmaW5hbFN0YXRlOiBudW1iZXJbXTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICAvLyBPdXRwdXQgaXMgdGhlIGN1cnJlbnQgc3RhdGUgKGFscmVhZHkgY29tcGxldGVkIGVuY3J5cHRpb24pXG4gICAgICBmaW5hbFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBZXNNb2RlLkNUUjpcbiAgICAgIC8vIFhPUiB0aGUgZW5jcnlwdGVkIGNvdW50ZXIgd2l0aCBwbGFpbnRleHRcbiAgICAgIGZpbmFsU3RhdGUgPSBjdXJyZW50U3RhdGUubWFwKChieXRlLCBpKSA9PiBieXRlIF4gaW5pdGlhbFN0YXRlW2ldKTtcbiAgICAgIHN0ZXBzLnB1c2goeyBcbiAgICAgICAgZGVzY3JpcHRpb246ICdPY2hpcSBtYXRuIHNoaWZybGFuZ2FuIGhpc29ibGFnaWNoIGJpbGFuIFhPUiBhbWFsaXlvdGlkYSBiaXJsYXNodGlyaWxhZGkuJywgXG4gICAgICAgIHN0YXRlOiBmaW5hbFN0YXRlLFxuICAgICAgICBhY3RpdmVJbmRpY2VzOiBBcnJheS5mcm9tKEFycmF5KDE2KS5rZXlzKCkpLFxuICAgICAgICBleHBsYW5hdGlvbjogJ0NUUiByZWppbWlkYSwgeWFrdW5peSBib3NxaWNoZGEgc2hpZnJsYW5nYW4gaGlzb2JsYWdpY2ggb2NoaXEgbWF0biBiaWxhbiBYT1IgYW1hbGl5b3RpIG9ycWFsaSBiaXJsYXNodGlyaWxhZGkgdmEgbmF0aWphZGEgc2hpZnJsYW5nYW4gbWF0biBob3NpbCBib+KAmGxhZGkuJyxcbiAgICAgICAgcHJldmlvdXNTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgICByb3VuZEtleTogY3VycmVudFN0YXRlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgZmluYWxTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBzdGVwcy5wdXNoKHsgXG4gICAgZGVzY3JpcHRpb246ICdZYWt1bml5IHNoaWZybGFuZ2FuIG1hdG4nLCBcbiAgICBzdGF0ZTogZmluYWxTdGF0ZSxcbiAgICBleHBsYW5hdGlvbjogYCR7bW9kZX0gcmVqaW1pZGEgQUVTLTEyOCB5b3JkYW1pZGEgb2xpbmdhbiB5YWt1bml5IHNoaWZybGFuZ2FuIG5hdGlqYS5gXG4gIH0pO1xuICBcbiAgLy8gUHJvY2VzcyBhbGwgYmxvY2tzIGZvciBtdWx0aS1ibG9jayBzdXBwb3J0XG4gIGxldCBwcmV2aW91c0NpcGhlcnRleHRCbG9jazogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGNvbWJpbmVkRmluYWxTdGF0ZXM6IG51bWJlcltdID0gW107XG4gIFxuICAvLyBHZW5lcmF0ZSBJViBpZiBuZWVkZWRcbiAgaWYgKChtb2RlID09PSBBZXNNb2RlLkNCQyB8fCBtb2RlID09PSBBZXNNb2RlLkNUUikgJiYgIWl2KSB7XG4gICAgaXYgPSBnZW5lcmF0ZUlWKCk7XG4gIH1cbiAgXG4gIGZvciAobGV0IGJsb2NrSW5kZXggPSAwOyBibG9ja0luZGV4IDwgYmxvY2tzLmxlbmd0aDsgYmxvY2tJbmRleCsrKSB7XG4gICAgY29uc3QgYmxvY2tSZXN1bHQgPSBnZXRBZXNTdGVwc0ZvckJsb2NrKFxuICAgICAgYmxvY2tzW2Jsb2NrSW5kZXhdLFxuICAgICAga2V5LFxuICAgICAgbW9kZSxcbiAgICAgIGJsb2NrSW5kZXgsXG4gICAgICBwcmV2aW91c0NpcGhlcnRleHRCbG9jayxcbiAgICAgIGl2XG4gICAgKTtcbiAgICBcbiAgICBhbGxCbG9ja3MucHVzaCh7XG4gICAgICBibG9ja0luZGV4LFxuICAgICAgc3RlcHM6IGJsb2NrUmVzdWx0LnN0ZXBzLFxuICAgICAgZmluYWxTdGF0ZTogYmxvY2tSZXN1bHQuZmluYWxTdGF0ZVxuICAgIH0pO1xuICAgIFxuICAgIGNvbWJpbmVkRmluYWxTdGF0ZXMucHVzaCguLi5ibG9ja1Jlc3VsdC5maW5hbFN0YXRlKTtcbiAgICBcbiAgICAvLyBGb3IgQ0JDIG1vZGUsIHVzZSBjdXJyZW50IGNpcGhlcnRleHQgYXMgcHJldmlvdXMgZm9yIG5leHQgYmxvY2tcbiAgICBpZiAobW9kZSA9PT0gQWVzTW9kZS5DQkMpIHtcbiAgICAgIHByZXZpb3VzQ2lwaGVydGV4dEJsb2NrID0gYmxvY2tSZXN1bHQuZmluYWxTdGF0ZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFVzZSBjb21iaW5lZCBmaW5hbCBzdGF0ZXMgaWYgd2UgaGF2ZSBtdWx0aXBsZSBibG9ja3MsIG90aGVyd2lzZSB1c2Ugc2luZ2xlIGJsb2NrIHJlc3VsdFxuICBjb25zdCBmaW5hbFN0YXRlVG9Vc2UgPSBibG9ja3MubGVuZ3RoID4gMSA/IGNvbWJpbmVkRmluYWxTdGF0ZXMgOiBmaW5hbFN0YXRlO1xuICBcbiAgLy8gQ29udmVydCB0aGUgZmluYWwgc3RhdGUgdG8gdGhlIHJlcXVlc3RlZCBvdXRwdXQgZm9ybWF0XG4gIGNvbnN0IGZpbmFsV29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoXG4gICAgbmV3IFVpbnQ4QXJyYXkoZmluYWxTdGF0ZVRvVXNlKSBhcyBhbnlcbiAgKTtcbiAgXG4gIGNvbnN0IGZpbmFsQ2lwaGVydGV4dEJhc2U2NCA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KGZpbmFsV29yZEFycmF5KTtcbiAgY29uc3QgZmluYWxDaXBoZXJ0ZXh0SGV4ID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkoZmluYWxXb3JkQXJyYXkpO1xuICBjb25zdCBmaW5hbENpcGhlcnRleHRCaW5hcnkgPSBieXRlc1RvQmluYXJ5KGZpbmFsU3RhdGVUb1VzZSwgJycpO1xuICBcbiAgcmV0dXJuIHsgXG4gICAgc3RlcHMsIFxuICAgIGZpbmFsQ2lwaGVydGV4dDoge1xuICAgICAgYmFzZTY0OiBmaW5hbENpcGhlcnRleHRCYXNlNjQsXG4gICAgICBoZXg6IGZpbmFsQ2lwaGVydGV4dEhleCxcbiAgICAgIGJpbmFyeTogZmluYWxDaXBoZXJ0ZXh0QmluYXJ5XG4gICAgfSwgXG4gICAgaXYsXG4gICAgYWxsQmxvY2tzOiBhbGxCbG9ja3MubGVuZ3RoID4gMSA/IGFsbEJsb2NrcyA6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuLy8gR2V0IGtleSBleHBhbnNpb24gc3RlcHMgd2l0aCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRLZXlFeHBhbnNpb25TdGVwcyA9IChrZXk6IG51bWJlcltdKTogeyBcbiAgZGVzY3JpcHRpb246IHN0cmluZywgXG4gIGtleTogbnVtYmVyW10sXG4gIGV4cGxhbmF0aW9uPzogc3RyaW5nLFxuICBoaWdobGlnaHRlZENlbGxzPzogbnVtYmVyW11cbn1bXSA9PiB7XG4gIGNvbnN0IHJvdW5kS2V5cyA9IGtleUV4cGFuc2lvbihrZXkpO1xuICBjb25zdCBzdGVwcyA9IFtdO1xuICBcbiAgc3RlcHMucHVzaCh7XG4gICAgZGVzY3JpcHRpb246ICdCb3NobGFuZ+KAmGljaCBrYWxpdCcsXG4gICAga2V5OiByb3VuZEtleXNbMF0sXG4gICAgZXhwbGFuYXRpb246ICdCdSBmb3lkYWxhbnV2Y2hpIHRvbW9uaWRhbiBiZXJpbGdhbiBhc2wgMTI4LWJpdGxpIGthbGl0ZGlyLidcbiAgfSk7XG4gIFxuICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDw9IDEwOyByb3VuZCsrKSB7XG4gICAgY29uc3QgcHJldktleSA9IHJvdW5kS2V5c1tyb3VuZCAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRLZXkgPSByb3VuZEtleXNbcm91bmRdO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtYXRpb25zIGZvciBhIG1vcmUgZGV0YWlsZWQgZXhwbGFuYXRpb25cbiAgICBjb25zdCBsYXN0V29yZCA9IFtwcmV2S2V5WzEyXSwgcHJldktleVsxM10sIHByZXZLZXlbMTRdLCBwcmV2S2V5WzE1XV07XG4gICAgY29uc3Qgcm90V29yZCA9IFtsYXN0V29yZFsxXSwgbGFzdFdvcmRbMl0sIGxhc3RXb3JkWzNdLCBsYXN0V29yZFswXV07XG4gICAgY29uc3Qgc2JveFdvcmQgPSByb3RXb3JkLm1hcChieXRlID0+IFNCT1hbYnl0ZV0pO1xuICAgIGNvbnN0IHJjb25WYWx1ZSA9IFJDT05bcm91bmRdO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkV29yZCA9IFsuLi5zYm94V29yZF07XG4gICAgdHJhbnNmb3JtZWRXb3JkWzBdIF49IHJjb25WYWx1ZTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIHByZXZpb3VzIGtleSBhbmQgaXRzIFhPUiB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB3b3JkXG4gICAgY29uc3QgZmlyc3RXb3JkUHJldiA9IFtwcmV2S2V5WzBdLCBwcmV2S2V5WzFdLCBwcmV2S2V5WzJdLCBwcmV2S2V5WzNdXTtcbiAgICBjb25zdCB4b3JSZXN1bHQgPSBmaXJzdFdvcmRQcmV2Lm1hcCgoYnl0ZSwgaW5kZXgpID0+IGJ5dGUgXiB0cmFuc2Zvcm1lZFdvcmRbaW5kZXhdKTtcblxuXG4gICAgLy8gU2hvdyB0aGUga2V5IHdpdGggaGlnaGxpZ2h0ZWQgY2VsbHMgZm9yIHRoZSBuZXcgd29yZFxuICAgIHN0ZXBzLnB1c2goe1xuICAgICAgZGVzY3JpcHRpb246IGBSYXVuZCBrYWxpdGkgJHtyb3VuZH1gLFxuICAgICAga2V5OiBjdXJyZW50S2V5LFxuICAgICAgZXhwbGFuYXRpb246IGBcbiAgICAgICAgJHtyb3VuZH0tcmF1bmQgdWNodW4ga2FsaXRuaSBrZW5nYXl0aXJpc2ggamFyYXlvbmk6XG4gICAgICAgIDEuIE9sZGluZ2kga2FsaXRuaW5nIG94aXJnaSB3b3JkIHFpc21pbmkgb2xpbmc6IFske2xhc3RXb3JkLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJywgJyl9XVxuICAgICAgICAyLiBXb3JkbmkgYXlsYW50aXJpbmc6IFske3JvdFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDMuIEF5bGFudGlyaWxnYW4gd29yZCBnYSBTLWJveCBuaSBxb+KAmGxsYW5nOiBbJHtzYm94V29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV1cbiAgICAgICAgNC4gQmlyaW5jaGkgYmF5dGdhIFJDT04gKFJvdW5kIENvbnN0YW50ICR7cmNvblZhbHVlLnRvU3RyaW5nKDE2KX0pIG5pIHFv4oCYbGxhbmc6XG4gICAgICAgICAgTmF0aWphOiBbJHt0cmFuc2Zvcm1lZFdvcmQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dXG4gICAgICAgIDUuIE9sZGluZ2kga2FsaXRuaW5nIGJpcmluY2hpIHdvcmQgaTogWyR7Zmlyc3RXb3JkUHJldi5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV0gbmkgb+KAmHpnYXJ0aXJpbGdhbiB3b3JkIGJpbGFuIFhPUiBxaWxpbmc6IFske3RyYW5zZm9ybWVkV29yZC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcsICcpfV0sIG5hdGlqYWRhOiBbJHt4b3JSZXN1bHQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignLCAnKX1dIGhvc2lsIGJv4oCYbGFkaS4gU2/igJhuZ3JhIHFvbGdhbiB3b3JkIGxhciBzaHUgdGFyemRhIGhvc2lsIHFpbGluYWRpLlxuICAgICAgYCxcbiAgICAgIGhpZ2hsaWdodGVkQ2VsbHM6IFswLCAxLCAyLCAzXSAvLyBIaWdobGlnaHQgdGhlIGZpcnN0IHdvcmQgdGhhdCdzIGRpcmVjdGx5IHRyYW5zZm9ybWVkXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBzdGVwcztcbn07XG5cbi8vIFJldHVybiBpbnRlcm1lZGlhdGUgc3RlcHMgZm9yIGVhY2ggd29yZCBleHBhbnNpb24gZm9yIHZpc3VhbGl6YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlTY2hlZHVsZURldGFpbGVkU3RlcHMoa2V5OiBudW1iZXJbXSwga2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgpIHtcbiAgY29uc3Qga2V5V29yZHMgPSBrZXkubGVuZ3RoIC8gNDtcbiAgY29uc3QgbnVtUm91bmRzID0ga2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzEyOCA/IDEwIDoga2V5TGVuZ3RoID09PSBLZXlMZW5ndGguQUVTXzE5MiA/IDEyIDogMTQ7XG5cbiAgLy8gRmxhdHRlbiBieXRlIGFycmF5IC0+IHdvcmRzXG4gIGxldCBwcmV2S2V5ID0ga2V5LnNsaWNlKCk7XG4gIGxldCByb3VuZEtleXMgPSBbcHJldktleS5zbGljZSgpXTtcblxuICAvLyBGb3IgcmVzdWx0IHZpc3VhbGl6YXRpb246IGVhY2ggc3RlcCBmb3IgZWFjaCByb3VuZFxuICBsZXQgc3RlcHNQZXJSb3VuZCA9IFtdO1xuXG4gIGZvciAobGV0IHJvdW5kID0gMTsgcm91bmQgPD0gbnVtUm91bmRzOyByb3VuZCsrKSB7XG4gICAgbGV0IHN0ZXBEZXRhaWxzID0gW107XG4gICAgbGV0IG5ld0tleSA9IHByZXZLZXkuc2xpY2UoKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBwcmV2S2V5Lmxlbmd0aCAtIDQ7XG4gICAgY29uc3QgbGFzdFdvcmQgPSBbcHJldktleVtsYXN0SW5kZXhdLCBwcmV2S2V5W2xhc3RJbmRleCArIDFdLCBwcmV2S2V5W2xhc3RJbmRleCArIDJdLCBwcmV2S2V5W2xhc3RJbmRleCArIDNdXTtcblxuICAgIC8vIFN0ZXAgMTogUm90V29yZFxuICAgIGNvbnN0IHJvdFdvcmQgPSBbbGFzdFdvcmRbMV0sIGxhc3RXb3JkWzJdLCBsYXN0V29yZFszXSwgbGFzdFdvcmRbMF1dO1xuICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgc3RlcDogJ1JvdFdvcmQnLCBpbnB1dDogbGFzdFdvcmQuc2xpY2UoKSwgb3V0cHV0OiByb3RXb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDI6IFN1YkJ5dGVzIChTLWJveClcbiAgICBjb25zdCBzYm94V29yZCA9IHJvdFdvcmQubWFwKGJ5dGUgPT4gU0JPWFtieXRlXSk7XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnU3ViQnl0ZXMnLCBpbnB1dDogcm90V29yZC5zbGljZSgpLCBvdXRwdXQ6IHNib3hXb3JkLnNsaWNlKClcbiAgICB9KTtcbiAgICAvLyBTdGVwIDM6IFJjb24gdG8gZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJjb25WYWx1ZSA9IFJDT05bcm91bmRdO1xuICAgIGNvbnN0IHJjb25Xb3JkID0gc2JveFdvcmQuc2xpY2UoKTtcbiAgICByY29uV29yZFswXSBePSByY29uVmFsdWU7XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnQXBwbHkgUmNvbicsIGlucHV0OiBzYm94V29yZC5zbGljZSgpLCByY29uOiByY29uVmFsdWUsIG91dHB1dDogcmNvbldvcmQuc2xpY2UoKVxuICAgIH0pO1xuICAgIC8vIFN0ZXAgNDogWE9SIHdpdGggcHJldmlvdXMgKGZpcnN0IHdvcmQpXG4gICAgY29uc3QgeG9yUmVzdWx0ID0gW1xuICAgICAgcHJldktleVswXSBeIHJjb25Xb3JkWzBdLFxuICAgICAgcHJldktleVsxXSBeIHJjb25Xb3JkWzFdLFxuICAgICAgcHJldktleVsyXSBeIHJjb25Xb3JkWzJdLFxuICAgICAgcHJldktleVszXSBeIHJjb25Xb3JkWzNdLFxuICAgIF07XG4gICAgc3RlcERldGFpbHMucHVzaCh7XG4gICAgICBzdGVwOiAnWE9SIHdpdGggcHJldmlvdXMnLCBpbnB1dHM6IFtwcmV2S2V5LnNsaWNlKDAsNCksIHJjb25Xb3JkLnNsaWNlKCldLCBvdXRwdXQ6IHhvclJlc3VsdC5zbGljZSgpXG4gICAgfSk7XG4gICAgLy8gU2F2ZSBhbmQgdXBkYXRlIG5ld0tleVxuICAgIG5ld0tleVswXSA9IHhvclJlc3VsdFswXTtcbiAgICBuZXdLZXlbMV0gPSB4b3JSZXN1bHRbMV07XG4gICAgbmV3S2V5WzJdID0geG9yUmVzdWx0WzJdO1xuICAgIG5ld0tleVszXSA9IHhvclJlc3VsdFszXTtcbiAgICAvLyBPdGhlciB3b3JkcyAob25seSBzaW1wbGUgeG9yKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5V29yZHM7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG4gICAgICBuZXdLZXlbb2Zmc2V0XSA9IG5ld0tleVtvZmZzZXQgLSA0XSBeIHByZXZLZXlbb2Zmc2V0XTtcbiAgICAgIG5ld0tleVtvZmZzZXQgKyAxXSA9IG5ld0tleVtvZmZzZXQgLSAzXSBeIHByZXZLZXlbb2Zmc2V0ICsgMV07XG4gICAgICBuZXdLZXlbb2Zmc2V0ICsgMl0gPSBuZXdLZXlbb2Zmc2V0IC0gMl0gXiBwcmV2S2V5W29mZnNldCArIDJdO1xuICAgICAgbmV3S2V5W29mZnNldCArIDNdID0gbmV3S2V5W29mZnNldCAtIDFdIF4gcHJldktleVtvZmZzZXQgKyAzXTtcbiAgICAgIHN0ZXBEZXRhaWxzLnB1c2goe1xuICAgICAgICBzdGVwOiAnWE9SIGNoYWluJywgaW5wdXRzOiBbXG4gICAgICAgICAgbmV3S2V5LnNsaWNlKG9mZnNldCAtIDQsIG9mZnNldCksXG4gICAgICAgICAgcHJldktleS5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpXG4gICAgICAgIF0sIG91dHB1dDogbmV3S2V5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNCksIHdvcmRJbmRleDogaVxuICAgICAgfSk7XG4gICAgfVxuICAgIHN0ZXBzUGVyUm91bmQucHVzaCh7IHJvdW5kLCBzdGVwRGV0YWlscywgcm91bmRLZXk6IG5ld0tleS5zbGljZSgpIH0pO1xuICAgIHByZXZLZXkgPSBuZXdLZXkuc2xpY2UoKTtcbiAgICByb3VuZEtleXMucHVzaChwcmV2S2V5KTtcbiAgfVxuICByZXR1cm4gc3RlcHNQZXJSb3VuZDtcbn1cblxuLy8gUmVhbCBBRVMgZW5jcnlwdGlvbiB1c2luZyBDcnlwdG9KUyBmb3IgdmVyaWZpY2F0aW9uXG5leHBvcnQgY29uc3QgcmVhbEFlc0VuY3J5cHQgPSAoXG4gIHBsYWludGV4dDogc3RyaW5nLFxuICBrZXk6IHN0cmluZyxcbiAgbW9kZTogQWVzTW9kZSA9IEFlc01vZGUuRUNCLFxuICBwYWRkaW5nOiBQYWRkaW5nVHlwZSA9IFBhZGRpbmdUeXBlLlBLQ1M3LFxuICBvdXRwdXRGb3JtYXQ6IE91dHB1dEZvcm1hdCA9IE91dHB1dEZvcm1hdC5CQVNFNjQsXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgsXG4gIGl2U3RyaW5nPzogc3RyaW5nXG4pOiB7IGNpcGhlcnRleHQ6IHN0cmluZywgaXY/OiBzdHJpbmcsIGZvcm1hdHM6IHsgYmFzZTY0OiBzdHJpbmcsIGhleDogc3RyaW5nLCBiaW5hcnk6IHN0cmluZyB9IH0gPT4ge1xuICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBrZXkgaXMgc2hvcnRlciB0aGFuIHJlcXVpcmVkIGJ5IGtleUxlbmd0aFxuICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICBsZXQga2V5SGV4ID0gY2xlYW5LZXkubGVuZ3RoICUgMiA9PT0gMSA/IGNsZWFuS2V5ICsgJzAnIDogY2xlYW5LZXk7XG4gIFxuICAvLyBFbnN1cmUga2V5IGlzIG9mIGNvcnJlY3QgbGVuZ3RoIGZvciB0aGUgc2VsZWN0ZWQga2V5IGxlbmd0aFxuICBjb25zdCByZXF1aXJlZEhleENoYXJzID0ga2V5TGVuZ3RoIC8gNDsgLy8gRWFjaCBoZXggY2hhciBpcyA0IGJpdHNcbiAgaWYgKGtleUhleC5sZW5ndGggPCByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgLy8gUGFkIGtleSBpZiB0b28gc2hvcnRcbiAgICBrZXlIZXggPSBrZXlIZXgucGFkRW5kKHJlcXVpcmVkSGV4Q2hhcnMsICcwJyk7XG4gIH0gZWxzZSBpZiAoa2V5SGV4Lmxlbmd0aCA+IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAvLyBUcnVuY2F0ZSBrZXkgaWYgdG9vIGxvbmdcbiAgICBrZXlIZXggPSBrZXlIZXguc3Vic3RyaW5nKDAsIHJlcXVpcmVkSGV4Q2hhcnMpO1xuICB9XG4gIFxuICBjb25zdCBrZXlXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGtleUhleCk7XG4gIFxuICBsZXQgcGFkZGluZ09wdGlvbjogYW55O1xuICBzd2l0Y2ggKHBhZGRpbmcpIHtcbiAgICBjYXNlIFBhZGRpbmdUeXBlLkFOU0lfWDkyMzpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7IHBhZGRpbmc6IENyeXB0b0pTLnBhZC5BbnNpWDkyMyB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQYWRkaW5nVHlwZS5OT05FOlxuICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhZGRpbmdPcHRpb24gPSB7fTsgLy8gZGVmYXVsdCBpcyBQS0NTN1xuICB9XG4gIFxuICBsZXQgbW9kZU9wdGlvbjogYW55O1xuICBsZXQgaXY6IGFueTtcbiAgXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgQWVzTW9kZS5DQkM6XG4gICAgICBpZiAoaXZTdHJpbmcpIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAgICB9XG4gICAgICBtb2RlT3B0aW9uID0geyBcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgICAgIGl2OiBpdixcbiAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWVzTW9kZS5DVFI6XG4gICAgICBpZiAoaXZTdHJpbmcpIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXYgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAgICB9XG4gICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNUUixcbiAgICAgICAgaXY6IGl2LFxuICAgICAgICBjb3VudGVyOiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMCwgMCwgMCwgMF0sIDE2KSxcbiAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEVDQlxuICAgICAgbW9kZU9wdGlvbiA9IHtcbiAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgY29uc3QgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQocGxhaW50ZXh0LCBrZXlXb3JkQXJyYXksIG1vZGVPcHRpb24pO1xuICBcbiAgLy8gR2V0IGFsbCBvdXRwdXQgZm9ybWF0c1xuICBjb25zdCBiYXNlNjRPdXRwdXQgPSBlbmNyeXB0ZWQudG9TdHJpbmcoKTtcbiAgY29uc3QgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuICAgIGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0T3V0cHV0KVxuICB9KTtcbiAgY29uc3QgaGV4T3V0cHV0ID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgXG4gIC8vIEZvciBiaW5hcnksIHdlIG5lZWQgdG8gY29udmVydCB0aGUgaGV4IHRvIGJpbmFyeVxuICBjb25zdCBoZXhCeXRlcyA9IGhleE91dHB1dC5tYXRjaCgvLnsyfS9nKSEubWFwKGhleCA9PiBwYXJzZUludChoZXgsIDE2KSk7XG4gIGNvbnN0IGJpbmFyeU91dHB1dCA9IGJ5dGVzVG9CaW5hcnkoaGV4Qnl0ZXMsICcnKTtcbiAgXG4gIC8vIFNlbGVjdCB0aGUgcmVxdWVzdGVkIGZvcm1hdCBmb3IgcHJpbWFyeSBvdXRwdXRcbiAgbGV0IHByaW1hcnlPdXRwdXQ6IHN0cmluZztcbiAgc3dpdGNoIChvdXRwdXRGb3JtYXQpIHtcbiAgICBjYXNlIE91dHB1dEZvcm1hdC5IRVg6XG4gICAgICBwcmltYXJ5T3V0cHV0ID0gaGV4T3V0cHV0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPdXRwdXRGb3JtYXQuQklOQVJZOlxuICAgICAgcHJpbWFyeU91dHB1dCA9IGJpbmFyeU91dHB1dDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIEJBU0U2NFxuICAgICAgcHJpbWFyeU91dHB1dCA9IGJhc2U2NE91dHB1dDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICByZXR1cm4geyBcbiAgICBjaXBoZXJ0ZXh0OiBwcmltYXJ5T3V0cHV0LFxuICAgIGl2OiBpdiA/IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KGl2KSA6IHVuZGVmaW5lZCxcbiAgICBmb3JtYXRzOiB7XG4gICAgICBiYXNlNjQ6IGJhc2U2NE91dHB1dCxcbiAgICAgIGhleDogaGV4T3V0cHV0LFxuICAgICAgYmluYXJ5OiBiaW5hcnlPdXRwdXRcbiAgICB9XG4gIH07XG59O1xuXG4vLyBSZWFsIEFFUyBkZWNyeXB0aW9uIHVzaW5nIENyeXB0b0pTXG5leHBvcnQgY29uc3QgcmVhbEFlc0RlY3J5cHQgPSAoXG4gIGNpcGhlcnRleHQ6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIG1vZGU6IEFlc01vZGUgPSBBZXNNb2RlLkVDQixcbiAgcGFkZGluZzogUGFkZGluZ1R5cGUgPSBQYWRkaW5nVHlwZS5QS0NTNyxcbiAgaW5wdXRGb3JtYXQ6IE91dHB1dEZvcm1hdCA9IE91dHB1dEZvcm1hdC5CQVNFNjQsXG4gIGtleUxlbmd0aDogS2V5TGVuZ3RoID0gS2V5TGVuZ3RoLkFFU18xMjgsXG4gIGl2U3RyaW5nPzogc3RyaW5nXG4pOiB7IHBsYWludGV4dDogc3RyaW5nLCBlcnJvcj86IHN0cmluZyB9ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBrZXkgaXMgc2hvcnRlciB0aGFuIHJlcXVpcmVkIGJ5IGtleUxlbmd0aFxuICAgIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgbGV0IGtleUhleCA9IGNsZWFuS2V5Lmxlbmd0aCAlIDIgPT09IDEgPyBjbGVhbktleSArICcwJyA6IGNsZWFuS2V5O1xuICAgIFxuICAgIC8vIEVuc3VyZSBrZXkgaXMgb2YgY29ycmVjdCBsZW5ndGggZm9yIHRoZSBzZWxlY3RlZCBrZXkgbGVuZ3RoXG4gICAgY29uc3QgcmVxdWlyZWRIZXhDaGFycyA9IGtleUxlbmd0aCAvIDQ7IC8vIEVhY2ggaGV4IGNoYXIgaXMgNCBiaXRzXG4gICAgaWYgKGtleUhleC5sZW5ndGggPCByZXF1aXJlZEhleENoYXJzKSB7XG4gICAgICAvLyBQYWQga2V5IGlmIHRvbyBzaG9ydFxuICAgICAga2V5SGV4ID0ga2V5SGV4LnBhZEVuZChyZXF1aXJlZEhleENoYXJzLCAnMCcpO1xuICAgIH0gZWxzZSBpZiAoa2V5SGV4Lmxlbmd0aCA+IHJlcXVpcmVkSGV4Q2hhcnMpIHtcbiAgICAgIC8vIFRydW5jYXRlIGtleSBpZiB0b28gbG9uZ1xuICAgICAga2V5SGV4ID0ga2V5SGV4LnN1YnN0cmluZygwLCByZXF1aXJlZEhleENoYXJzKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qga2V5V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShrZXlIZXgpO1xuICAgIFxuICAgIC8vIFBhcnNlIGNpcGhlcnRleHQgYmFzZWQgb24gaW5wdXQgZm9ybWF0XG4gICAgbGV0IGNpcGhlcnRleHRXb3JkQXJyYXk6IGFueTtcbiAgICBzd2l0Y2ggKGlucHV0Rm9ybWF0KSB7XG4gICAgICBjYXNlIE91dHB1dEZvcm1hdC5IRVg6XG4gICAgICAgIGNpcGhlcnRleHRXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGNpcGhlcnRleHQucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPdXRwdXRGb3JtYXQuQklOQVJZOlxuICAgICAgICAvLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgdG8gaGV4IGZpcnN0XG4gICAgICAgIGNvbnN0IGhleEZyb21CaW5hcnkgPSBjaXBoZXJ0ZXh0LnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goLy57OH0vZyk/Lm1hcChiaW4gPT4gcGFyc2VJbnQoYmluLCAyKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJykgfHwgJyc7XG4gICAgICAgIGNpcGhlcnRleHRXb3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleEZyb21CaW5hcnkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIEJBU0U2NFxuICAgICAgICBjaXBoZXJ0ZXh0V29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGxldCBwYWRkaW5nT3B0aW9uOiBhbnk7XG4gICAgc3dpdGNoIChwYWRkaW5nKSB7XG4gICAgICBjYXNlIFBhZGRpbmdUeXBlLkFOU0lfWDkyMzpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHsgcGFkZGluZzogQ3J5cHRvSlMucGFkLkFuc2lYOTIzIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWRkaW5nVHlwZS5OT05FOlxuICAgICAgICBwYWRkaW5nT3B0aW9uID0geyBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFkZGluZ09wdGlvbiA9IHt9OyAvLyBkZWZhdWx0IGlzIFBLQ1M3XG4gICAgfVxuICAgIFxuICAgIGxldCBtb2RlT3B0aW9uOiBhbnk7XG4gICAgbGV0IGl2OiBhbnk7XG4gICAgXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFlc01vZGUuQ0JDOlxuICAgICAgICBpZiAoIWl2U3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdDQkMgcmVqaW1pIHVjaHVuIElWIGtlcmFrJyB9O1xuICAgICAgICB9XG4gICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShpdlN0cmluZy5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgbW9kZU9wdGlvbiA9IHsgXG4gICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgIC4uLnBhZGRpbmdPcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFlc01vZGUuQ1RSOlxuICAgICAgICBpZiAoIWl2U3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGxhaW50ZXh0OiAnJywgZXJyb3I6ICdDVFIgcmVqaW1pIHVjaHVuIElWIChOb25jZSkga2VyYWsnIH07XG4gICAgICAgIH1cbiAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGl2U3RyaW5nLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBtb2RlT3B0aW9uID0ge1xuICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ1RSLFxuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICBjb3VudGVyOiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMCwgMCwgMCwgMF0sIDE2KSxcbiAgICAgICAgICAuLi5wYWRkaW5nT3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gRUNCXG4gICAgICAgIG1vZGVPcHRpb24gPSB7XG4gICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgICAgICAgLi4ucGFkZGluZ09wdGlvblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGVjcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoXG4gICAgICB7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXkgfSBhcyBhbnksXG4gICAgICBrZXlXb3JkQXJyYXksXG4gICAgICBtb2RlT3B0aW9uXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBwbGFpbnRleHQgPSBkZWNyeXB0ZWQudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuICAgIFxuICAgIGlmICghcGxhaW50ZXh0KSB7XG4gICAgICByZXR1cm4geyBwbGFpbnRleHQ6ICcnLCBlcnJvcjogJ0Rlc2hpZnJsYXNoIG11dmFmZmFxaXlhdHNpei4gS2FsaXQgeW9raSBzaGlmcmxhbmdhbiBtYXRuIG5vdG9cXCdnXFwncmkuJyB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBwbGFpbnRleHQgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7IHBsYWludGV4dDogJycsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdEZXNoaWZybGFzaGRhIHhhdG9saWsgeXV6IGJlcmRpJyB9O1xuICB9XG59O1xuXG4vLyBUZXN0IHNwZWNpZmljIGNhc2UgZm9yIFwiU2Fsb20sIEFFUyFcIiB3aXRoIGtleSBcImNjIDBlIGMxIDcwIDI0IDI0IDAxIDhkIDRlIGZkIDVlIGYzIDhkIDE1IDJmIDYzXCJcbmV4cG9ydCBjb25zdCB0ZXN0U3BlY2lmaWNDYXNlID0gKCk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHBsYWludGV4dCA9IFwiU2Fsb20sIEFFUyFcIjtcbiAgY29uc3Qga2V5ID0gXCJjYyAwZSBjMSA3MCAyNCAyNCAwMSA4ZCA0ZSBmZCA1ZSBmMyA4ZCAxNSAyZiA2M1wiO1xuICBcbiAgLy8gQ3JlYXRlIGtleSBhbmQgaW5wdXQgYXMgYnl0ZSBhcnJheXNcbiAgY29uc3Qga2V5Qnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBrZXlCeXRlcy5wdXNoKHBhcnNlSW50KGtleS5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgXG4gIC8vIFVzZSBvdXIgaW1wbGVtZW50YXRpb25cbiAgY29uc3QgeyBmaW5hbENpcGhlcnRleHQgfSA9IGdldEFlc1N0ZXBzKHBsYWludGV4dCwga2V5Qnl0ZXMsIEFlc01vZGUuRUNCLCBQYWRkaW5nVHlwZS5QS0NTNyk7XG4gIFxuICAvLyBVc2UgQ3J5cHRvSlMgaW1wbGVtZW50YXRpb25cbiAgY29uc3QgY3J5cHRvUmVzdWx0ID0gcmVhbEFlc0VuY3J5cHQocGxhaW50ZXh0LCBrZXksIEFlc01vZGUuRUNCLCBQYWRkaW5nVHlwZS5QS0NTNywgT3V0cHV0Rm9ybWF0LkhFWCk7XG4gIFxuICByZXR1cm4gYFxuICAgIEJpem5pbmcgaW1wbGVtZW50YXRzaXlhbWl6IChIRVgpOiAke2ZpbmFsQ2lwaGVydGV4dC5oZXh9XG4gICAgQ3J5cHRvSlMgaW1wbGVtZW50YXRzaXlhc2kgKEhFWCk6ICR7Y3J5cHRvUmVzdWx0LmZvcm1hdHMuaGV4fVxuICAgIEt1dGlsYXlvdGdhbiBuYXRpamE6IDMwNDg0QjhGOEM2QkIwOUNBM0Y5NEM2Rjg0RjAzMDVFXG4gIGA7XG59O1xuIl0sIm5hbWVzIjpbIkNyeXB0b0pTIiwiQWVzTW9kZSIsIlBhZGRpbmdUeXBlIiwiT3V0cHV0Rm9ybWF0IiwiS2V5TGVuZ3RoIiwiZ2V0TnVtUm91bmRzIiwia2V5TGVuZ3RoIiwiZ2V0S2V5Qnl0ZUxlbmd0aCIsIlNCT1giLCJSQ09OIiwiR0FMT0lTX01VTF8yIiwiR0FMT0lTX01VTF8zIiwidGV4dFRvU3RhdGUiLCJ0ZXh0Iiwid29yZEFycmF5IiwiZW5jIiwiVXRmOCIsInBhcnNlIiwiYnl0ZXMiLCJzaWdCeXRlcyIsImkiLCJ3b3JkcyIsImxlbmd0aCIsIndvcmQiLCJieXRlc0luVGhpc1dvcmQiLCJNYXRoIiwibWluIiwicHVzaCIsImJsb2NrIiwic2xpY2UiLCJrZXlUb0J5dGVzIiwia2V5IiwicmVxdWlyZWRCeXRlcyIsInJlcXVpcmVkSGV4TGVuZ3RoIiwiY2xlYW5LZXkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwicGFyc2VJbnQiLCJzdWJzdHIiLCJnZW5lcmF0ZVJhbmRvbUtleSIsImtleUJ5dGVzIiwiZmxvb3IiLCJyYW5kb20iLCJieXRlc1RvSGV4Iiwiam9pbkNoYXIiLCJtYXAiLCJieXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJieXRlc1RvQmluYXJ5Iiwic3ViQnl0ZXMiLCJzdGF0ZSIsInNoaWZ0Um93cyIsInJlc3VsdCIsImlkeCIsInJvdyIsImNvbCIsInJvd1ZhbHVlcyIsInNoaWZ0ZWQiLCJjb25jYXQiLCJtaXhDb2x1bW5zIiwiczAiLCJzMSIsInMyIiwiczMiLCJhZGRSb3VuZEtleSIsInJvdW5kS2V5Iiwia2V5RXhwYW5zaW9uIiwibm9ybWFsaXplZEtleSIsImtleVdvcmRzIiwibnVtUm91bmRzIiwicm91bmRLZXlzIiwicm91bmQiLCJwcmV2S2V5IiwibmV3S2V5IiwibGFzdEluZGV4IiwibGFzdFdvcmQiLCJyb3RXb3JkIiwic3ViV29yZCIsIm9mZnNldCIsInRlbXBXb3JkIiwic3ViVGVtcFdvcmQiLCJhZXNSb3VuZCIsImlzTGFzdFJvdW5kIiwibmV3U3RhdGUiLCJhZXNFbmNyeXB0IiwicGxhaW50ZXh0IiwiY3VycmVudFN0YXRlIiwidGV4dFRvQmxvY2tzIiwicGFkZGluZyIsInBhZGRlZEJ5dGVzIiwiYXBwbHlQS0NTN1BhZGRpbmciLCJhcHBseUFuc2lYOTIzUGFkZGluZyIsImJsb2NrcyIsImRhdGEiLCJwYWRkZWQiLCJwYWRkaW5nTGVuZ3RoIiwicmVtb3ZlQW5zaVg5MjNQYWRkaW5nIiwiZ2VuZXJhdGVJViIsIml2IiwiZ2V0QWVzU3RlcHNGb3JCbG9jayIsIm1vZGUiLCJibG9ja0luZGV4IiwicHJldmlvdXNDaXBoZXJ0ZXh0QmxvY2siLCJzdGVwcyIsInBsYWludGV4dEJ5dGVzIiwiZGVzY3JpcHRpb24iLCJleHBsYW5hdGlvbiIsImluaXRpYWxTdGF0ZSIsImFjdGl2ZUluZGljZXMiLCJBcnJheSIsImZyb20iLCJrZXlzIiwicHJldmlvdXNTdGF0ZSIsImZpbmFsU3RhdGUiLCJjb3VudGVyQmxvY2siLCJjb3VudGVyVmFsdWUiLCJzdW0iLCJhZnRlckluaXRpYWxSb3VuZCIsImFmdGVyU3ViQnl0ZXMiLCJhZnRlclNoaWZ0Um93cyIsInByZXZpb3VzU3RhdGVGb3JBZGRSb3VuZEtleSIsImFmdGVyTWl4Q29sdW1ucyIsImdldEFlc1N0ZXBzIiwicHJvdmlkZWRJdiIsInVuZGVmaW5lZCIsImFsbEJsb2NrcyIsIml2RGVzY3JpcHRpb24iLCJpdkV4cGxhbmF0aW9uIiwiY291bnRlciIsImNvbWJpbmVkRmluYWxTdGF0ZXMiLCJibG9ja1Jlc3VsdCIsImZpbmFsU3RhdGVUb1VzZSIsImZpbmFsV29yZEFycmF5IiwibGliIiwiV29yZEFycmF5IiwiY3JlYXRlIiwiVWludDhBcnJheSIsImZpbmFsQ2lwaGVydGV4dEJhc2U2NCIsIkJhc2U2NCIsInN0cmluZ2lmeSIsImZpbmFsQ2lwaGVydGV4dEhleCIsIkhleCIsImZpbmFsQ2lwaGVydGV4dEJpbmFyeSIsImZpbmFsQ2lwaGVydGV4dCIsImJhc2U2NCIsImhleCIsImJpbmFyeSIsImdldEtleUV4cGFuc2lvblN0ZXBzIiwiY3VycmVudEtleSIsInNib3hXb3JkIiwicmNvblZhbHVlIiwidHJhbnNmb3JtZWRXb3JkIiwiZmlyc3RXb3JkUHJldiIsInhvclJlc3VsdCIsImluZGV4IiwiYiIsImhpZ2hsaWdodGVkQ2VsbHMiLCJnZXRLZXlTY2hlZHVsZURldGFpbGVkU3RlcHMiLCJzdGVwc1BlclJvdW5kIiwic3RlcERldGFpbHMiLCJzdGVwIiwiaW5wdXQiLCJvdXRwdXQiLCJyY29uV29yZCIsInJjb24iLCJpbnB1dHMiLCJ3b3JkSW5kZXgiLCJyZWFsQWVzRW5jcnlwdCIsIm91dHB1dEZvcm1hdCIsIml2U3RyaW5nIiwia2V5SGV4IiwicmVxdWlyZWRIZXhDaGFycyIsInBhZEVuZCIsInN1YnN0cmluZyIsImtleVdvcmRBcnJheSIsInBhZGRpbmdPcHRpb24iLCJwYWQiLCJBbnNpWDkyMyIsIk5vUGFkZGluZyIsIm1vZGVPcHRpb24iLCJDQkMiLCJDVFIiLCJFQ0IiLCJlbmNyeXB0ZWQiLCJBRVMiLCJlbmNyeXB0IiwiYmFzZTY0T3V0cHV0IiwiY2lwaGVyUGFyYW1zIiwiQ2lwaGVyUGFyYW1zIiwiY2lwaGVydGV4dCIsImhleE91dHB1dCIsImZvcm1hdCIsImhleEJ5dGVzIiwibWF0Y2giLCJiaW5hcnlPdXRwdXQiLCJwcmltYXJ5T3V0cHV0IiwiZm9ybWF0cyIsInJlYWxBZXNEZWNyeXB0IiwiaW5wdXRGb3JtYXQiLCJjaXBoZXJ0ZXh0V29yZEFycmF5IiwiaGV4RnJvbUJpbmFyeSIsImJpbiIsImVycm9yIiwiZGVjcnlwdGVkIiwiZGVjcnlwdCIsIm1lc3NhZ2UiLCJ0ZXN0U3BlY2lmaWNDYXNlIiwiY3J5cHRvUmVzdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/aes.ts\n"));

/***/ })

});